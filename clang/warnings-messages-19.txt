# enabled by default:
#   -W (partial)
#     -Wextra (partial)
#       -Wignored-qualifiers (partial)
#             'A' qualifier on function type B has no effect
#             'A' qualifier on omitted return type B has no effect
#             ARC <unused|__unsafe_unretained|__strong|__weak|__autoreleasing> lifetime qualifier on return type is ignored
#         -Wignored-reference-qualifiers
#               'A' qualifier on reference type B has no effect
#       -Winitializer-overrides
#             initializer [partially ]overrides prior initialization of this subobject
#   -W#pragma-messages
#         The text of this diagnostic is not controlled by Clang
#   -Waarch64-sme-attributes (partial)
#         always_inline function B and its caller A have mismatching C attributes, inlining may change runtime behaviour
#   -Wabsolute-value
#         absolute value function A given an argument of type B but has parameter of type C which may cause truncation of value
#         taking the absolute value of <pointer|function|array> type B is suspicious
#         taking the absolute value of unsigned type A has no effect
#         using <integer|floating point|complex> absolute value function A when argument is of <integer|floating point|complex> type
#   -Wabstract-final-class
#         abstract class is marked '<final|sealed>'
#   -Waddress
#     -Wpointer-bool-conversion
#           address of <'B'|function 'B'|array 'B'|lambda function pointer conversion operator> will always evaluate to 'true'
#           nonnull <function call|parameter> 'B' will evaluate to 'true' on first encounter
#     -Wstring-compare
#           result of comparison against <a string literal|@encode> is unspecified (use an explicit string comparison function instead)
#     -Wtautological-pointer-compare
#           comparison of <address of|function|array> 'B' [not ]equal to a null pointer is always <true|false>
#           comparison of nonnull <function call|parameter> 'B' [not ]equal to a null pointer is '<true|false>' on first encounter
#   -Waddress-of-packed-member
#         taking address of packed member A of class or structure B may result in an unaligned pointer value
#   -Waddress-of-temporary
#         taking the address of a temporary object of type A
#   -Waix-compat
#         #pragma align(packed) may not be compatible with objects generated with AIX XL C/C++
#         alignment of 16 bytes for a struct member is not binary compatible with IBM XL C/C++ for AIX 16.1.0 or older
#   -Walias-template-in-declaration-name
#         a declarative nested name specifier cannot name an alias template
#   -Walign-mismatch
#         passing A-byte aligned argument to B-byte aligned parameter C[ of E] may result in an unaligned pointer access
#   -Walloca-with-align-alignof
#         second argument to __builtin_alloca_with_align is supposed to be in bits
#   -Wambiguous-delete
#         multiple suitable A functions for B; no 'operator delete' function will be invoked if initialization throws an exception
#   -Wambiguous-ellipsis
#         '...' in this location creates a C-style varargs function[, not a function parameter pack]
#   -Wambiguous-macro
#         ambiguous expansion of macro A
#   -Wambiguous-member-template
#         lookup of A in member access expression is ambiguous; using member of B
#   -Wambiguous-reversed-operator
#         ISO C++20 considers use of overloaded operator 'A' (with operand types B and C) to be ambiguous despite there being a unique best viable function[ with non-reversed arguments]
#   -Wanalyzer-incompatible-plugin
#         checker plugin 'A' is not compatible with this version of the analyzer
#   -Wandroid-unversioned-fallback
#         using unversioned Android target directory A for target B; unversioned directories will not be used in Clang 19 -- provide a versioned directory for the target version or lower instead
#   -Wanon-enum-enum-conversion (partial)
#     -Wdeprecated-anon-enum-enum-conversion
#           <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#   -Wanonymous-pack-parens
#         ISO C++11 requires a parenthesized pack declaration to have a name
#   -Wapinotes
#         The text of this diagnostic is not controlled by Clang
#   -Warc
#     -Warc-non-pod-memaccess
#           <destination for|source of> this B call is a pointer to ownership-qualified type C
#     -Warc-retain-cycles
#           capturing A strongly in this block is likely to lead to a retain cycle
#     -Warc-unsafe-retained-assign
#           assigning <array literal|dictionary literal|numeric literal|boxed expression|<should not happen>|block literal> to a weak <property|variable>; object will be released after assignment
#           assigning retained object to <weak|unsafe_unretained> <property|variable>; object will be released after assignment
#           assigning retained object to unsafe property; object will be released after assignment
#   -Warc-bridge-casts-disallowed-in-nonarc
#         'A' casts have no effect when not using ARC
#   -Warc-performSelector-leaks
#         performSelector may cause a leak because its selector is unknown
#   -Wargument-outside-range
#         argument value A is outside the valid range [B, C]
#   -Wargument-undefined-behaviour
#         argument value A will result in undefined behaviour
#   -Warm-interrupt-vfp-clobber
#         interrupt service routine with vfp enabled may clobber the interruptee's vfp state
#   -Warray-bounds
#         array argument is too small; <contains A elements|is of size A>, callee requires at least B
#         array index A is before the beginning of the array
#         array index A is past the end of the array (that has type B[, cast to D])
#         array index A refers past the last possible element for an array in B-bit address space containing C-bit (D-byte) elements (max possible E element(s))
#         the pointer incremented by A refers past the last possible element for an array in B-bit address space containing C-bit (D-byte) elements (max possible E element(s))
#   -Wasm
#     -Wasm-operand-widths
#           value size does not match register size specified by the constraint and modifier
#   -Wassume
#         assumption is ignored because it contains (potential) side-effects
#   -Watimport-in-framework-header
#         use of '@import' in framework header is discouraged, including this header requires -fmodules
#   -Watomic-access
#         accessing a member of an atomic structure or union is undefined behavior
#   -Watomic-alignment
#         large atomic operation may incur significant performance penalty; the access size (A bytes) exceeds the max lock-free size (B  bytes)
#         misaligned atomic operation may incur significant performance penalty; the expected alignment (A bytes) exceeds the actual alignment (B bytes)
#   -Watomic-memory-ordering
#         [success |failure ]memory order argument to atomic operation is invalid
#   -Watomic-property-with-user-defined-accessor
#         writable atomic property A cannot pair a synthesized <getter|setter> with a user defined <getter|setter>
#   -Wattribute-packed-for-bitfield
#         'packed' attribute was ignored on bit-fields with single-byte alignment in older versions of GCC and Clang
#   -Wattribute-warning
#         -mtocdata option is ignored for A because B
#         call to 'A' declared with 'warning' attribute: B
#   -Wattributes
#     -Wignored-attributes
#           '<pure|const>' attribute on function returning 'void'; attribute ignored
#           'A' attribute cannot be specified on a definition
#           'A' only applies to <function|pointer|Objective-C object or block pointer> types; type here is C
#           '[[<nodiscard|gnu::warn_unused_result>]]' attribute ignored when applied to a typedef; consider using '__attribute__((warn_unused_result))' or '[[clang::warn_unused_result]]' instead
#           '__clang__' is a predefined macro name, not an attribute scope specifier; did you mean '_Clang' instead?
#           'abi_tag' attribute on <non-inline|anonymous> namespace ignored
#           'cmse_nonsecure_entry' cannot be applied to functions with internal linkage
#           'const' attribute imposes more restrictions; 'pure' attribute ignored
#           'deprecated' attribute on anonymous namespace ignored
#           'dllexport' attribute ignored on explicit instantiation definition
#           'gnu_inline' attribute requires function to be marked 'inline', attribute ignored
#           'hybrid_patchable' is ignored on functions without external linkage
#           'internal_linkage' attribute on a non-static local variable is ignored
#           'mig_server_routine' attribute only applies to routines that return a kern_return_t
#           'nocf_check' attribute ignored; use -fcf-protection to enable the attribute
#           'noderef' can only be used on an array or pointer type
#           'nonnull' attribute applied to function with no pointer arguments
#           'nonnull' attribute when used on parameters takes no arguments
#           'nothrow' attribute conflicts with exception specification; attribute ignored
#           'objc_externally_retained' can only be applied to local variables <of retainable type|with strong ownership>
#           'require_constant_initialization' attribute added after initialization of variable
#           'sentinel' attribute only supported for variadic <functions|blocks>
#           'sentinel' attribute requires named arguments
#           'sycl_kernel' attribute only applies to a function template with at least two template parameters
#           'trivial_abi' cannot be applied to A
#           <MIPS|MSP430|RISC-V> 'interrupt' attribute only applies to functions that have <no parameters|a 'void' return type>
#           <alias|ifunc> will always resolve to A even if weak definition of B is overridden
#           <alias|ifunc> will not be in section 'A' but in the same section as the <aliasee|resolver>
#           <alignment|size> of field B (C bits) does not match the <alignment|size> of the first field in transparent union; transparent_union attribute ignored
#           <unsupported|duplicate|unknown>[ CPU| tune CPU] 'C' in the '<target|target_clones|target_version>' attribute string; '<target|target_clones|target_version>' attribute ignored
#           A attribute argument 'B' not supported on a global variable
#           A attribute argument not supported: B
#           A attribute can only be applied to instance variables or properties
#           A attribute ignored
#           A attribute ignored for field of type B
#           A attribute ignored on a non-definition declaration
#           A attribute ignored on inline function
#           A attribute ignored on local class[ member]
#           A attribute ignored when parsing type
#           A attribute is deprecated and ignored in B
#           A attribute is ignored because B is not a function pointer
#           A attribute is ignored because there exists no call expression inside the statement
#           A attribute isn't implemented by this Objective-C runtime
#           A attribute only applies to <Objective-C object|pointer|pointer-to-CF-pointer|pointer/reference-to-OSObject-pointer> parameters
#           A attribute only applies to <functions|methods|properties> that return <an Objective-C object|a pointer|a non-retainable pointer>
#           A attribute only applies to a pointer or reference (B is invalid)
#           A attribute only applies to return values that are pointers
#           A attribute only applies to return values that are pointers or references
#           A attribute only applies to[ constant] pointer arguments
#           A calling convention is not supported <for this target|on variadic function|on constructor/destructor|on builtin function>
#           A currently has no effect on a using declaration
#           A redeclared inline; B attribute ignored
#           A[ attribute] only applies to <functions|unions|variables and functions|functions and methods|functions, methods and blocks|functions, methods, and parameters|variables|variables and fields|variables, data members and tag types|types and namespaces|variables, functions and classes|kernel functions|non-K&R-style functions>
#           A[ attribute] only applies to C
#           Objective-C GC does not allow weak variables on the stack
#           __declspec attribute A is not supported
#           __weak attribute cannot be specified on a field declaration
#           __weak attribute cannot be specified on an automatic variable when ARC is not enabled
#           attribute A after definition is ignored
#           attribute A cannot be applied to <functions|Objective-C method> without return value
#           attribute A has no effect when annotating an 'if <constexpr|consteval>' statement
#           attribute A has no effect when annotating an infinite loop
#           attribute A ignored, because it cannot be applied to a type
#           attribute A ignored, because it cannot be applied to omitted return type
#           attribute A ignored, because it is not attached to a declaration
#           attribute A is already applied
#           attribute A is already applied with different arguments
#           attribute A is ignored, place it after "<class|struct|interface|union|enum|enum class|enum struct>" to apply attribute to type declaration
#           attribute declaration must precede definition
#           attribute is ignored on this statement as it only applies to functions; use 'A' on statements
#           conflicting attributes A are ignored
#           direct attribute on property A ignored (not implemented by this Objective-C runtime)
#           first field of a transparent union cannot have <floating point|vector> type B; transparent_union attribute ignored
#           function template with 'sycl_kernel' attribute must have a 'void' return type
#           function template with 'sycl_kernel' attribute must have a single parameter
#           ignoring __declspec(allocator) because the function return type A is not a pointer or reference type
#           import <module|name> (B) does not match the import <module|name> (C) of the previous declaration
#           import <module|name> cannot be applied to a function with a definition
#           inheritance model ignored on <primary template|partial specialization>
#           maxclusterrank requires sm_90 or higher, CUDA arch provided: A, ignoring B attribute
#           qualifiers after comma in declarator list are ignored
#           repeated RISC-V 'interrupt' attribute
#           requested alignment is less than minimum alignment of B for type A
#           statement attribute A has higher precedence than function attribute '<always_inline|flatten|noinline>'
#           template parameter of a function template with the 'sycl_kernel' attribute cannot be a non-type template parameter
#           transparent union definition must contain at least one field; transparent_union attribute ignored
#           transparent_union attribute can only be applied to a union definition; attribute ignored
#           unknown attribute 'A'
#           unknown visibility A
#     -Wunknown-attributes
#           unknown attribute A ignored
#   -Wauto-disable-vptr-sanitizer
#         implicitly disabling vptr sanitizer because rtti wasn't enabled
#   -Wauto-storage-class
#         'auto' storage class specifier is not permitted in C++11, and will not be supported in future releases
#   -Wauto-var-id
#         'auto' deduced as 'id' in declaration of A
#   -Wavailability
#         'unavailable' availability overrides all other availability information
#         Fuchsia API Level prohibits specifying a minor or sub-minor version
#         [overriding ]method <introduced after|deprecated before|obsoleted before> <the protocol method it implements|overridden method> on B (C vs. D)
#         [overriding ]method cannot be unavailable on A when <the protocol method it implements|its overridden method> is available
#         availability does not match previous declaration
#         feature cannot be <introduced|deprecated|obsoleted> in B version C before it was <introduced|deprecated|obsoleted> in version E; attribute ignored
#         ignoring availability attribute <on '+load' method|with constructor attribute|with destructor attribute>
#         only 'unavailable' and 'deprecated' are supported for Swift availability
#         unknown environment A in availability macro
#         unknown platform A in availability macro
#         use same version number separators '_' or '.'; as in 'major[.minor[.subminor]]'
#   -Wavr-rtlib-linking-quirks
#         no avr-libc installation can be found on the system, cannot link standard libraries
#         no target microcontroller specified on command line, cannot link standard libraries, please pass -mmcu=<mcu name>
#         standard library not linked and so no interrupt vector table or compiler runtime routines will be linked
#         support for linking stdlibs for microcontroller 'A' is not implemented
#         support for passing the data section address to the linker for microcontroller 'A' is not implemented
#   -Wbackend-plugin
#         A (B) exceeds limit (C) in 'D'
#         The text of this diagnostic is not controlled by Clang
#   -Wbackslash-newline-escape
#         backslash and newline separated by space
#   -Wbinding-in-condition
#         ISO C++17 does not permit structured binding declaration in a condition
#   -Wbitfield-width
#         width of bit-field A (B bits) exceeds the width of its type; value will be truncated to C bit(s)
#   -Wblock-capture-autoreleasing
#         block captures an autoreleasing out-parameter, which may result in use-after-free bugs
#   -Wbool-conversions
#     -Wbool-conversion
#           initialization of pointer of type A to null from a constant boolean expression
#       -Wpointer-bool-conversion
#             address of <'B'|function 'B'|array 'B'|lambda function pointer conversion operator> will always evaluate to 'true'
#             nonnull <function call|parameter> 'B' will evaluate to 'true' on first encounter
#       -Wundefined-bool-conversion
#             'this' pointer cannot be null in well-defined C++ code; pointer may be assumed to always convert to true
#             reference cannot be bound to dereferenced null pointer in well-defined C++ code; pointer may be assumed to always convert to true
#   -Wbounds-safety-counted-by-elt-type-unknown-size
#         '<counted_by|sized_by|counted_by_or_null|sized_by_or_null>' <cannot|should not> be applied to <a pointer with pointee|an array with element> of unknown size because B is <an incomplete type|a sizeless type|a function type|a struct type with a flexible array member[. This will be an error in a future compiler version]>
#   -Wbraced-scalar-init
#         braces around [scalar ]initializer
#   -Wbranch-protection
#         '-mbranch-protection=' option is incompatible with the 'A' architecture
#         ignoring the 'branch-protection' attribute because the 'A' architecture does not support it
#         invalid branch protection option 'A' in 'B'
#         unsupported branch protection specification 'A'
#   -Wbridge-cast
#         A bridges to B, not C
#         A cannot bridge to B
#   -Wbuiltin-assume-aligned-alignment
#         requested alignment must be A bytes or smaller; maximum alignment assumed
#   -Wbuiltin-memcpy-chk-size
#         'A' will always overflow; destination buffer has size B, but size argument is C
#   -Wbuiltin-requires-header
#         declaration of built-in function 'B' requires inclusion of the header <A>
#   -Wc++0x-compat (partial)
#     -Wc++11-compat (partial)
#           integer literal is too large to be represented in type 'long' and is subject to undefined behavior under C++98, interpreting as 'unsigned long'; this literal will <have type 'long long'|be ill-formed> in C++11 onwards
#           integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C++98; this literal will <have type 'long long'|be ill-formed> in C++11 onwards
#           use of right-shift operator ('>>') in template argument will require parentheses in C++11
#       -Wc++11-compat-deprecated-writable-strings
#             conversion from string literal to A is deprecated
#       -Wc++11-narrowing (partial)
#             <case value|enumerator value|non-type template argument|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#             constant expression evaluates to A which cannot be narrowed to type B
#             non-constant-expression cannot be narrowed from type A to B in initializer list
#             type A cannot be narrowed to B in initializer list
#         -Wc++11-narrowing-const-reference
#               constant expression evaluates to A which cannot be narrowed to type B
#               non-constant-expression cannot be narrowed from type A to B in initializer list
#               type A cannot be narrowed to B in initializer list
#   -Wc++0x-extensions (partial)
#     -Wc++11-extensions (partial)
#           'A' keyword is a C++11 extension
#           'auto' type specifier is a C++11 extension
#           'template' keyword outside of a template
#           'typename' occurs outside of a template
#           <defaulted|deleted> function definitions are a C++11 extension
#           alias declarations are a C++11 extension
#           default member initializer for non-static data member is a C++11 extension
#           default template arguments for a function template are a C++11 extension
#           explicit conversion functions are a C++11 extension
#           generalized initializer lists are a C++11 extension
#           lambdas are a C++11 extension
#           non-class friend type A is a C++11 extension
#           non-type template argument referring to <function|object> B with internal linkage is a C++11 extension
#           range-based for loop is a C++11 extension
#           reference qualifiers on functions are a C++11 extension
#           rvalue references are a C++11 extension
#           scoped enumerations are a C++11 extension
#           static data member A in union is a C++11 extension
#           unelaborated friend declaration is a C++11 extension; specify '<struct|interface|union|class|enum>' to befriend B
#           use of enumeration in a nested name specifier is a C++11 extension
#           variadic templates are a C++11 extension
#       -Wc++11-inline-namespace
#             inline namespaces are a C++11 feature
#   -Wc++0x-narrowing (partial)
#     -Wc++11-narrowing (partial)
#           <case value|enumerator value|non-type template argument|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#           constant expression evaluates to A which cannot be narrowed to type B
#           non-constant-expression cannot be narrowed from type A to B in initializer list
#           type A cannot be narrowed to B in initializer list
#       -Wc++11-narrowing-const-reference
#             constant expression evaluates to A which cannot be narrowed to type B
#             non-constant-expression cannot be narrowed from type A to B in initializer list
#             type A cannot be narrowed to B in initializer list
#   -Wc++11-compat-pedantic (partial)
#     -Wc++11-compat (partial)
#           integer literal is too large to be represented in type 'long' and is subject to undefined behavior under C++98, interpreting as 'unsigned long'; this literal will <have type 'long long'|be ill-formed> in C++11 onwards
#           integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C++98; this literal will <have type 'long long'|be ill-formed> in C++11 onwards
#           use of right-shift operator ('>>') in template argument will require parentheses in C++11
#       -Wc++11-compat-deprecated-writable-strings
#             conversion from string literal to A is deprecated
#       -Wc++11-narrowing (partial)
#             <case value|enumerator value|non-type template argument|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#             constant expression evaluates to A which cannot be narrowed to type B
#             non-constant-expression cannot be narrowed from type A to B in initializer list
#             type A cannot be narrowed to B in initializer list
#         -Wc++11-narrowing-const-reference
#               constant expression evaluates to A which cannot be narrowed to type B
#               non-constant-expression cannot be narrowed from type A to B in initializer list
#               type A cannot be narrowed to B in initializer list
#   -Wc++17-compat-pedantic (partial)
#     -Wc++17-compat (partial)
#       -Wc++17-compat-mangling
#             mangled name of A will change in C++17 due to non-throwing exception specification in function signature
#       -Wdeprecated-increment-bool
#             incrementing expression of type bool is deprecated and incompatible with C++17
#       -Wdeprecated-register
#             'register' storage class specifier is deprecated and incompatible with C++17
#   -Wc++1y-extensions (partial)
#     -Wc++14-extensions (partial)
#           'decltype(auto)' type specifier is a C++14 extension
#           initialized lambda captures are a C++14 extension
#           multiple return statements in constexpr function is a C++14 extension
#           type definition in a constexpr <function|constructor> is a C++14 extension
#           use of this statement in a constexpr <function|constructor> is a C++14 extension
#           variable declaration in a constexpr <function|constructor> is a C++14 extension
#           variable templates are a C++14 extension
#   -Wc++1z-compat (partial)
#     -Wc++17-compat (partial)
#       -Wc++17-compat-mangling
#             mangled name of A will change in C++17 due to non-throwing exception specification in function signature
#       -Wdeprecated-increment-bool
#             incrementing expression of type bool is deprecated and incompatible with C++17
#       -Wdeprecated-register
#             'register' storage class specifier is deprecated and incompatible with C++17
#   -Wc++1z-compat-mangling
#     -Wc++17-compat-mangling
#           mangled name of A will change in C++17 due to non-throwing exception specification in function signature
#   -Wc++1z-extensions (partial)
#     -Wc++17-extensions (partial)
#           '<if|switch>' initialization statements are a C++17 extension
#           'begin' and 'end' returning different types (A and B) is a C++17 extension
#           'constexpr' on lambda expressions is a C++17 extension
#           'static_assert' with no message is a C++17 extension
#           capture of '*this' by copy is a C++17 extension
#           constexpr if is a C++17 extension
#           decomposition declarations are a C++17 extension
#           default scope specifier for attributes is a C++17 extension
#           inline variables are a C++17 extension
#           nested namespace definition is a C++17 extension; define each namespace separately
#           pack expansion of using declaration is a C++17 extension
#           pack fold expression is a C++17 extension
#           template template parameter using 'typename' is a C++17 extension
#           use of multiple declarators in a single using declaration is a C++17 extension
#   -Wc++2a-compat (partial)
#     -Wc++20-compat (partial)
#           '<=>' is a single token in C++20; add a space to avoid a change in behavior
#           taking address of non-addressable standard library function is incompatible with C++20
#   -Wc++2a-compat-pedantic (partial)
#     -Wc++20-compat-pedantic (partial)
#       -Wc++20-compat (partial)
#             '<=>' is a single token in C++20; add a space to avoid a change in behavior
#             taking address of non-addressable standard library function is incompatible with C++20
#   -Wc++2a-extensions (partial)
#     -Wc++20-extensions (partial)
#           captured structured bindings are a C++20 extension
#           constexpr constructor that does not initialize all members is a C++20 extension
#           constexpr union constructor that does not initialize any member is a C++20 extension
#           decomposition declaration declared <'B'|with 'B' specifiers> is a C++20 extension
#           default member initializer for bit-field is a C++20 extension
#           defaulted comparison operators are a C++20 extension
#           explicit capture of 'this' with a capture default of '=' is a C++20 extension
#           explicit template parameter list for lambdas is a C++20 extension
#           explicit(bool) is a C++20 extension
#           function try block in constexpr <function|constructor> is a C++20 extension
#           initialized lambda pack captures are a C++20 extension
#           inline nested namespace definition is a C++20 extension
#           missing 'typename' prior to dependent type name AB; implicit 'typename' is a C++20 extension
#           range-based for loop initialization statements are a C++20 extension
#           uninitialized variable in a constexpr <function|constructor> is a C++20 extension
#           use of function template name with no prior declaration in function call with explicit template arguments is a C++20 extension
#           use of this statement in a constexpr <function|constructor> is a C++20 extension
#           using declaration naming a scoped enumerator is a C++20 extension
#           using enum declaration is a C++20 extension
#   -Wc++2b-extensions
#     -Wc++23-extensions
#           'size_t' suffix for literals is a C++23 extension
#           alias declaration in this context is a C++23 extension
#           consteval if is a C++23 extension
#           declaring overloaded A as 'static' is a C++23 extension
#           definition of a <static|thread_local> variable in a constexpr <function|constructor> is a C++23 extension
#           label at end of compound statement is a C++23 extension
#           lambda without a parameter clause is a C++23 extension
#           static lambdas are a C++23 extension
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is a C++23 extension
#           use of this statement in a constexpr <function|constructor> is a C++23 extension
#       -Wc++23-lambda-attributes
#             <an attribute specifier sequence|A> in this position is a C++23 extension
#   -Wc++2c-compat
#     -Wdelete-incomplete
#           cannot delete expression with pointer-to-'void' type A
#           deleting pointer to incomplete type A is incompatible with C++2c and may cause undefined behavior
#   -Wc++2c-extensions (partial)
#     -Wc++26-extensions (partial)
#           '= delete' with a message is a C++2c extension
#           an attribute specifier sequence attached to a structured binding declaration is a C++2c extension
#           pack indexing is a C++2c extension
#           placeholder variables are a C++2c extension
#   -Wc2x-extensions (partial)
#     -Wc23-extensions (partial)
#           #embed is a <C23|Clang> extension
#           '_BitInt' suffix for literals is a C23 extension
#           '_Static_assert' with no message is a C23 extension
#           label at end of compound statement is a C23 extension
#           label followed by a declaration is a C23 extension
#           omitting the parameter name in a function definition is a C23 extension
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is a C23 extension
#   -Wc99-compat (partial)
#         integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C89; this literal will <have type 'long long'|be ill-formed> in C99 onwards
#   -Wc99-extensions (partial)
#         ISO C99 requires whitespace after the macro name
#     -Wc99-designator (partial)
#           array designators are a C99 extension
#           brace elision for designated initializer is a C99 extension
#           mixture of designated and non-designated initializers in the same initializer list is a C99 extension
#           nested designators are a C99 extension
#   -Wcall-to-pure-virtual-from-ctor-dtor
#         call to pure virtual member function A has undefined behavior; overrides of A in subclasses are not available in the <constructor|destructor> of C
#   -Wcalled-once-parameter (partial)
#         A parameter marked 'called_once' is called twice
#         A parameter marked 'called_once' is never <used|called> when <taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches>
#         [captured ]A parameter marked 'called_once' is never called
#   -Wcast-calling-convention
#         cast between incompatible calling conventions 'A' and 'B'; calls through this pointer may abort at runtime
#   -Wcast-qual-unrelated
#         ISO C++ does not allow [const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast] from B to C because it casts away qualifiers, even though the source and destination types are unrelated
#   -WCFString-literal
#         input conversion stopped due to an input byte that does not belong to the input codeset UTF-8
#   -WCL4 (partial)
#     -Wall (partial)
#       -Wmost (partial)
#         -Wcast-of-sel-type
#               cast of type A to B is deprecated; use sel_getName instead
#         -Wcomment (partial)
#               '/*' within block comment
#               escaped newline between */ characters at block comment end
#         -Wdelete-non-virtual-dtor (partial)
#           -Wdelete-abstract-non-virtual-dtor
#                 <delete|destructor> called on B that is abstract but has non-virtual destructor
#         -Wextern-c-compat
#               [empty ]<struct|union> has size 0 in C, <size 1|non-zero size> in C++
#         -Wformat
#               '%n' specifier not supported on this platform
#               '<*|.*>' specified field <width|precision> is missing a matching 'int' argument
#               'A' is not a valid object format flag
#               <field width|precision> used with 'B' conversion specifier, resulting in undefined behavior
#               <values of type|enum values with underlying type> 'A' should not be used as format arguments; add an explicit cast to B instead
#               cannot mix positional and non-positional arguments in format string
#               data argument position 'A' exceeds the number of data arguments (B)
#               field <width|precision> should have type B, but argument has type C
#               flag 'A' is ignored when flag 'B' is present
#               flag 'A' results in undefined behavior with 'B' conversion specifier
#               format specifies type A but the argument has <type|underlying type> B
#               format string contains '\0' within the string body
#               format string is not null-terminated
#               format string missing
#               format string should not be a wide string
#               incomplete format specifier
#               invalid position specified for <field width|field precision>
#               length modifier 'A' results in undefined behavior or no effect with 'B' conversion specifier
#               missing object format flag
#               no closing ']' for '%[' in scanf format string
#               object format flags cannot be used with 'A' conversion specifier
#               position arguments in format strings start counting at 1 (not 0)
#               using '%P' format specifier with an Objective-C pointer results in dumping runtime object structure, not object value
#               using '%P' format specifier without precision
#               using 'A' format specifier annotation outside of os_log()/os_trace()
#               using 'A' format specifier, but argument has boolean value
#               zero field width in scanf format string is unused
#           -Wformat-extra-args
#                 data argument not used by format string
#           -Wformat-insufficient-args
#                 more '%' conversions than data arguments
#           -Wformat-invalid-specifier
#                 invalid conversion specifier 'A'
#           -Wformat-overflow
#                 'A' will always overflow; destination buffer has size B, but format string expands to at least C,1,2
#             -Wformat-overflow-non-kprintf
#                   'A' will always overflow; destination buffer has size B, but format string expands to at least C,1,2
#           -Wformat-security
#                 format string is not a string literal (potentially insecure)
#           -Wformat-truncation
#                 'A' will always be truncated; specified size is B, but format string expands to at least C,1,2
#             -Wformat-truncation-non-kprintf
#                   'A' will always be truncated; specified size is B, but format string expands to at least C,1,2
#           -Wformat-zero-length
#                 format string is empty
#           -Wnonnull
#                 null passed to a callee that requires a non-null argument
#                 null returned from <function|method> that requires a non-null return value
#         -Wimplicit (partial)
#           -Wimplicit-function-declaration (partial)
#                 call to undeclared function A; ISO C99 and later do not support implicit function declarations
#                 call to undeclared library function 'A' with type B; ISO C99 and later do not support implicit function declarations
#                 implicitly declaring library function 'A' with type B
#                 use of unknown builtin A
#           -Wimplicit-int (partial)
#                 parameter A was not declared, defaults to 'int'; ISO C99 and later do not support implicit int
#                 type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int
#         -Wmultichar
#               multi-character character constant
#         -Wobjc-designated-initializers
#               convenience initializer missing a 'self' call to another initializer
#               convenience initializer should not invoke an initializer on 'super'
#               designated initializer invoked a non-designated initializer
#               designated initializer missing a 'super' call to a designated initializer of the super class
#               designated initializer should only invoke a designated initializer on 'super'
#               method override for the designated initializer of the superclass A not found
#         -Wobjc-flexible-array
#               field A can overwrite instance variable B with variable sized type C in superclass D
#               field A with variable sized type B is not visible to subclasses and can conflict with their instance variables
#         -Wobjc-missing-super-calls
#               method possibly missing a [super A] call
#         -Wprivate-extern
#               use of __private_extern__ on a declaration may not produce external symbol private to the linkage unit and is deprecated
#         -Wreorder (partial)
#           -Wreorder-init-list
#                 ISO C++ requires field designators to be specified in declaration order; field B will be initialized after field A
#         -Wreturn-type
#               non-void coroutine does not return a value
#               non-void coroutine does not return a value in all control paths
#               non-void function does not return a value
#               non-void function does not return a value in all control paths
#               non-void lambda does not return a value
#               non-void lambda does not return a value in all control paths
#           -Wreturn-mismatch
#                 <void function|void method|constructor|destructor> A should not return a value
#                 non-void <function|method> A should return a value
#           -Wreturn-type-c-linkage
#                 A has C-linkage specified, but returns incomplete type B which could be incompatible with C
#                 A has C-linkage specified, but returns user-defined type B which is incompatible with C
#         -Wself-assign (partial)
#           -Wself-assign-field
#                 assigning <field|instance variable> to itself
#         -Wsizeof-array-argument
#               sizeof on array function parameter will return size of A instead of B
#         -Wsizeof-array-decay
#               sizeof on pointer operation will return size of A instead of B
#         -Wstring-plus-int
#               adding A to a string does not append to the string
#         -Wtautological-compare (partial)
#               <aligning a value|the result of checking whether a value is aligned> to 1 byte is <a no-op|always true>
#               <self-|array >comparison always evaluates to <a constant|true|false|'std::strong_ordering::equal'>
#           -Wtautological-constant-compare
#                 converting the result of '<<' to a boolean always evaluates to <false|true>
#                 converting the result of '?:' with integer constants to a boolean always evaluates to 'true'
#                 result of comparison of <constant A|true|false> with <expression of type C|boolean expression> is always E
#             -Wtautological-constant-out-of-range-compare
#                   result of comparison of <constant A|true|false> with <expression of type C|boolean expression> is always E
#           -Wtautological-objc-bool-compare
#                 result of comparison of constant A with expression of type 'BOOL' is always B, as the only well defined values for 'BOOL' are YES and NO
#           -Wtautological-pointer-compare
#                 comparison of <address of|function|array> 'B' [not ]equal to a null pointer is always <true|false>
#                 comparison of nonnull <function call|parameter> 'B' [not ]equal to a null pointer is '<true|false>' on first encounter
#           -Wtautological-undefined-compare
#                 'this' pointer cannot be null in well-defined C++ code; comparison may be assumed to always evaluate to <true|false>
#                 reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to always evaluate to <true|false>
#         -Wtrigraphs
#               ignored trigraph would end block comment
#               trigraph converted to 'A' character
#               trigraph ends block comment
#               trigraph ignored
#         -Wuninitialized (partial)
#               base class A is uninitialized when used here to access B
#               field A is uninitialized when used here
#               reference A is not yet bound to a value when used here
#               reference A is not yet bound to a value when used within its own initialization
#               variable A is uninitialized when used within its own initialization
#           -Wstatic-self-init
#                 static variable A is suspiciously used within its own initialization
#         -Wunknown-pragmas (partial)
#               #pragma execution_character_set expected 'A'
#               #pragma execution_character_set expected 'push' or 'pop'
#               #pragma execution_character_set invalid value 'A', only 'UTF-8' is supported
#               #pragma warning expected 'A'
#               #pragma warning expected 'push', 'pop', 'default', 'disable', 'error', 'once', 'suppress', 1, 2, 3, or 4
#               #pragma warning expected a warning number
#               #pragma warning(push, level) requires a level between 0 and 4
#               angle-bracketed include <A> cannot be aliased to double-quoted include "B"
#               double-quoted include "A" cannot be aliased to angle-bracketed include <B>
#               expected 'ON' or 'OFF' or 'DEFAULT' in pragma
#               expected end of directive in pragma
#               pragma STDC FENV_ROUND is not supported
#               pragma diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'
#               pragma diagnostic expected option name (e.g. "-Wundef")
#               pragma diagnostic pop could not pop, no matching push
#               pragma include_alias expected 'A'
#               pragma include_alias expected include filename
#               unexpected token in pragma diagnostic
#               unknown pragma in STDC namespace
#         -Wunused (partial)
#           -Wunused-value
#                 container access result unused - container access should not be used for side effects
#                 expression result unused
#                 expression result unused; should this cast be to 'void'?
#                 ignoring return value of function declared with A attribute
#                 ignoring temporary created by a constructor declared with A attribute
#                 ignoring temporary created by a constructor declared with A attribute: B
#                 left operand of comma operator has no effect
#             -Wunevaluated-expression
#                   expression with side effects has no effect in an unevaluated context
#               -Wpotentially-evaluated-expression
#                     expression with side effects will be evaluated despite being used as an operand to 'typeid'
#             -Wunused-comparison
#                   <equality|inequality|relational|three-way> comparison result unused
#             -Wunused-result
#                   ignoring return value of function declared with A attribute
#                   ignoring return value of function declared with A attribute: B
#         -Wuser-defined-warnings
#               The text of this diagnostic is not controlled by Clang
#       -Wparentheses (partial)
#             A has lower precedence than B; B will be evaluated first
#             comparisons like 'X<=Y<=Z' don't have their mathematical meaning
#             operator '?:' has lower precedence than 'A'; 'A' will be evaluated first
#             using the result of an assignment as a condition without parentheses
#         -Wbitwise-conditional-parentheses
#               operator '?:' has lower precedence than 'A'; 'A' will be evaluated first
#         -Wdangling-else
#               add explicit braces to avoid dangling else
#         -Wlogical-not-parentheses
#               logical not is only applied to the left hand side of this <comparison|bitwise operator>
#         -Woverloaded-shift-op-parentheses
#               overloaded operator <>>|<<> has higher precedence than comparison operator
#         -Wparentheses-equality
#               equality comparison with extraneous parentheses
#         -Wshift-op-parentheses
#               operator 'A' has lower precedence than 'B'; 'B' will be evaluated first
#       -Wswitch
#             <enumeration value B not handled in switch|enumeration values B and C not handled in switch|enumeration values B, C, and D not handled in switch|A enumeration values not handled in switch>
#             case value not in enumerated type A
#             overflow converting case value to switch condition type (A to B)
#       -Wswitch-bool
#             switch condition has boolean value
#       -Wvla-cxx-extension (partial)
#             variable length arrays in C++ are a Clang extension
#         -Wvla-extension-static-assert (partial)
#               variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?
#     -Wextra (partial)
#       -Wignored-qualifiers (partial)
#             'A' qualifier on function type B has no effect
#             'A' qualifier on omitted return type B has no effect
#             ARC <unused|__unsafe_unretained|__strong|__weak|__autoreleasing> lifetime qualifier on return type is ignored
#         -Wignored-reference-qualifiers
#               'A' qualifier on reference type B has no effect
#       -Winitializer-overrides
#             initializer [partially ]overrides prior initialization of this subobject
#   -Wclang-cl-pch
#         #pragma hdrstop filename not supported, /Fp can be used to specify precompiled header filename
#         definition of macro A does not match definition in precompiled header
#         support for '/Yc' and '/Yu' with different filenames not implemented yet; flags ignored
#         support for '/Yc' with more than one source file not implemented yet; flag ignored
#   -Wclass-conversion
#         conversion function converting A to B will never be used
#         conversion function converting A to its base class B will never be used
#         conversion function converting A to itself will never be used
#   -Wclass-varargs (partial)
#     -Wnon-pod-varargs
#           cannot pass <non-POD|non-trivial> object of type B to variadic <function|block|method|constructor>; expected type from format string was D
#           cannot pass object of <non-POD|non-trivial> type B through variadic <function|block|method|constructor>; call will abort at runtime
#           second argument to 'va_arg' is of ARC ownership-qualified type A
#           second argument to 'va_arg' is of non-POD type A
#   -Wcmse-union-leak
#         passing union across security boundary via <parameter B|return value> may leak information
#   -Wcomments (partial)
#     -Wcomment (partial)
#           '/*' within block comment
#           escaped newline between */ characters at block comment end
#   -Wcompare-distinct-pointer-types
#         comparison of distinct pointer types
#   -Wcompound-token-split (partial)
#     -Wcompound-token-split-by-macro
#           [B and ]C tokens <introducing statement expression|terminating statement expression|introducing attribute|terminating attribute|forming pointer to member type>,1,2,3 appear in different macro expansion contexts
#   -Wconditional-type-mismatch
#         pointer/integer type mismatch in conditional expression
#   -Wconfig-macros
#         <definition|#undef> of configuration macro 'B' has no effect on the import of 'C'; pass '<-DB=...|-UB>' on the command line to configure the module
#   -Wconstant-evaluated
#         'A' will always evaluate to 'true' in a manifestly constant-evaluated expression
#   -Wconstant-logical-operand
#         use of logical 'A' with constant operand
#   -Wconstexpr-not-const
#         'constexpr' non-static member function will not be implicitly 'const' in C++14; add 'const' to avoid a change in behavior
#   -Wconversion-null
#     -Wnull-conversion
#           implicit conversion of <NULL|nullptr> constant to B
#   -Wcoroutine
#         return type of 'coroutine_handle<>::address should be 'void*' (have A) in order to get capability with existing async C API
#     -Walways-inline-coroutine
#           this coroutine may be split into pieces; not every piece is guaranteed to be inlined
#     -Wcoro-non-aligned-allocation-function
#           under -fcoro-aligned-allocation, the non-aligned allocation function for the promise type A has higher precedence than the global aligned allocation function
#     -Wcoroutine-missing-unhandled-exception
#           A is required to declare the member 'unhandled_exception()' when exceptions are enabled
#     -Wdeprecated-coroutine
#           'for co_await' belongs to CoroutineTS instead of C++20, which is deprecated
#   -Wcpp
#     -W#warnings
#           The text of this diagnostic is not controlled by Clang
#   -Wctu
#         imported AST from 'A' had been generated for a different target, current: B, imported: C
#   -Wcuda-compat (partial)
#         A attribute parameter B is negative and will be ignored
#         argument to '#pragma unroll' should not be in parentheses in CUDA C/C++
#         ignored 'inline' attribute on kernel function A
#         nvcc does not allow '__A__' to appear after the parameter list in lambdas
#   -Wcxx-attribute-extension
#         ISO C++ does not allow <an attribute list|A> to appear here
#   -Wdangling (partial)
#         <temporary <whose address is used as value of|[implicitly ]bound to> <[reference ]member of local variable|local <variable|reference>>|array backing <initializer list subobject of local variable|local initializer list>> [D ]will be destroyed at the end of the full-expression
#         lifetime extension of <temporary|backing array of initializer list> created by aggregate initialization using a default member initializer is not yet supported; lifetime of <temporary|backing array> will end at the end of the full-expression
#     -Wdangling-assignment
#           object backing the pointer A will be destroyed at the end of the full-expression
#     -Wdangling-field
#           <reference|backing array for 'std::initializer_list'> [subobject of ]member A <binds to|is> a temporary object whose lifetime is shorter than the lifetime of the constructed object
#           binding reference member A to stack allocated <variable|parameter> B
#           initializing pointer member A with the stack address of <variable|parameter> B
#           temporary bound to reference member of allocated object will be destroyed at the end of the full-expression
#     -Wdangling-gsl
#           initializing pointer member A to point to a temporary object whose lifetime is shorter than the lifetime of the constructed object
#           object backing the pointer will be destroyed at the end of the full-expression
#     -Wdangling-initializer-list
#           array backing <initializer list subobject of the allocated object|the allocated initializer list> will be destroyed at the end of the full-expression
#     -Wreturn-stack-address
#           <address of|reference to> stack memory associated with <local variable|parameter|compound literal> B returned
#           returning <address of|reference to> local temporary object
#           returning address of label, which is local
#   -Wdarwin-sdk-settings
#         SDK settings were ignored as 'SDKSettings.json' could not be parsed
#   -Wdealloc-in-category
#         -dealloc is being overridden in a category
#   -Wdebug-compression-unavailable
#         cannot compress debug sections (A not enabled)
#   -Wdefaulted-function-deleted
#         explicitly defaulted <<ERROR>|equality|three-way|relational> comparison operator is implicitly deleted
#         explicitly defaulted <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> is implicitly deleted
#   -Wdelayed-template-parsing-in-cxx20
#         -fdelayed-template-parsing is deprecated after C++20
#   -Wdelegating-ctor-cycles
#         constructor for A creates a delegation cycle
#   -Wdeprecate-lax-vec-conv-all
#         implicit conversion between vector types ('A' and 'B') is deprecated; in the future, the behavior implied by '-fno-lax-vector-conversions' will be the default
#   -Wdeprecated (partial)
#         'depend' clause for 'ordered' is deprecated; use 'doacross' instead
#         -O4 is equivalent to -O3
#         A does not support the option 'B'
#         access declarations are deprecated; use using declarations instead
#         argument 'A' is deprecated, B
#         argument 'A' is deprecated[, use 'C' instead]
#         minus(-) operator for reductions is deprecated; use + or user defined reduction instead
#         treating 'A' input as 'B' when in C++ mode, this behavior is deprecated
#         use of 'long' with '__vector' is deprecated
#     -Wdeprecated-anon-enum-enum-conversion
#           <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#     -Wdeprecated-array-compare
#           comparison between two arrays is deprecated; to compare array addresses, use unary '+' to decay operands to pointers
#     -Wdeprecated-attributes
#           applying attribute A to a declaration is deprecated; apply it to the type instead
#           specifying vector types with the 'mode' attribute is deprecated; use the 'vector_size' attribute instead
#           the '[[_Noreturn]]' attribute spelling is deprecated in C23; use '[[noreturn]]' instead
#     -Wdeprecated-builtins
#           builtin A is deprecated; use B instead
#     -Wdeprecated-comma-subscript
#           top-level comma expression in array subscript is deprecated in C++20 and unsupported in C++23
#     -Wdeprecated-declarations
#           A is deprecated
#           A is deprecated: B
#           A may be deprecated because the receiver type is unknown
#           property access is using A method which is deprecated
#           specifying 'uuid' as an ATL attribute is deprecated; use __declspec instead
#           use of C-style parameters in Objective-C method declarations is deprecated
#     -Wdeprecated-enum-compare
#           <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#     -Wdeprecated-enum-compare-conditional
#           <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#     -Wdeprecated-enum-enum-conversion
#           <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#     -Wdeprecated-enum-float-conversion
#           <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> <floating-point|enumeration> type C <with|from|and> <enumeration|floating-point> type D is deprecated
#     -Wdeprecated-increment-bool
#           incrementing expression of type bool is deprecated and incompatible with C++17
#     -Wdeprecated-no-relaxed-template-template-args
#           argument '-fno-relaxed-template-template-args' is deprecated
#     -Wdeprecated-ofast
#           argument '-Ofast' is deprecated; use '-O3 -ffast-math' for the same behavior, or '-O3' to enable only conforming optimizations
#     -Wdeprecated-pragma
#           macro A has been marked as deprecated[: C]
#     -Wdeprecated-register
#           'register' storage class specifier is deprecated and incompatible with C++17
#     -Wdeprecated-this-capture
#           implicit capture of 'this' with a capture default of '=' is deprecated
#     -Wdeprecated-type
#           '_ExtInt' is deprecated; use '_BitInt' instead
#     -Wdeprecated-volatile
#           <decrement|increment> of object of volatile-qualified type B is deprecated
#           use of result of assignment to object of volatile-qualified type A is deprecated
#           volatile qualifier in structured binding declaration is deprecated
#           volatile-qualified parameter type A is deprecated
#           volatile-qualified return type A is deprecated
#     -Wdeprecated-writable-strings
#       -Wc++11-compat-deprecated-writable-strings
#             conversion from string literal to A is deprecated
#   -Wdeprecated-altivec-src-compat
#         current handling of vector bool and vector pixel types in this context are deprecated; the default behaviour will soon change to that implied by the '-altivec-compat=xl' option
#   -Wdeprecated-module-dot-map
#         'A' as a module map name is deprecated, rename it to <module.modulemap|module.private.modulemap>[ in the 'Modules' directory of the framework]
#   -Wdeprecated-objc-isa-usage
#         assignment to Objective-C's isa is deprecated in favor of object_setClass()
#         direct access to Objective-C's isa is deprecated in favor of object_getClass()
#   -Wdeprecated-objc-pointer-introspection
#         bitmasking for introspection of Objective-C object pointers is strongly discouraged
#     -Wdeprecated-objc-pointer-introspection-performSelector
#           bitmasking for introspection of Objective-C object pointers is strongly discouraged
#   -Wdistributed-object-modifiers
#         conflicting distributed object modifiers on parameter type in implementation of A
#         conflicting distributed object modifiers on return type in implementation of A
#   -Wdiv-by-zero
#     -Wdivision-by-zero
#           <remainder|division> by zero is undefined
#   -Wdll-attribute-on-redeclaration
#         redeclaration of A should not add B attribute
#   -Wdllexport-explicit-instantiation-decl
#         explicit instantiation declaration should not be 'dllexport'
#   -Wdllimport-static-field-def
#         definition of dllimport static field
#   -Wdtor-name (partial)
#         qualified destructor name only found in lexical scope; omit the qualifier to find this type name by unqualified lookup
#   -Wdtor-typedef
#         destructor cannot be declared using a <typedef|type alias> A of the class name
#   -Wduplicate-decl-specifier (partial)
#         duplicate 'A' declaration specifier
#         multiple identical address spaces specified for type
#   -Wduplicate-protocol
#         duplicate protocol definition of A is ignored
#   -Wdxil-validation
#         dxv not found; resulting DXIL will not be validated or signed for use in release environment
#   -Wdynamic-exception-spec (partial)
#         ISO C++17 does not allow dynamic exception specifications
#   -Weager-load-cxx-named-modules
#         the form '-fmodule-file=<BMI-path>' is deprecated for standard C++ named modules;consider to use '-fmodule-file=<module-name>=<BMI-path>' instead
#   -Welaborated-enum-base
#         non-defining declaration of enumeration with a fixed underlying type is only permitted as a standalone declaration[; missing list of enumerators?]
#   -Welaborated-enum-class
#         reference to enumeration must use 'enum' not 'enum <struct|class>'
#   -Wempty-body
#         for loop has empty body
#         if statement has empty body
#         range-based for loop has empty body
#         switch statement has empty body
#         while loop has empty body
#   -Wempty-decomposition
#         ISO C++17 does not allow a decomposition group to be empty
#   -Wencode-type
#         encoding of A type is incomplete because B component has unknown encoding
#   -Wendif-labels
#     -Wextra-tokens
#           extra tokens at end of #A directive
#           extra tokens at the end of '#pragma omp A' are ignored
#   -Wenum-compare
#         <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types
#     -Wdeprecated-enum-compare
#           <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#     -Wenum-compare-switch
#           comparison of different enumeration types in switch statement
#   -Wenum-constexpr-conversion
#         integer value A is outside the valid range of values [B, C] for the enumeration type D
#   -Wenum-too-large
#         enumeration values exceed range of largest integer
#         incremented enumerator value A is not representable in the largest integer type
#   -Wexceptions
#         A has a non-throwing exception specification but can still throw
#         cannot refer to a non-static member from the handler of a <constructor|destructor> function try block
#         exception of type A will be caught by earlier handler
#   -Wexcess-initializers
#         excess elements in <array|vector|scalar|union|struct> initializer
#         excess elements in char array initializer
#         excess elements in initializer for indivisible sizeless type A
#         initializer-string for char array is too long
#   -Wexcessive-regsave
#         <interrupt service routine|function with attribute 'no_caller_saved_registers'> should only call a function with attribute 'no_caller_saved_registers' or be compiled with '-mgeneral-regs-only'
#   -Wexpansion-to-defined (partial)
#         macro expansion producing 'defined' has undefined behavior
#   -Wexperimental-header-units
#         the implementation of header units is in an experimental phase
#   -Wexplicit-initialize-call
#         explicit call to +initialize results in duplicate call to +initialize
#         explicit call to [super initialize] should only be in implementation of +initialize
#   -Wexplicit-specialization-storage-class
#         explicit specialization cannot have a storage class
#   -Wextern-initializer
#         'extern' variable has an initializer
#   -Wextra-qualification
#         extra qualification on member A
#   -Wextractapi-misuse
#         missing symbol graph output directory, defaulting to working directory
#   -Wfinal-dtor-non-final-class
#         class with destructor marked '<final|sealed>' cannot be inherited from
#   -Wfixed-point-overflow
#         overflow in expression; result is A with type B
#   -Wflag-enum
#         enumeration value A is out of range of flags in enumeration type B
#   -Wformat=2 (partial)
#     -Wformat-security
#           format string is not a string literal (potentially insecure)
#   -Wfortify-source
#         'A' may overflow; destination buffer in argument B has size C, but the corresponding specifier may require size D
#         'A' size argument is too large; destination buffer has size B, but size argument is C
#         'A' will always overflow; destination buffer has size B, but size argument is C
#         'A' will always overflow; destination buffer has size B, but the source string has length C (including NUL byte)
#     -Wformat-overflow
#           'A' will always overflow; destination buffer has size B, but format string expands to at least C,1,2
#       -Wformat-overflow-non-kprintf
#             'A' will always overflow; destination buffer has size B, but format string expands to at least C,1,2
#     -Wformat-truncation
#           'A' will always be truncated; specified size is B, but format string expands to at least C,1,2
#       -Wformat-truncation-non-kprintf
#             'A' will always be truncated; specified size is B, but format string expands to at least C,1,2
#   -Wframe-larger-than=
#     -Wframe-larger-than
#           The text of this diagnostic is not controlled by Clang
#           stack frame size (A) exceeds limit (B) in 'C'
#   -Wframework-include-private-from-public
#         public framework header includes private framework header 'A'
#   -Wfree-nonheap-object
#         attempt to call A on non-heap <object C|object: block expression|object: lambda-to-function-pointer conversion>
#   -Wfriend-enum
#         elaborated enum specifier cannot be declared as a friend
#   -Wfunction-def-in-objc-container
#         function definition inside an Objective-C container is deprecated
#   -Wfunction-effects
#         attribute 'A' on function does not match previous declaration
#         attribute 'A' on overriding function does not match base declaration
#         attribute 'A' should not be added via type conversion
#         effects conflict when merging declarations; kept 'A', discarded 'B'
#   -Wfunction-multiversion
#         CPU list contains duplicate entries; attribute ignored
#         body of cpu_dispatch function will be ignored
#         version list contains duplicate entries
#         version list contains entries that don't impact code generation
#     -Wtarget-clones-mixed-specifiers
#           mixing 'target_clones' specifier mechanisms is permitted for GCC compatibility; use a comma separated sequence of string literals, or a string literal containing a comma-separated list of versions
#   -Wgcc-compat (partial)
#         'A' is bound to current loop, GCC binds it to the enclosing loop
#         'break' is bound to loop, GCC binds it to switch
#         GCC does not allow A attribute in this position on a function definition
#         GCC does not allow an attribute in this position on a function declaration
#         GCC does not allow the 'cleanup' attribute argument to be anything other than a simple identifier
#         GCC does not allow the A attribute to be written on a type
#         GCC does not allow variable declarations in for loop initializers before C99
#         GCC requires a function with the A attribute to be variadic
#         __final is a GNU extension, consider using C++11 final
#   -Wglobal-isel
#         -fglobal-isel support for the 'A' architecture is incomplete
#         -fglobal-isel support is incomplete for this architecture at the current optimization level
#   -Wgnu (partial)
#     -Wgnu-alignof-expression
#           A applied to an expression is a GNU extension
#     -Wgnu-designator (partial)
#           use of GNU 'missing =' extension in designator
#           use of GNU old-style field designator extension
#     -Wgnu-folding-constant (partial)
#           variable length array folded to constant array as an extension
#     -Wgnu-static-float-init
#           in-class initializer for static data member of type A is a GNU extension
#     -Wgnu-string-literal-operator-template
#           string literal operator templates are a GNU extension
#     -Wgnu-variable-sized-type-not-at-end
#           field A with variable sized type B not at the end of a struct or class is a GNU extension
#     -Wredeclared-class-member
#           class member cannot be redeclared
#     -Wvla-extension (partial)
#       -Wvla-cxx-extension (partial)
#             variable length arrays in C++ are a Clang extension
#         -Wvla-extension-static-assert (partial)
#               variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?
#   -Wgnu-array-member-paren-init
#         parenthesized initialization of a member array is a GNU extension
#   -Wgnu-inline-cpp-without-extern
#         'gnu_inline' attribute without 'extern' in C++ treated as externally available, this changed in Clang 10
#   -Wgpu-maybe-wrong-side
#         capture host side class data member by this pointer in device or host device lambda function may result in invalid memory access if this pointer is not accessible on device side
#   -Wheader-guard
#         A is used as a header guard here, followed by #define of a different macro
#   -Whigher-precision-fp
#         higher precision floating-point type size has the same size than floating-point type size
#   -Whip-omp-target-directives
#         HIP does not support OpenMP target directives; directive has been ignored
#   -Whip-only
#         'A' is ignored since it is only supported for HIP
#   -Whlsl-availability
#         A is only available [in E environment ]on B C or newer
#         A is unavailable
#   -Whlsl-extensions
#         access specifiers are a clang HLSL extension
#   -Wignored-availability-without-sdk-settings
#         A availability is ignored without a valid 'SDKSettings.json' in the SDK
#   -Wignored-gch
#         precompiled header 'A' was ignored because it is not a clang PCH file
#         precompiled header directory 'A' was ignored because it contains no clang PCH files
#   -Wimplicit-conversion-floating-point-to-bool
#         implicit conversion turns floating-point number into bool: A to B
#   -Wimplicit-exception-spec-mismatch
#         function previously declared with an <explicit|implicit> exception specification redeclared with an <implicit|explicit> exception specification
#   -Wimplicit-fixed-point-conversion
#         implicit conversion from A cannot fit within the range of values for B
#   -Wimplicitly-unsigned-literal
#         integer literal is too large to be represented in a signed integer type, interpreting as unsigned
#   -Winaccessible-base
#         direct base A is inaccessible due to ambiguity:B
#   -Winclude-angled-in-module-purview
#         '#include <filename>' attaches the declarations to the named module 'A', which is not usually intended; consider moving that directive before the module declaration
#   -Winclude-next-absolute-path
#         #include_next in file found relative to primary source file or found by absolute path; will search from start of include path
#   -Winclude-next-outside-header
#         #include_next in primary source file; will search from start of include path
#   -Wincompatible-exception-spec
#         exception specifications of <return|argument> types differ
#         target exception specification is not superset of source
#   -Wincompatible-library-redeclaration
#         incompatible redeclaration of library function A
#   -Wincompatible-ms-pragma-section
#         `#pragma const_seg` for section B will not apply to A due to the presence of a [mutable field|non-trivial constructor|non-trivial destructor]
#   -Wincompatible-ms-struct
#         ms_struct may not produce Microsoft-compatible layouts for classes with base classes or virtual functions
#         ms_struct may not produce Microsoft-compatible layouts with fundamental data types with sizes that aren't a power of two
#   -Wincompatible-pointer-types
#         incompatible pointer types <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#     -Wincompatible-function-pointer-types
#           incompatible function pointer types <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#     -Wincompatible-pointer-types-discards-qualifiers
#           <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types> discards qualifiers
#           <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types> discards qualifiers in nested pointer types
#           <reinterpret_cast|C-style cast> from B to C changes address space of nested pointers
#   -Wincompatible-property-type
#         property type A is incompatible with type B inherited from C
#   -Wincompatible-sysroot
#         using sysroot for 'A' but targeting 'B'
#   -Wincomplete-framework-module-declaration
#         skipping 'A' because module declaration of 'B' lacks the 'framework' qualifier
#   -Wincomplete-implementation
#         method definition for A not found
#   -Wincomplete-module (partial)
#     -Wincomplete-umbrella
#           missing submodule 'A'
#           umbrella directory 'A' not found
#           umbrella header for module 'A' does not include header 'B'
#   -Wincomplete-setjmp-declaration
#         declaration of built-in function 'A' requires the declaration of the 'jmp_buf' type, commonly provided in the header <setjmp.h>
#   -Winconsistent-missing-override
#         A overrides a member function but is not marked 'override'
#   -Wincrement-bool
#         ISO C++17 does not allow incrementing expression of type bool
#     -Wdeprecated-increment-bool
#           incrementing expression of type bool is deprecated and incompatible with C++17
#   -WIndependentClass-attribute
#         'objc_independent_class' attribute may be put on Objective-C object pointer type only; attribute is ignored
#         'objc_independent_class' attribute may be put on a typedef only; attribute is ignored
#   -Winjected-class-name
#         ISO C++ specifies that qualified reference to A is a constructor name rather than a <template name|type> in this context, despite preceding <'typename'|'template'> keyword
#   -Winline-asm
#         The text of this diagnostic is not controlled by Clang
#   -Winline-namespace-reopened-noninline
#         inline namespace reopened as a non-inline namespace
#   -Winline-new-delete
#         replacement function A cannot be declared 'inline'
#   -Winstallapi-violation
#         declaration 'A' is <weak defined|thread local>, but symbol is not in dynamic library
#         declaration 'A' is marked <available|unavailable>, but symbol is [not ]exported in dynamic library
#         declaration has external linkage, but dynamic library doesn't have symbol 'A'
#         declaration has external linkage, but symbol has internal linkage in dynamic library 'A'
#         dynamic library symbol 'A' is <weak defined|thread local>, but its declaration is not
#         glob 'A' did not match any header file
#         no declaration was found for exported symbol 'A' in dynamic library
#         no such excluded <public|private> header file: 'B'
#         platform does not match: 'A' (provided) vs 'B' (found)
#         runpath search paths do not match: 'A' (provided) vs 'B' (found)
#         runpath search paths missing from A: 'B'
#         symbol exported in dynamic library, but marked hidden in declaration 'A'
#         violations found for A
#   -Winstantiation-after-specialization
#         explicit instantiation of A that occurs after an explicit specialization has no effect
#   -Wint-conversions
#     -Wint-conversion
#           incompatible integer to pointer conversion <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#           incompatible pointer to integer conversion <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#   -Wint-to-pointer-cast
#         cast to B from smaller integer type A
#     -Wint-to-void-pointer-cast
#           cast to B from smaller integer type A
#   -Winteger-overflow
#         overflow in expression; result is A with type B
#   -Winvalid-command-line-argument
#         feature flag 'A' is ignored since the feature is read only
#         feature flag 'A' must start with either '+' to enable the feature or '-' to disable it; flag ignored
#         ignoring extension 'A' because the 'B' architecture does not support it
#         mismatch between architecture and environment in target triple 'A'; did you mean 'B'?
#         missing plugin argument for plugin A in B
#         missing plugin name in A
#         no MCU device specified, but '-mhwmult' is set to 'auto', assuming no hardware multiply; use '-mmcu' to specify an MSP430 device, or '-mhwmult' to set the hardware multiply type explicitly
#         optimization level 'A' is not supported; using 'BC' instead
#         the given MCU does not support hardware multiply, but '-mhwmult' is set to A
#         the given MCU supports A hardware multiply, but '-mhwmult' is set to B
#         the object size sanitizer has no effect at -O0, but is explicitly enabled: A
#     -Wignored-optimization-argument
#           optimization flag 'A' is not supported
#           optimization flag 'A' is not supported for target 'B'
#   -Winvalid-constexpr
#         <constexpr|consteval> <function|constructor> never produces a constant expression
#   -Winvalid-feature-combination
#         invalid feature combination: A
#   -Winvalid-iboutlet
#         <instance variable|property> with A attribute must be an object type (invalid B)
#         IBOutletCollection properties should be copy/strong and not assign
#   -Winvalid-initializer-from-system-header
#         invalid constructor from class in system header, should not be explicit
#   -Winvalid-ios-deployment-target
#         invalid iOS deployment version 'A', iOS 10 is the maximum deployment target for 32-bit targets
#   -Winvalid-no-builtin-names
#         'A' is not a valid builtin name for B
#   -Winvalid-noreturn
#         function A declared 'noreturn' should not return
#         function declared 'noreturn' should not return
#   -Winvalid-offsetof
#         offset of on non-POD type A
#         offset of on non-standard-layout type A
#   -Winvalid-partial-specialization
#         <class|variable> template partial specialization is not more specialized than the primary template
#   -Winvalid-pp-token
#         empty character constant
#         missing terminating <'|'"'> character
#   -Winvalid-source-encoding
#         illegal character encoding in character literal
#         illegal character encoding in string literal
#   -Winvalid-static-assert-message
#         the message in this static assertion is not a constant expression
#   -Winvalid-token-paste
#         pasting formed 'A', an invalid preprocessing token
#   -Winvalid-unevaluated-string
#         encoding prefix 'A' on an unevaluated string literal has no effect[ and is incompatible with c++2c]
#   -Wjump-seh-finally
#         jump out of __finally block has undefined behavior
#   -Wkeyword-compat
#         keyword 'A' will be made available as an identifier <here|for the remainder of the translation unit>
#   -Wknr-promoted-parameter
#         promoted type of K&R function parameter is not compatible with parameter type declared in a previous prototype
#   -Wlarge-by-value-copy
#         A is a large (B bytes) pass-by-value argument; pass it by reference instead ?
#         return value of A is a large (B bytes) pass-by-value object; pass it by reference instead ?
#   -Wlinker-warnings
#         linking module 'A': B
#   -Wlocal-type-template-args (partial)
#         template argument uses local type A
#   -Wmain (partial)
#         'main' is not allowed to be declared _Noreturn
#         'main' is not allowed to be declared variadic
#         'main' should not be declared static
#         bool literal returned from 'main'
#         only one parameter on 'main' declaration
#         variable named 'main' with external linkage has undefined behavior
#   -Wmain-return-type
#         return type of 'main' is not 'int'
#   -Wmalformed-warning-check
#         __has_warning expected option name (e.g. "-Wundef")
#   -Wmany-braces-around-scalar-init
#         too many braces around [scalar ]initializer
#   -Wmathematical-notation-identifier-extension
#         mathematical notation character <U+A> in an identifier is a Clang extension
#   -Wmax-unsigned-zero
#         taking the max of <a value and unsigned zero|unsigned zero and a value> is always equal to the other value
#   -Wmemsize-comparison
#         size argument in A call is a comparison
#   -Wmicrosoft (partial)
#     -Winconsistent-dllimport
#           A redeclared without 'dllimport' attribute: 'dllexport' attribute added
#           A redeclared without B attribute: previous B ignored
#     -Wmicrosoft-abstract
#           'abstract' keyword is a Microsoft extension
#     -Wmicrosoft-anon-tag (partial)
#           anonymous <structs|unions> are a Microsoft extension
#     -Wmicrosoft-cast
#           implicit conversion between pointer-to-function and pointer-to-object is a Microsoft extension
#           static_cast between pointer-to-function and pointer-to-object is a Microsoft extension
#     -Wmicrosoft-const-init
#           default initialization of an object of const type A[ without a user-provided default constructor] is a Microsoft extension
#     -Wmicrosoft-default-arg-redefinition
#           redefinition of default argument
#     -Wmicrosoft-drectve-section
#           #pragma A(".drectve") has undefined behavior, use #pragma comment(linker, ...) instead
#     -Wmicrosoft-enum-forward-reference
#           forward references to 'enum' types are a Microsoft extension
#     -Wmicrosoft-exception-spec (partial)
#           [pointer to |reference to ]incomplete type B is not allowed in exception specification
#           exception specification in declaration does not match previous declaration
#           exception specification in explicit instantiation does not match instantiated one
#           exception specification of overriding function is more lax than base version
#     -Wmicrosoft-explicit-constructor-call
#           explicit constructor calls are a Microsoft extension
#     -Wmicrosoft-extra-qualification
#           extra qualification on member A
#     -Wmicrosoft-goto
#           jump from this goto statement to its label is a Microsoft extension
#     -Wmicrosoft-include
#           #include resolved using non-portable Microsoft search rules as: A
#     -Wmicrosoft-init-from-predefined
#           initializing an array from a 'A' predefined identifier is a Microsoft extension
#     -Wmicrosoft-mutable-reference
#           'mutable' on a reference type is a Microsoft extension
#     -Wmicrosoft-pure-definition
#           function definition with pure-specifier is a Microsoft extension
#     -Wmicrosoft-sealed
#           'sealed' keyword is a Microsoft extension
#     -Wmicrosoft-static-assert
#           use of 'static_assert' without inclusion of <assert.h> is a Microsoft extension
#     -Wmicrosoft-string-literal-from-predefined
#           expansion of predefined identifier 'A' to a string literal is a Microsoft extension
#     -Wmicrosoft-template
#           'static' can only be specified inside the class definition
#           <class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration> specialization of B not in <a namespace enclosing C|class C or an enclosing namespace> is a Microsoft extension
#           duplicate explicit instantiation of A ignored as a Microsoft extension
#           non-type template argument containing a dereference operation is a Microsoft extension
#           template argument for template type parameter must be a type; omitted 'typename' is a Microsoft extension
#           unqualified base initializer of class templates is a Microsoft extension
#           use of member A before its declaration is a Microsoft extension
#           use of member A found via unqualified lookup into dependent bases of class templates is a Microsoft extension
#           use of undeclared identifier A; unqualified lookup into dependent bases of class template B is a Microsoft extension
#           using the undeclared type A as a default template argument is a Microsoft extension
#       -Wmicrosoft-template-shadow
#             declaration of A shadows template parameter
#     -Wmicrosoft-union-member-reference
#           union member A has reference type B, which is a Microsoft extension
#     -Wmicrosoft-unqualified-friend
#           unqualified friend declaration referring to type outside of the nearest enclosing namespace is a Microsoft extension; add a nested name specifier
#     -Wmicrosoft-using-decl
#           using declaration referring to inaccessible member 'A' (which refers to accessible member 'B') is a Microsoft compatibility extension
#     -Wmicrosoft-void-pseudo-dtor
#           pseudo-destructors on type void are a Microsoft extension
#   -Wmicrosoft-exists
#         dependent <__if_not_exists|__if_exists> declarations are ignored
#   -Wmicrosoft-inaccessible-base
#         accessing inaccessible direct base A of B is a Microsoft extension
#   -Wmisexpect
#         potential performance regression from use of __builtin_expect(): annotation was correct on A of profiled executions
#   -Wmismatched-new-delete
#         'delete[[]]' applied to a pointer that was allocated with 'new[[]]'; did you mean 'delete[[]]'?
#   -Wmismatched-parameter-types
#         conflicting parameter types in implementation of A
#   -Wmismatched-return-types
#         conflicting return type in implementation of A
#   -Wmissing-constinit
#         'constinit' specifier missing on initializing declaration of A
#   -Wmissing-declarations
#         'A' ignored on this declaration
#         'A' is not permitted on a declaration of a type
#         declaration does not declare anything
#         typedef requires a name
#   -Wmissing-exception-spec
#         A is missing exception specification 'B'
#   -Wmissing-multilib
#         no multilib found matching flags: A
#   -Wmissing-noescape
#         parameter of overriding method should be annotated with __attribute__((noescape))
#   -Wmissing-prototype-for-cc
#         function with no prototype cannot use the A calling convention
#   -Wmissing-selector-name
#         A used as the name of the previous parameter rather than as part of the selector
#   -Wmissing-sysroot
#         no such sysroot directory: 'A'
#   -Wmissing-template-arg-list-after-template-kw
#         a template argument list is expected after a name prefixed by the template keyword
#   -Wmisspelled-assumption
#         unknown assumption string 'A' may be misspelled; attribute is potentially ignored, did you mean 'B'?
#   -Wmix-packoffset
#         cannot mix packoffset elements with nonpackoffset elements in a cbuffer
#   -Wmodule-conflict
#         module 'A' conflicts with already-imported module 'B': C
#         module file 'A' was validated as a system module and is now being imported as a non-system module; any difference in diagnostic options will be ignored
#   -Wmodule-file-config-mismatch
#         module file A cannot be loaded due to a configuration mismatch with the current compilation
#   -Wmodule-file-extension
#         duplicate module file extension block name 'A'
#   -Wmodule-import-in-extern-c
#         import of C++ module 'A' appears within extern "C" language linkage specification
#   -Wmodules-ambiguous-internal-linkage
#         ambiguous use of internal linkage declaration A defined in multiple modules
#   -Wmodules-import-nested-redundant
#         redundant #include of module 'A' appears within B
#   -Wmsvc-include
#     -Wmicrosoft-include
#           #include resolved using non-portable Microsoft search rules as: A
#   -Wmsvc-not-found
#         unable to find a Visual Studio installation; try running Clang from a developer command prompt
#   -Wmulti-gpu
#         multiple A architectures are detected: B; only the first one is used for 'C'
#   -Wmultiple-move-vbase
#         defaulted move assignment operator of A will move assign virtual base class B multiple times
#   -Wnan-infinity-disabled
#         use of <infinity|NaN>[ via a macro] is undefined behavior due to the currently enabled floating-point options
#   -Wnarrowing (partial)
#     -Wc++11-narrowing (partial)
#           <case value|enumerator value|non-type template argument|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#           constant expression evaluates to A which cannot be narrowed to type B
#           non-constant-expression cannot be narrowed from type A to B in initializer list
#           type A cannot be narrowed to B in initializer list
#       -Wc++11-narrowing-const-reference
#             constant expression evaluates to A which cannot be narrowed to type B
#             non-constant-expression cannot be narrowed from type A to B in initializer list
#             type A cannot be narrowed to B in initializer list
#   -Wnew-returns-null
#         A should not return a null pointer unless it is declared 'throw()'[ or 'noexcept']
#   -Wnoderef
#         casting to dereferenceable pointer removes 'noderef' attribute
#         dereferencing A; was declared with a 'noderef' type
#         dereferencing expression marked as 'noderef'
#   -Wnoexcept-type
#     -Wc++17-compat-mangling
#           mangled name of A will change in C++17 due to non-throwing exception specification in function signature
#   -Wnon-c-typedef-for-linkage
#         anonymous non-C-compatible type given name for linkage purposes by <typedef|alias> declaration; add a tag name here
#   -Wnon-gcc (partial)
#     -Wconversion (partial)
#           implicit conversion truncates vector: A to B
#       -Wbool-conversion
#             initialization of pointer of type A to null from a constant boolean expression
#         -Wpointer-bool-conversion
#               address of <'B'|function 'B'|array 'B'|lambda function pointer conversion operator> will always evaluate to 'true'
#               nonnull <function call|parameter> 'B' will evaluate to 'true' on first encounter
#         -Wundefined-bool-conversion
#               'this' pointer cannot be null in well-defined C++ code; pointer may be assumed to always convert to true
#               reference cannot be bound to dereferenced null pointer in well-defined C++ code; pointer may be assumed to always convert to true
#       -Wconstant-conversion
#             implicit conversion from C to D changes value from A to B
#         -Wbitfield-constant-conversion
#               implicit truncation from C to bit-field changes value from A to B
#           -Wsingle-bit-bitfield-constant-conversion
#                 implicit truncation from C to a one-bit wide bit-field changes value from A to B
#         -Wobjc-bool-constant-conversion
#               implicit conversion from constant value A to 'BOOL'; the only well defined values for 'BOOL' are YES and NO
#       -Wenum-conversion (partial)
#             implicit conversion from enumeration type A to different enumeration type B
#         -Wenum-compare-conditional (partial)
#           -Wdeprecated-enum-compare-conditional
#                 <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#         -Wenum-enum-conversion (partial)
#           -Wdeprecated-enum-enum-conversion
#                 <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#         -Wenum-float-conversion (partial)
#           -Wdeprecated-enum-float-conversion
#                 <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> <floating-point|enumeration> type C <with|from|and> <enumeration|floating-point> type D is deprecated
#       -Wimplicit-float-conversion (partial)
#         -Wimplicit-int-float-conversion (partial)
#           -Wimplicit-const-int-float-conversion
#                 implicit conversion from C to D changes value from A to B
#         -Wobjc-signed-char-bool-implicit-float-conversion
#               implicit conversion from floating-point type A to 'BOOL'
#       -Wint-conversion
#             incompatible integer to pointer conversion <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#             incompatible pointer to integer conversion <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#       -Wliteral-conversion
#             implicit conversion from A to B changes value from C to D
#             implicit conversion of out of range value from A to B is undefined
#       -Wnon-literal-null-conversion
#             expression which evaluates to zero treated as a null pointer constant of type A
#       -Wnull-conversion
#             implicit conversion of <NULL|nullptr> constant to B
#       -Wobjc-literal-conversion
#             implicit boolean conversion of Objective-C object literal always evaluates to true
#             object of type A is not compatible with <array element type|dictionary key type|dictionary value type> C
#     -Wliteral-range
#           floating-point comparison is always <true|false>; constant cannot be represented exactly in type B
#           magnitude of floating-point constant too large for type A; maximum is B
#           magnitude of floating-point constant too small for type A; minimum is B
#   -Wnon-power-of-two-alignment
#         requested alignment is not a power of 2
#   -Wnonportable-include-path
#         non-portable path to file 'A'; specified path differs in case from file name on disk
#   -Wnonportable-private-apinotes-path
#         private API notes file for module 'A' should be named 'A_private.apinotes', not 'B'
#   -Wnonportable-vector-initialization
#         vector initializers are not compatible with NEON intrinsics in big endian mode
#   -Wnsconsumed-mismatch
#         overriding method has mismatched ns_consumed attribute on its parameter
#   -WNSObject-attribute
#         'NSObject' attribute may be put on a typedef only; attribute is ignored
#   -Wnsreturns-mismatch
#         overriding method has mismatched ns_returns_<not_retained|retained> attributes
#   -Wnull-arithmetic
#         comparison between NULL and non-pointer <(B and NULL)|(NULL and B)>
#         use of NULL in arithmetic operation
#   -Wnull-character
#         null character ignored
#         null character(s) preserved in <char|string> literal
#   -Wnull-dereference
#         binding dereferenced null pointer to reference has undefined behavior
#         indirection of non-volatile null pointer will be deleted, not trap
#   -Wnullability
#         conflicting nullability specifier on parameter types, A conflicts with existing specifier B
#         conflicting nullability specifier on return types, A conflicts with existing specifier B
#         duplicate nullability specifier A
#         nullability specifier A conflicts with existing specifier B
#         synthesized setter A for null_resettable property B does not handle nil
#   -Wnullability-completeness
#         <pointer|block pointer|member pointer> is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)
#     -Wnullability-completeness-on-arrays
#           array parameter is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)
#   -Wnullability-declspec
#         nullability specifier A cannot be applied to non-pointer type B; did you mean to apply the specifier to the <pointer|block pointer|member pointer|function pointer|member function pointer>?
#   -Wnullability-inferred-on-nested-type
#         inferring '_Nonnull' for pointer type within <array|reference> is deprecated
#   -Wobjc-autosynthesis-property-ivar-name-match
#         autosynthesized property A will use [synthesized] instance variable C, not existing instance variable D
#   -Wobjc-boxing
#         string is ill-formed as UTF-8 and will become a null A when boxed
#   -Wobjc-circular-container
#         adding A to B might cause circular dependency in container
#   -Wobjc-cocoa-api
#     -Wobjc-redundant-api-use
#       -Wobjc-redundant-literal-use
#             using A with a literal is redundant
#   -Wobjc-dictionary-duplicate-keys
#         duplicate key in dictionary literal
#   -Wobjc-duplicate-category-definition
#         duplicate definition of category B on interface A
#   -Wobjc-forward-class-redefinition
#         redefinition of forward class A of a typedef name of an object type is ignored
#   -Wobjc-literal-compare
#         direct comparison of [an array literal|a dictionary literal|a numeric literal|a boxed expression] has undefined behavior
#     -Wobjc-string-compare
#           direct comparison of a string literal has undefined behavior
#   -Wobjc-macro-redefinition
#         ignoring redefinition of Objective-C qualifier macro
#   -Wobjc-method-access
#         class method A not found (return type defaults to 'id')
#         class method A not found (return type defaults to 'id'); did you mean C?
#         instance method A found instead of class method B
#         instance method A is being used on 'Class' which is not in the root class
#         instance method A not found (return type defaults to 'id')
#         instance method A not found (return type defaults to 'id'); did you mean C?
#   -Wobjc-multiple-method-names
#         multiple methods named A found
#   -Wobjc-noncopy-retain-block-property
#         retain'ed block property does not copy the block - use copy attribute instead
#   -Wobjc-nonunified-exceptions
#         cannot catch an exception thrown with @throw in C++ in the non-unified exception model
#   -Wobjc-property-implementation
#         class property A requires method B to be defined - use @dynamic or provide a method implementation in this category
#         class property A requires method B to be defined - use @dynamic or provide a method implementation in this class implementation
#         property A requires method B to be defined - use @dynamic or provide a method implementation in this category
#         property A requires method B to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation
#   -Wobjc-property-implicit-mismatch
#         primary property declaration is implicitly strong while redeclaration in class extension is weak
#   -Wobjc-property-matches-cocoa-ownership-rule
#         property follows Cocoa naming convention for returning 'owned' objects
#   -Wobjc-property-no-attribute
#         default property attribute 'assign' not appropriate for object
#         no 'assign', 'retain', or 'copy' attribute is specified - 'assign' is assumed
#   -Wobjc-property-synthesis
#         auto property synthesis will not synthesize property A because it cannot share an ivar with another synthesized property
#         auto property synthesis will not synthesize property A because it is 'readwrite' but it will be synthesized 'readonly' via another property
#         auto property synthesis will not synthesize property A; it will be implemented by its superclass, use @dynamic to acknowledge intention
#   -Wobjc-protocol-method-implementation
#         category is implementing a method which will also be implemented by its primary class
#   -Wobjc-protocol-property-synthesis
#         auto property synthesis will not synthesize property A declared in protocol B
#   -Wobjc-protocol-qualifiers
#         parameterized class A already conforms to the protocols listed; did you forget a '*'?
#   -Wobjc-readonly-with-setter-property
#         setter cannot be specified for a readonly property
#   -Wobjc-root-class
#         class A defined without specifying a base class
#   -Wobjc-signed-char-bool (partial)
#     -Wobjc-bool-constant-conversion
#           implicit conversion from constant value A to 'BOOL'; the only well defined values for 'BOOL' are YES and NO
#     -Wobjc-signed-char-bool-implicit-float-conversion
#           implicit conversion from floating-point type A to 'BOOL'
#     -Wtautological-objc-bool-compare
#           result of comparison of constant A with expression of type 'BOOL' is always B, as the only well defined values for 'BOOL' are YES and NO
#   -Wobjc-string-concatenation
#         concatenated NSString literal for an NSArray expression - possibly missing a comma
#   -Wobjc-unsafe-perform-selector
#         A is incompatible with selectors that return a <struct|union|vector> type
#   -Wodr
#         <class|instance> method B has a different number of parameters in different translation units (C vs. D)
#         <class|instance> method B has a parameter with a different types in different translation units (C vs. D)
#         <class|instance> method B has incompatible result types in different translation units (C vs. D)
#         <class|instance> method B is variadic in one translation unit and not variadic in another
#         class A has incompatible superclasses
#         external function A declared with incompatible types in different translation units (B vs. C)
#         external variable A declared with incompatible types in different translation units (B vs. C)
#         external variable A defined in multiple translation units
#         field A declared with incompatible types in different translation units (B vs. C)
#         instance variable A declared with incompatible types in different translation units (B vs. C)
#         non-type template parameter declared with incompatible types in different translation units (A vs. B)
#         parameter kind mismatch; parameter is <not a|a> parameter pack
#         property A declared with incompatible types in different translation units (B vs. C)
#         property A is implemented with <@synthesize|@dynamic> in one translation but <@dynamic|@synthesize> in another translation unit
#         property A is synthesized to different ivars in different translation units (B vs. C)
#         template parameter has different kinds in different translation units
#         template parameter lists have a different number of parameters (A vs B)
#         type A has incompatible definitions in different translation units
#   -Wopenacc (partial)
#     -Wsource-uses-openacc (partial)
#           OpenACC clause 'A' not yet implemented, clause ignored
#           OpenACC construct 'A' not yet implemented, pragma ignored
#   -Wopenacc-deprecated-clause-alias
#         OpenACC clause name 'A' is a deprecated clause name and is now an alias for 'B'
#   -Wopenacc-self-if-potential-conflict
#         OpenACC construct 'self' has no effect when an 'if' clause evaluates to true
#   -Wopencl-unsupported-rgba
#         vector component name 'A' is a feature from OpenCL version 3.0 onwards
#   -Wopenmp (partial)
#     -Wopenmp-51-extensions
#           specifying OpenMP directives with [[]] is an OpenMP 5.1 extension
#     -Wopenmp-clauses
#           'A' is not a valid context property for the context selector 'B' and the context set 'C'; property ignored
#           'A' is not a valid context selector for the context set 'B'; selector ignored
#           'A' is not a valid context set in a `declare variant`; set ignored
#           A clause should not be followed by arguments; tokens will be ignored
#           aligned clause will be ignored because the requested alignment is not a power of 2
#           allocate directive specifies <default|'B'> allocator while previously used <default|'D'>
#           allocator with the 'thread' trait access has unspecified behavior on 'A' directive
#           expected 'A' after the B; 'A' assumed
#           expected identifier or string literal describing a context <set|selector|property>; <set|selector|property> skipped
#           interop type 'A' cannot be specified more than once
#           more than one 'device_type' clause is specified
#           reserved locator 'omp_all_memory' cannot be specified more than once
#           the context <set|selector|property> 'B' was used already in the same 'omp declare variant' directive; <set|selector|property> ignored
#           the context property 'A' is not valid for the context selector 'B' and the context set 'C'; property ignored
#           the context selector 'A' in context set 'B' requires a context property defined in parentheses; selector ignored
#           the context selector 'A' in the context set 'B' cannot have a score ('C'); score ignored
#           the context selector 'A' is not valid for the context set 'B'; selector ignored
#           valid A clauses start with B; <token|tokens> will be ignored
#           zero linear step (A [and other variables in clause ]should probably be const)
#     -Wopenmp-extensions
#           'ompx_attribute' clause only allows 'amdgpu_flat_work_group_size', 'amdgpu_waves_per_eu', and 'launch_bounds'; A is ignored
#     -Wopenmp-loop-form
#           OpenMP loop iteration variable cannot have more than 64 bits size and will be narrowed
#           initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')
#     -Wopenmp-mapping
#           type A is not trivially copyable and not guaranteed to be mapped correctly
#     -Wopenmp-target
#           OpenMP offloading target 'A' is similar to target 'B' already specified; will be ignored
#           declaration is not declared in any declare target region
#           declaration marked as declare target after first use, it may lead to incorrect results
#       -Wopenmp-mapping
#             type A is not trivially copyable and not guaranteed to be mapped correctly
#     -Wopenmp-target-exception
#           target 'A' does not support exception handling; 'catch' block is ignored
#           target 'A' does not support exception handling; 'throw' is assumed to be never reached
#     -Wsource-uses-openmp (partial)
#           '#pragma omp declare variant' cannot be applied for function after first usage; the original function might be used
#           '#pragma omp declare variant' cannot be applied to the function that was defined already; the original function might be used
#           OpenMP only allows an ordered construct with the simd clause nested in a simd construct
#           expected '#pragma omp end declare target' at end of file to match '#pragma omp A'
#           isa trait 'A' is not known to the current target; verify the spelling or consider restricting the context selector with the 'arch' selector further
#           score expressions in the OpenMP context selector need to be constant; A is not and will be ignored
#           variant function in '#pragma omp declare variant' is itself marked as '#pragma omp declare variant'
#   -Woption-ignored
#         'A' does not support '-B'; flag ignored
#         'A' does not support '-moutline'; flag ignored
#         -fjmc works only for ELF; option ignored
#         /arm64EC has been overridden by specified target: A; option ignored
#         A requires HVX, use -mhvx/-mhvx= to enable it
#         A requires debug info. Use B or debug options that enable debugger's stepping function; option ignored
#         ignoring '-mlong-calls' option as it is not currently supported with [the implicit usage of ]-mabicalls
#         ignoring '-msmall-data-limit=' with -mcmodel=large for -fpic or RV64
#         ignoring 'A' as it conflicts with that implied by 'B' (C)
#         ignoring 'A' option as it cannot be used with [implicit usage of] -mabicalls and the N64 ABI
#         ignoring 'A' option as it is not currently supported for processor 'B'
#         ignoring 'A' option as it is not currently supported for target 'B'
#         ignoring 'A' option for offload arch 'B' as it is not currently supported there. Use it with an offload arch containing 'C' instead
#         option '-ffine-grained-bitfield-accesses' cannot be enabled together with a sanitizer; flag ignored
#         option 'A' was ignored by the B toolchain, using '-fPIC'
#         the argument 'A' is not supported for option 'B'. Mapping to 'BC'
#         the library 'A=B' is not supported, OpenMP will not be enabled
#         the warning option '-A' is not supported
#   -Wordered-compare-function-pointers
#         ordered comparison of function pointers (A and B)
#   -Wout-of-line-declaration
#         out-of-line declaration of a member must be a definition
#   -Wout-of-scope-function
#         use of out-of-scope declaration of A[ whose type is not compatible with that of an implicit declaration]
#   -Woverride-init
#     -Winitializer-overrides
#           initializer [partially ]overrides prior initialization of this subobject
#   -Woverride-module
#         overriding the module target triple with A
#   -Woverriding-option
#         overriding 'A' option with 'B'
#   -Wpartial-availability (partial)
#     -Wunguarded-availability (partial)
#       -Wunguarded-availability-new
#             A is only available [in E environment ]on B C or newer
#             A is unavailable
#   -Wpass-failed
#         The text of this diagnostic is not controlled by Clang
#   -Wpch-date-time
#         <precompiled header|module> uses __DATE__ or __TIME__
#   -Wpch-vfs-diff
#         PCH was compiled with different VFS overlay files than are currently in use
#   -Wpedantic-macros
#     -Wbuiltin-macro-redefined
#           redefining builtin macro
#           undefining builtin macro
#     -Wdeprecated-pragma
#           macro A has been marked as deprecated[: C]
#     -Wfinal-macro
#           macro A has been marked as final and should not be <undefined|redefined>
#     -Wmacro-redefined
#           A macro redefined
#     -Wrestrict-expansion
#           macro A has been marked as unsafe for use in headers[: C]
#   -Wpointer-arith (partial)
#         subtraction of pointers to type A of zero size has undefined behavior
#   -Wpointer-compare
#         comparing a pointer to a null character constant; did you mean to compare to <NULL|(void *)0>?
#   -Wpointer-integer-compare
#         comparison between pointer and integer (A and B)
#   -Wpointer-sign
#         <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types> converts between pointers to integer types <with different sign|where one is of the unique plain 'char' type and the other is not>
#   -Wpointer-to-int-cast
#         cast to smaller integer type B from A
#     -Wpointer-to-enum-cast
#           cast to smaller integer type B from A
#       -Wvoid-pointer-to-enum-cast
#             cast to smaller integer type B from A
#     -Wvoid-pointer-to-int-cast
#           cast to smaller integer type B from A
#       -Wvoid-pointer-to-enum-cast
#             cast to smaller integer type B from A
#   -Wpointer-type-mismatch
#         pointer type mismatch
#   -Wpragma-once-outside-header
#         #pragma once in main file
#   -Wpragma-system-header-outside-header
#         #pragma system_header ignored in main file
#   -Wpragmas (partial)
#         #pragma redefine_extname is applicable to external C declarations only; not applied to <function|variable> B
#         setting the floating point evaluation method to `source` on a target without SSE is not supported
#     -Wignored-pragmas
#           #pragma A(pop, ...) failed: B
#           #pragma options align=reset failed: A
#           '#pragma A' is not supported on this target - ignored
#           '#pragma comment A' ignored
#           '#pragma init_seg' is only supported when targeting a Microsoft environment
#           <value|type>-dependent expression passed as an argument to debug command
#           OpenCL extension A unknown or does not require pragma - ignoring
#           expected #pragma pack parameter to be '1', '2', '4', '8', or '16'
#           expected '#pragma unused' argument to be a variable name
#           expected ')' or ',' in '#pragma A'
#           expected ',' in '#pragma A'
#           expected '=' following '#pragma <align|options align>' - ignored
#           expected 'align' following '#pragma options' - ignored
#           expected 'compiler', 'lib', 'user', or a string literal for the section name in '#pragma A' - ignored
#           expected <'enable', 'disable', 'begin' or 'end'|'disable'> - ignoring
#           expected a stack label or a string literal for the section name in '#pragma A' - ignored
#           expected a string literal for the section name in '#pragma A' - ignored
#           expected action or ')' in '#pragma A' - ignored
#           expected identifier in '#pragma A' - ignored
#           expected integer between A and B inclusive in '#pragma C' - ignored
#           expected integer or identifier in '#pragma pack' - ignored
#           expected non-wide string literal in '#pragma A'
#           expected push, pop or a string literal for the section name in '#pragma A' - ignored
#           expected string literal in '#pragma A' - ignoring
#           expected string literal in 'clause A' - ignoring
#           extra tokens at end of '#pragma A' - ignored
#           incorrect use of #pragma clang force_cuda_host_device begin|end
#           incorrect use of '#pragma fenv_access (on|off)' - ignored
#           incorrect use of '#pragma ms_struct on|off' - ignored
#           invalid alignment option in '#pragma <align|options align>' - ignored
#           invalid or unsupported rounding mode in '#pragma STDC FENV_ROUND' - ignored
#           known but unsupported action 'B' for '#pragma A' - ignored
#           missing '(' after '#pragma A' - ignoring
#           missing ')' after '#pragma A' - ignoring
#           missing ':' after A - ignoring
#           missing ':' or ')' after A - ignoring
#           missing argument to '#pragma A'[; expected C]
#           missing argument to debug command 'A'
#           missing debug command
#           only variables can be arguments to '#pragma unused'
#           pragma pop_macro could not pop 'A', no matching push_macro
#           undeclared variable A used as an argument for '#pragma unused'
#           unexpected argument 'A' to '#pragma B'[; expected D]
#           unexpected argument to debug command
#           unexpected debug command 'A'
#           unknown action 'B' for '#pragma A' - ignored
#           unknown action for '#pragma A' - ignored
#           unknown module 'A'
#           unsupported OpenCL extension A - ignoring
#       -Wignored-pragma-intrinsic
#             A is not a recognized builtin[; consider including <intrin.h> to access non-builtin intrinsics]
#     -Wpragma-clang-attribute
#           unused attribute A in '#pragma clang attribute push' region
#     -Wpragma-pack (partial)
#           the current #pragma pack alignment value is modified in the included file
#           unterminated '#pragma pack (push, ...)' at end of file
#     -Wunknown-pragmas (partial)
#           #pragma execution_character_set expected 'A'
#           #pragma execution_character_set expected 'push' or 'pop'
#           #pragma execution_character_set invalid value 'A', only 'UTF-8' is supported
#           #pragma warning expected 'A'
#           #pragma warning expected 'push', 'pop', 'default', 'disable', 'error', 'once', 'suppress', 1, 2, 3, or 4
#           #pragma warning expected a warning number
#           #pragma warning(push, level) requires a level between 0 and 4
#           angle-bracketed include <A> cannot be aliased to double-quoted include "B"
#           double-quoted include "A" cannot be aliased to angle-bracketed include <B>
#           expected 'ON' or 'OFF' or 'DEFAULT' in pragma
#           expected end of directive in pragma
#           pragma STDC FENV_ROUND is not supported
#           pragma diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'
#           pragma diagnostic expected option name (e.g. "-Wundef")
#           pragma diagnostic pop could not pop, no matching push
#           pragma include_alias expected 'A'
#           pragma include_alias expected include filename
#           unexpected token in pragma diagnostic
#           unknown pragma in STDC namespace
#   -Wpredefined-identifier-outside-function
#         predefined identifier is only valid inside function
#   -Wprivate-header
#         use of private header from outside its module: 'A'
#   -Wprivate-module
#         expected canonical name for private module 'A'
#         module 'A' already re-exported as 'B'
#         no submodule named A in module 'B'; using top level 'C'
#         private submodule 'A' in private module map, expected top-level module
#   -Wprofile-instr-out-of-date
#         profile data may be out of date: of A function(s), B <has|have> mismatched data that will be ignored
#   -Wprofile-instr-unprofiled
#         no profile data available for file "A"
#   -Wproperty-access-dot-syntax
#         property A not found on object of type B; did you mean to access property C?
#   -Wproperty-attribute-mismatch
#         'B' attribute on property A does not match the property inherited from C
#         attribute 'readonly' of property A restricts attribute 'readwrite' of property inherited from B
#         getter name mismatch between property redeclaration (B) and its original declaration (A)
#         property attribute in class extension does not match the primary class
#   -Wprotocol
#         method A in protocol B not implemented
#   -Wprotocol-property-synthesis-ambiguity
#         property <of type B|with attribute 'B'|without attribute 'B'|with getter B|with setter B> was selected for synthesis
#   -Wpsabi
#         AVX vector <return|argument> of type B without 'C' enabled changes the ABI
#   -Wptrauth-null-pointers
#         authenticating a null pointer will almost certainly trap
#         signing a null pointer will yield a non-null pointer
#   -Wqualified-void-return-type
#         function cannot return qualified void type A
#   -Wread-only-types
#         object of type A cannot be placed in read-only memory
#   -Wreadonly-iboutlet-property
#         readonly IBOutlet property A when auto-synthesized may not work correctly with 'nib' loader
#   -Wreceiver-expr
#         receiver type A is not 'id' or interface pointer, consider casting it to 'id'
#   -Wreceiver-forward-class (partial)
#         receiver A is a forward class and corresponding @interface may not exist
#   -Wredundant-consteval-if
#         consteval if is always true in an <unevaluated|immediate> context
#   -Wregister
#         ISO C++17 does not allow 'register' storage class specifier
#     -Wdeprecated-register
#           'register' storage class specifier is deprecated and incompatible with C++17
#   -Wreinterpret-base-class
#         'reinterpret_cast' <from|to> class A <to|from> its <virtual base|base at non-zero offset> B behaves differently from 'static_cast'
#   -Wrequires-super-attribute
#         A attribute cannot be applied to <methods in protocols|dealloc>
#   -Wreserved-identifier (partial)
#     -Wreserved-module-identifier
#           A is a reserved name for a module
#     -Wuser-defined-literals
#           user-defined literal suffixes <<ERROR>|not starting with '_'|containing '__'> are reserved[; no literal will invoke this operator]
#   -Wreserved-user-defined-literal (partial)
#         invalid suffix on literal; C++11 requires a space between literal and identifier
#   -Wreturn-local-addr
#     -Wreturn-stack-address
#           <address of|reference to> stack memory associated with <local variable|parameter|compound literal> B returned
#           returning <address of|reference to> local temporary object
#           returning address of label, which is local
#   -Wrewrite-not-bool
#         ISO C++20 requires return type of selected 'operator==' function for rewritten 'B' comparison to be 'bool', not A
#   -Wrtti
#         dynamic_cast will not work since RTTI data is disabled by <-fno-rtti-data|/GR->
#         typeid will not work since RTTI data is disabled by <-fno-rtti-data|/GR->
#   -Wsarif-format-unstable
#         diagnostic formatting in SARIF mode is currently unstable
#   -Wsection
#         <codeseg|section> does not match previous declaration
#         duplicate code segment specifiers
#         section attribute is specified on redeclared variable
#   -Wsentinel
#         missing sentinel in <function call|method dispatch|block call>
#         not enough variable arguments in A declaration to fit a sentinel
#   -Wsequence-point
#     -Wunsequenced
#           multiple unsequenced modifications to A
#           unsequenced modification and access to A
#   -Wserialized-diagnostics
#         received warning after diagnostic serialization teardown was underway: A
#         unable to merge a subprocess's serialized diagnostics
#         unable to open file A for serializing diagnostics (B)
#   -Wshadow-all (partial)
#     -Wshadow (partial)
#       -Wshadow-ivar
#             local declaration of A hides instance variable
#   -Wshift-count-negative
#         shift count is negative
#   -Wshift-count-overflow
#         shift count >= width of type
#   -Wshift-negative-value
#         shifting a negative signed value is undefined
#   -Wshift-overflow
#         signed shift result (A) requires B bits to represent, but C only has D bits
#   -Wsigned-unsigned-wchar
#         'A' cannot be signed or unsigned
#   -Wsizeof-array-div
#         expression does not compute the number of elements in this array; element type is A, not B
#   -Wsizeof-pointer-div
#         'A' will return the size of the pointer, not the array itself
#   -Wslash-u-filename
#         '/UA' treated as the '/U' option
#   -Wslh-asm-goto
#         speculative load hardening does not protect functions with asm goto
#   -Rsloc-usage
#         source manager location address space usage:
#   -Wsource-mgr
#         The text of this diagnostic is not controlled by Clang
#   -Wstack-exhausted
#         stack nearly exhausted; compilation time may suffer, and crashes due to stack overflow are likely
#   -Wstack-protector
#         unable to protect inline asm that clobbers stack pointer against stack clash
#   -Wstatic-float-init
#         in-class initializer for static data member of type A requires 'constexpr' specifier
#     -Wgnu-static-float-init
#           in-class initializer for static data member of type A is a GNU extension
#   -Wstatic-in-inline (partial)
#         static <function|variable> B is used in an inline function with external linkage
#   -Wstatic-inline-explicit-instantiation
#         ignoring '<static|inline>' keyword on explicit template instantiation
#   -Wstatic-local-in-inline
#         non-constant static local variable in inline function may be different in different files
#   -Wstdlibcxx-not-found
#         include path for libstdc++ headers not found; pass '-stdlib=libc++' on the command line to use the libc++ standard library instead
#   -Wstrict-potentially-direct-selector (partial)
#     -Wpotentially-direct-selector
#           @selector expression formed with potentially direct selector A
#   -Wstrict-primary-template-shadow
#         declaration of A shadows template parameter
#   -Wstrict-prototypes (partial)
#     -Wdeprecated-non-prototype
#           a function <declaration|definition> without a prototype is deprecated in all versions of C <and is not supported in C23|and is treated as a zero-parameter prototype in C23, conflicting with a <previous|subsequent> <declaration|definition>>
#           passing arguments to <a function|B> without a prototype is deprecated in all versions of C and is not supported in C23
#   -Wstring-plus-char
#         adding A to a string pointer does not append to the string
#   -Wstrlcpy-strlcat-size
#         size argument in A call appears to be size of the source; expected the size of the destination
#   -Wstrncat-size
#         size argument in 'strncat' call appears to be size of the source
#         the value of the size argument in 'strncat' is too large, might lead to a buffer overflow
#         the value of the size argument to 'strncat' is wrong
#   -Wsuspicious-memaccess
#     -Wdynamic-class-memaccess
#           <destination for|source of|first operand of|second operand of> this B call is a pointer to [class containing a ]dynamic class D; vtable pointer will be <overwritten|copied|moved|compared>
#     -Wmemset-transposed-args
#           <'size' argument to memset is '0'|setting buffer to a 'sizeof' expression>; did you mean to transpose the last two arguments?
#     -Wnontrivial-memaccess
#           <destination for|source of|first operand of|second operand of> this B call is a pointer to record C that is not trivial to <primitive-default-initialize|primitive-copy>
#     -Wsizeof-pointer-memaccess
#           'A' call operates on objects of type B while the size is based on a different type C
#           argument to 'sizeof' in A call is the same pointer type B as the <destination|source>; expected D or an explicit length
#     -Wsuspicious-bzero
#           'size' argument to bzero is '0'
#   -Wswift-name-attribute
#         A attribute argument must be a string literal specifying a Swift function name
#         A attribute cannot be applied to a <function|method> with no parameters
#         A attribute cannot be applied to this declaration
#         A attribute cannot specify more than one 'self:' parameter
#         A attribute for 'subscript' getter cannot have a 'newValue:' parameter
#         A attribute for 'subscript' must <be a getter or setter|have at least one parameter|have a 'self:' parameter>
#         A attribute for 'subscript' setter cannot have multiple 'newValue:' parameters
#         A attribute for 'subscript' setter must have a 'newValue:' parameter
#         A attribute for getter must not have any parameters besides 'self:'
#         A attribute for setter must have one parameter for new value
#         A attribute has invalid identifier for the <base|context|parameter> name
#         A attribute is missing parameter label clause
#         too <few|many> parameters in the signature specified by the B attribute (expected C; got D)
#   -Wsync-alignment
#         __sync builtin operation must have natural alignment (consider using __atomic)
#   -Wsync-fetch-and-nand-semantics-changed
#         the semantics of this intrinsic changed with GCC version 4.4 - the newer semantics are provided here
#   -Wtcb-enforcement
#         calling A is a violation of trusted computing base 'B'
#   -Wtemplate-in-declaration-name
#         'template' cannot be used after a declarative nested name specifier
#   -Wtentative-definition-array
#         tentative array definition assumed to have one element
#   -Wtentative-definition-incomplete-type
#         tentative definition of variable with internal linkage has incomplete non-array type A
#   -Wtype-safety
#         argument type A doesn't match specified B type tag [that requires D]
#         specified A type tag requires a null pointer
#         this type tag was not designed to be used with this function
#   -Wtypedef-redefinition
#         redefinition of typedef A is a C11 feature
#   -Wtypename-missing
#         missing 'typename' prior to dependent type name 'AB'
#   -Wunable-to-open-stats-file
#         unable to open statistics output file 'A': 'B'
#   -Wunaligned-qualifier-implicit-cast
#         implicit cast from type A to type B drops __unaligned qualifier
#   -Wunavailable-declarations
#         A may be unavailable because the receiver type is unknown
#   -Wundefined-arm-za
#         builtin call is not valid when calling from a function without active ZA state
#   -Wundefined-arm-zt0
#         builtin call is not valid when calling from a function without active ZT0 state
#   -Wundefined-inline
#         inline function A is not defined
#   -Wundefined-internal
#         <function|variable> B has internal linkage but is not defined
#   -Wundefined-var-template
#         instantiation of variable A required here, but no definition is available
#   -Wunderaligned-exception-object
#         underaligned exception object thrown
#   -Wunicode
#         \A used with no following hex digits; treating as '\' followed by identifier
#         empty delimited universal character name; treating as '\' 'A' '{' '}'
#         incomplete delimited universal character name; treating as '\' 'A' '{' identifier
#         incomplete universal character name; treating as '\' followed by identifier
#         universal character name refers to a surrogate character
#         universal character names are only valid in C99 or C++
#         universal character names are only valid in C99 or C++; treating as '\' followed by identifier
#   -Wunicode-homoglyph
#         treating Unicode character <U+A> as an identifier character rather than as 'B' symbol
#   -Wunicode-whitespace
#         treating Unicode character as whitespace
#   -Wunicode-zero-width
#         identifier contains Unicode character <U+A> that is invisible in some environments
#   -Wunknown-argument
#         joined argument treated as 'A'; did you mean 'B'?
#         unknown argument ignored in clang-cl 'A'; did you mean 'B'?
#         unknown argument ignored in clang-cl: 'A'
#   -Wunknown-assumption
#         unknown assumption string 'A'; attribute is potentially ignored
#   -Wunknown-cuda-version
#         CUDA version A is only partially supported
#         CUDA versionA is newer than the latest[ partially] supported version C
#   -Wunknown-directives
#         invalid preprocessing directive[, did you mean '#B'?]
#   -Wunknown-escape-sequence
#         unknown escape sequence '\A'
#   -Wunknown-sanitizers
#         unknown sanitizer 'A' ignored
#   -Wunknown-warning-option
#         unknown <warning|remark> option 'B'[; did you mean 'D'?]
#         unknown A warning specifier: 'B'
#         unknown warning group 'A', ignored
#   -Wunnamed-type-template-args (partial)
#         template argument uses unnamed type
#   -Wunqualified-std-cast-call
#         unqualified call to 'A'
#   -Wunreachable-code-aggressive (partial)
#     -Wunreachable-code (partial)
#       -Wunreachable-code-generic-assoc
#             due to lvalue conversion of the controlling expression, association of type A will never be selected because it is <of array type|qualified>
#   -Wunsupported-abi
#         'A': selected processor lacks floating point registers
#         float ABI 'A' is not supported by current library
#   -Wunsupported-abs
#         ignoring '-mabs=2008' option because the 'A' architecture does not support it
#         ignoring '-mabs=legacy' option because the 'A' architecture does not support it
#   -Wunsupported-availability-guard
#         <@available|__builtin_available> does not guard availability here; use if (<@available|__builtin_available>) instead
#   -Wunsupported-cb
#         ignoring '-mcompact-branches=' option because the 'A' architecture does not support it
#   -Wunsupported-floating-point-opt
#         overriding currently unsupported rounding mode on this target
#         overriding currently unsupported use of floating point exceptions on this target
#   -Wunsupported-friend
#         dependent nested name specifier 'A' for friend class declaration is not supported; turning off access control for B
#         dependent nested name specifier 'A' for friend template declaration is not supported; ignoring this friend declaration
#   -Wunsupported-gpopt
#         ignoring '-mgpopt' option as it cannot be used with [the implicit usage of ]-mabicalls
#   -Wunsupported-nan
#         ignoring '-mnan=2008' option because the 'A' architecture does not support it
#         ignoring '-mnan=legacy' option because the 'A' architecture does not support it
#   -Wunsupported-target-opt
#         debug information option 'A' is not supported for target 'B'
#         debug information option 'A' is not supported; requires DWARF-C but target 'B' only provides DWARF-D
#   -Wunsupported-visibility
#         target does not support 'protected' visibility; using 'default'
#   -Wunusable-partial-specialization
#         <class|variable> template partial specialization contains <a template parameter|template parameters> that cannot be deduced; this partial specialization will never be used
#   -Wunused-command-line-argument
#         '-x A' after last input file has no effect
#         'A' only applies to medium and large code models
#         A: 'B' input unused in cpp mode
#         A: 'B' input unused[ when 'D' is present]
#         A: previously preprocessed input[ unused when 'C' is present]
#         argument 'A' requires profile-guided optimization information
#         argument unused during compilation: 'A'
#         ignoring '-f[no-]raw-string-literals', which is only valid for C and C++ standards before C++11
#         ignoring -fdiscard-value-names for LLVM Bitcode
#         ignoring -fverify-debuginfo-preserve-export=A because -fverify-debuginfo-preserve wasn't enabled
#         ignoring invalid /arch: argument 'A'; for <64|32>-bit expected one of C
#         joined argument expects additional value: 'A'
#         the flag 'A' has been deprecated and will be ignored
#   -Wunused-getter-return-value
#         property access result unused - getters should not be used for side effects
#   -Wunused-volatile-lvalue
#         expression result unused; assign into a variable to force a volatile load
#   -Wvarargs
#         passing <an object that undergoes default argument promotion|an object of reference type|a parameter declared with the 'register' keyword> to 'va_start' has undefined behavior
#         second argument to 'va_arg' is of promotable type A; this va_arg has undefined behavior because arguments will be promoted to B
#         second argument to 'va_start' is not the last named parameter
#   -Wvariadic-macros (partial)
#         __VA_OPT__ can only appear in the expansion of a variadic macro
#   -Wvec-elem-size
#         vector operands do not have the same elements sizes (A and B)
#   -Wvexing-parse
#         empty parentheses interpreted as a function declaration
#         parentheses were disambiguated as a function declaration
#         parentheses were disambiguated as redundant parentheses around declaration of variable named A
#   -Wvisibility
#         declaration of A will not be visible outside of this function
#         redefinition of A will not be visible outside of this function
#   -Wvla (partial)
#     -Wvla-extension (partial)
#       -Wvla-cxx-extension (partial)
#             variable length arrays in C++ are a Clang extension
#         -Wvla-extension-static-assert (partial)
#               variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?
#   -Wvoid-ptr-dereference
#         ISO C does not allow indirection on operand of type A
#   -Wwasm-exception-spec
#         dynamic exception specifications with types are currently ignored in wasm
#   -Wwrite-strings
#     -Wwritable-strings
#           ISO C++11 does not allow conversion from string literal to A
#       -Wdeprecated-writable-strings
#         -Wc++11-compat-deprecated-writable-strings
#               conversion from string literal to A is deprecated
#   -Wxor-used-as-pow
#         result of 'A' is B; did you mean 'C' (D)?
#         result of 'A' is B; did you mean 'C'?
#         result of 'A' is B; did you mean exponentiation?
-W
#   -Wextra
#     -Wcast-function-type-mismatch
#           cast converts to incompatible function type
#     -Wdeprecated-copy
#           definition of implicit copy <constructor|assignment operator> for A is deprecated because it has a user-declared copy <assignment operator|constructor>
#       -Wdeprecated-copy-with-user-provided-copy
#             definition of implicit copy <constructor|assignment operator> for A is deprecated because it has a user-provided copy <assignment operator|constructor>
#     -Wempty-init-stmt
#           empty initialization statement of '<if|switch|range-based for>' has no effect
#     -Wfuse-ld-path
#           '-fuse-ld=' taking a path is deprecated; use '--ld-path=' instead
#     -Wignored-qualifiers
#           'A' qualifier on function type B has no effect
#           'A' qualifier on omitted return type B has no effect
#           'A' type qualifier(s) on return type <has|have> no effect
#           ARC <unused|__unsafe_unretained|__strong|__weak|__autoreleasing> lifetime qualifier on return type is ignored
#       -Wignored-reference-qualifiers
#             'A' qualifier on reference type B has no effect
#     -Winitializer-overrides
#           initializer [partially ]overrides prior initialization of this subobject
#     -Wmissing-field-initializers
#           missing field A initializer
#       -Wmissing-designated-field-initializers
#             missing field A initializer
#     -Wmissing-method-return-type
#           method has no return type specified; defaults to 'id'
#     -Wnull-pointer-arithmetic
#           performing pointer arithmetic on a null pointer has undefined behavior[ if the offset is nonzero]
#       -Wgnu-null-pointer-arithmetic
#             arithmetic on a null pointer treated as a cast from integer to pointer is a GNU extension
#     -Wnull-pointer-subtraction
#           performing pointer subtraction with a null pointer <has|may have> undefined behavior
#     -Wsemicolon-before-method-body
#           semicolon before method body is ignored
#     -Wsign-compare
#           comparison of integers of different signs: A and B
#     -Wstring-concatenation
#           suspicious concatenation of string literals in an array initialization; did you mean to separate the elements with a comma?
#     -Wunused-but-set-parameter
#           parameter A set but not used
#     -Wunused-parameter
#           unused parameter A
-Waarch64-sme-attributes
#     <returning|passing> a VL-dependent argument <from|to> a function with a different streaming-mode is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime
#     <returning|passing> a VL-dependent argument <from|to> a locally streaming function is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime
#     always_inline function B and its caller A have mismatching C attributes, inlining may change runtime behaviour
-Wabi # IGNORED switch
-Wabstract-vbase-init
#     initializer for virtual base class A of abstract class B will never be used
-Waggregate-return # IGNORED switch
-Walloca
#     use of function A is discouraged; there is no way to check for failure but failure may still occur, resulting in a possibly exploitable security vulnerability
-Wanon-enum-enum-conversion
#     <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types
#   -Wdeprecated-anon-enum-enum-conversion
#         <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
-Warc-repeated-use-of-weak
#     weak <variable|property|implicit property|instance variable> B is accessed multiple times in this <function|method|block|lambda> but may be unpredictably set to nil; assign to a strong variable to keep the object alive
#   -Warc-maybe-repeated-use-of-weak
#         weak <variable|property|implicit property|instance variable> B may be accessed multiple times in this <function|method|block|lambda> and may be unpredictably set to nil; assign to a strong variable to keep the object alive
-Warray-bounds-pointer-arithmetic
#     the pointer decremented by A refers before the beginning of the array
#     the pointer incremented by A refers past the end of the array (that has type B)
-Wassign-enum
#     integer constant not in range of enumerated type A
-Wat-protocol # IGNORED switch
-Watomic-implicit-seq-cst
#     implicit use of sequentially-consistent atomic may incur stronger memory barriers than necessary
-Watomic-properties
#   -Wcustom-atomic-properties
#         atomic by default property A has a user defined <getter|setter> (property should be marked 'atomic' if this is intended)
#   -Wimplicit-atomic-properties
#         property is assumed atomic by default
#         property is assumed atomic when auto-synthesizing the property
-Wauto-import # IGNORED switch
-Wbad-function-cast
#     cast from function call of type A to non-matching type B
-Wbinary-literal
#   -Wc++14-binary-literal
#         binary integer literals are a C++14 extension
#   -Wc++98-c++11-compat-binary-literal
#         binary integer literals are incompatible with C++ standards before C++14
-Wbind-to-temporary-copy
#     C++98 requires an accessible copy constructor for class C when binding a reference to a temporary; was <private|protected>
#     no viable constructor <copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value> of type B; C++98 requires a copy constructor when binding a reference to a temporary
#   -Wc++98-compat-bind-to-temporary-copy
#         <copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value> of type C when binding a reference to a temporary would <invoke an inaccessible constructor|find no viable constructor|find ambiguous constructors|invoke a deleted constructor> in C++98
-Wc++-compat
#     [empty ]<struct|union> has size 0 in C, <size 1|non-zero size> in C++
-Wc++0x-compat
#   -Wc++11-compat
#         'A' is a keyword in C++11
#         'auto' storage class specifier is redundant and incompatible with C++11
#         explicit instantiation cannot be 'inline'
#         explicit instantiation of A must occur at global scope
#         explicit instantiation of A must occur in namespace B
#         explicit instantiation of A not in a namespace enclosing B
#         identifier after literal will be treated as a user-defined literal suffix in C++11
#         integer literal is too large to be represented in type 'long' and is subject to undefined behavior under C++98, interpreting as 'unsigned long'; this literal will <have type 'long long'|be ill-formed> in C++11 onwards
#         integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C++98; this literal will <have type 'long long'|be ill-formed> in C++11 onwards
#         use of right-shift operator ('>>') in template argument will require parentheses in C++11
#     -Wc++11-compat-deprecated-writable-strings
#           conversion from string literal to A is deprecated
#     -Wc++11-compat-reserved-user-defined-literal
#           identifier after literal will be treated as a reserved user-defined literal suffix in C++11
#     -Wc++11-narrowing
#           <case value|enumerator value|non-type template argument|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#           constant expression evaluates to A which cannot be narrowed to type B
#           constant expression evaluates to A which cannot be narrowed to type B in C++11
#           non-constant-expression cannot be narrowed from type A to B in initializer list
#           non-constant-expression cannot be narrowed from type A to B in initializer list in C++11
#           type A cannot be narrowed to B in initializer list
#           type A cannot be narrowed to B in initializer list in C++11
#       -Wc++11-narrowing-const-reference
#             constant expression evaluates to A which cannot be narrowed to type B
#             non-constant-expression cannot be narrowed from type A to B in initializer list
#             type A cannot be narrowed to B in initializer list
#     -Wpre-c++14-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++14
#           constexpr function with no return statements is incompatible with C++ standards before C++14
#           digit separators are incompatible with C++ standards before C++14
#           generic lambdas are incompatible with C++11
#           initialized lambda captures are incompatible with C++ standards before C++14
#           multiple return statements in constexpr function is incompatible with C++ standards before C++14
#           return type deduction is incompatible with C++ standards before C++14
#           type definition in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           variable declaration in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           variable templates are incompatible with C++ standards before C++14
#     -Wpre-c++17-compat
#           'begin' and 'end' returning different types (A and B) is incompatible with C++ standards before C++17
#           'static_assert' with no message is incompatible with C++ standards before C++17
#           <if|switch> initialization statements are incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           class template argument deduction is incompatible with C++ standards before C++17[; for compatibility, use explicit type name B]
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with A are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
#     -Wpre-c++20-compat
#           '<=>' operator is incompatible with C++ standards before C++20
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           <default construction|assignment> of lambda is incompatible with C++ standards before C++20
#           captured structured bindings are incompatible with C++ standards before C++20
#           class template argument deduction for alias templates is incompatible with C++ standards before C++20
#           constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20
#           constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20
#           decomposition declaration declared <'B'|with 'B' specifiers> is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++20
#           defaulted comparison operators are incompatible with C++ standards before C++20
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20
#           explicit template parameter list for lambdas is incompatible with C++ standards before C++20
#           explicit(bool) is incompatible with C++ standards before C++20
#           explicitly defaulting this <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> with a type different from the implicit type is incompatible with C++ standards before C++20
#           function try block in constexpr <function|constructor> is incompatible with C++ standards before C++20
#           initialized lambda capture packs are incompatible with C++ standards before C++20
#           inline nested namespace definition is incompatible with C++ standards before C++20
#           member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20
#           member using declaration naming non-class 'A' enumerator is incompatible with C++ standards before C++20
#           non-type template parameter of type A is incompatible with C++ standards before C++20
#           passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20
#           range-based for loop initialization statements are incompatible with C++ standards before C++20
#           uninitialized variable in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           using declaration naming a scoped enumerator is incompatible with C++ standards before C++20
#           using enum declaration is incompatible with C++ standards before C++20
#           virtual constexpr functions are incompatible with C++ standards before C++20
#     -Wpre-c++23-compat
#           #warning is incompatible with C++ standards before C++23
#           'auto' as a functional-style cast is incompatible with C++ standards before C++23
#           'size_t' suffix for literals is incompatible with C++ standards before C++23
#           <an attribute specifier sequence|B> in this position is incompatible with C++ standards before C++23
#           <delimited|named> escape sequences are incompatible with C++ standards before C++23
#           alias declaration in this context is incompatible with C++ standards before C++23
#           consteval if is incompatible with C++ standards before C++23
#           declaring overloaded A as 'static' is incompatible with C++ standards before C++23
#           definition of a <static variable|thread_local variable|variable of non-literal type> in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#           label at end of compound statement is incompatible with C++ standards before C++23
#           overloaded A with <no|a defaulted|more than one> parameter is a C++23 extension
#           static lambdas are incompatible with C++ standards before C++23
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C++ standards before C++23
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#     -Wpre-c++26-compat
#            'A' in a raw string literal delimiter is incompatible with standards before C++2c
#           '= delete' with a message is incompatible with C++ standards before C++2c
#           an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#           pack indexing is incompatible with C++ standards before C++2c
#           placeholder variables are incompatible with C++ standards before C++2c
-Wc++0x-extensions
#   -Wc++11-extensions
#         'A' keyword is a C++11 extension
#         'auto' type specifier is a C++11 extension
#         'template' keyword outside of a template
#         'typename' occurs outside of a template
#         <defaulted|deleted> function definitions are a C++11 extension
#         [[]] attributes are a C++11 extension
#         alias declarations are a C++11 extension
#         commas at the end of enumerator lists are a C++11 extension
#         default member initializer for non-static data member is a C++11 extension
#         default template arguments for a function template are a C++11 extension
#         enumeration types with a fixed underlying type are a C++11 extension
#         explicit conversion functions are a C++11 extension
#         extern templates are a C++11 extension
#         generalized initializer lists are a C++11 extension
#         implicit conversion from array size expression of type A to <integral|enumeration> type C is a C++11 extension
#         lambdas are a C++11 extension
#         non-class friend type A is a C++11 extension
#         non-type template argument referring to <function|object> B with internal linkage is a C++11 extension
#         range-based for loop is a C++11 extension
#         reference qualifiers on functions are a C++11 extension
#         rvalue references are a C++11 extension
#         scoped enumerations are a C++11 extension
#         static data member A in union is a C++11 extension
#         unelaborated friend declaration is a C++11 extension; specify '<struct|interface|union|class|enum>' to befriend B
#         use of enumeration in a nested name specifier is a C++11 extension
#         variadic templates are a C++11 extension
#     -Wc++11-extra-semi
#           extra ';' outside of a function is a C++11 extension
#     -Wc++11-inline-namespace
#           inline namespaces are a C++11 feature
#     -Wc++11-long-long
#           'long long' is a C++11 extension
-Wc++0x-narrowing
#   -Wc++11-narrowing
#         <case value|enumerator value|non-type template argument|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#         constant expression evaluates to A which cannot be narrowed to type B
#         constant expression evaluates to A which cannot be narrowed to type B in C++11
#         non-constant-expression cannot be narrowed from type A to B in initializer list
#         non-constant-expression cannot be narrowed from type A to B in initializer list in C++11
#         type A cannot be narrowed to B in initializer list
#         type A cannot be narrowed to B in initializer list in C++11
#     -Wc++11-narrowing-const-reference
#           constant expression evaluates to A which cannot be narrowed to type B
#           non-constant-expression cannot be narrowed from type A to B in initializer list
#           type A cannot be narrowed to B in initializer list
-Wc++11-compat-pedantic
#   -Wc++11-compat
#         'A' is a keyword in C++11
#         'auto' storage class specifier is redundant and incompatible with C++11
#         explicit instantiation cannot be 'inline'
#         explicit instantiation of A must occur at global scope
#         explicit instantiation of A must occur in namespace B
#         explicit instantiation of A not in a namespace enclosing B
#         identifier after literal will be treated as a user-defined literal suffix in C++11
#         integer literal is too large to be represented in type 'long' and is subject to undefined behavior under C++98, interpreting as 'unsigned long'; this literal will <have type 'long long'|be ill-formed> in C++11 onwards
#         integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C++98; this literal will <have type 'long long'|be ill-formed> in C++11 onwards
#         use of right-shift operator ('>>') in template argument will require parentheses in C++11
#     -Wc++11-compat-deprecated-writable-strings
#           conversion from string literal to A is deprecated
#     -Wc++11-compat-reserved-user-defined-literal
#           identifier after literal will be treated as a reserved user-defined literal suffix in C++11
#     -Wc++11-narrowing
#           <case value|enumerator value|non-type template argument|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#           constant expression evaluates to A which cannot be narrowed to type B
#           constant expression evaluates to A which cannot be narrowed to type B in C++11
#           non-constant-expression cannot be narrowed from type A to B in initializer list
#           non-constant-expression cannot be narrowed from type A to B in initializer list in C++11
#           type A cannot be narrowed to B in initializer list
#           type A cannot be narrowed to B in initializer list in C++11
#       -Wc++11-narrowing-const-reference
#             constant expression evaluates to A which cannot be narrowed to type B
#             non-constant-expression cannot be narrowed from type A to B in initializer list
#             type A cannot be narrowed to B in initializer list
#     -Wpre-c++14-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++14
#           constexpr function with no return statements is incompatible with C++ standards before C++14
#           digit separators are incompatible with C++ standards before C++14
#           generic lambdas are incompatible with C++11
#           initialized lambda captures are incompatible with C++ standards before C++14
#           multiple return statements in constexpr function is incompatible with C++ standards before C++14
#           return type deduction is incompatible with C++ standards before C++14
#           type definition in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           variable declaration in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           variable templates are incompatible with C++ standards before C++14
#     -Wpre-c++17-compat
#           'begin' and 'end' returning different types (A and B) is incompatible with C++ standards before C++17
#           'static_assert' with no message is incompatible with C++ standards before C++17
#           <if|switch> initialization statements are incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           class template argument deduction is incompatible with C++ standards before C++17[; for compatibility, use explicit type name B]
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with A are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
#     -Wpre-c++20-compat
#           '<=>' operator is incompatible with C++ standards before C++20
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           <default construction|assignment> of lambda is incompatible with C++ standards before C++20
#           captured structured bindings are incompatible with C++ standards before C++20
#           class template argument deduction for alias templates is incompatible with C++ standards before C++20
#           constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20
#           constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20
#           decomposition declaration declared <'B'|with 'B' specifiers> is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++20
#           defaulted comparison operators are incompatible with C++ standards before C++20
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20
#           explicit template parameter list for lambdas is incompatible with C++ standards before C++20
#           explicit(bool) is incompatible with C++ standards before C++20
#           explicitly defaulting this <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> with a type different from the implicit type is incompatible with C++ standards before C++20
#           function try block in constexpr <function|constructor> is incompatible with C++ standards before C++20
#           initialized lambda capture packs are incompatible with C++ standards before C++20
#           inline nested namespace definition is incompatible with C++ standards before C++20
#           member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20
#           member using declaration naming non-class 'A' enumerator is incompatible with C++ standards before C++20
#           non-type template parameter of type A is incompatible with C++ standards before C++20
#           passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20
#           range-based for loop initialization statements are incompatible with C++ standards before C++20
#           uninitialized variable in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           using declaration naming a scoped enumerator is incompatible with C++ standards before C++20
#           using enum declaration is incompatible with C++ standards before C++20
#           virtual constexpr functions are incompatible with C++ standards before C++20
#     -Wpre-c++23-compat
#           #warning is incompatible with C++ standards before C++23
#           'auto' as a functional-style cast is incompatible with C++ standards before C++23
#           'size_t' suffix for literals is incompatible with C++ standards before C++23
#           <an attribute specifier sequence|B> in this position is incompatible with C++ standards before C++23
#           <delimited|named> escape sequences are incompatible with C++ standards before C++23
#           alias declaration in this context is incompatible with C++ standards before C++23
#           consteval if is incompatible with C++ standards before C++23
#           declaring overloaded A as 'static' is incompatible with C++ standards before C++23
#           definition of a <static variable|thread_local variable|variable of non-literal type> in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#           label at end of compound statement is incompatible with C++ standards before C++23
#           overloaded A with <no|a defaulted|more than one> parameter is a C++23 extension
#           static lambdas are incompatible with C++ standards before C++23
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C++ standards before C++23
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#     -Wpre-c++26-compat
#            'A' in a raw string literal delimiter is incompatible with standards before C++2c
#           '= delete' with a message is incompatible with C++ standards before C++2c
#           an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#           pack indexing is incompatible with C++ standards before C++2c
#           placeholder variables are incompatible with C++ standards before C++2c
#   -Wpre-c++14-compat-pedantic
#     -Wc++98-c++11-compat-binary-literal
#           binary integer literals are incompatible with C++ standards before C++14
#     -Wpre-c++14-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++14
#           constexpr function with no return statements is incompatible with C++ standards before C++14
#           digit separators are incompatible with C++ standards before C++14
#           generic lambdas are incompatible with C++11
#           initialized lambda captures are incompatible with C++ standards before C++14
#           multiple return statements in constexpr function is incompatible with C++ standards before C++14
#           return type deduction is incompatible with C++ standards before C++14
#           type definition in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           variable declaration in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           variable templates are incompatible with C++ standards before C++14
#   -Wpre-c++17-compat-pedantic
#         attributes on <a namespace|an enumerator> declaration are incompatible with C++ standards before C++17
#         hexadecimal floating literals are incompatible with C++ standards before C++17
#     -Wpre-c++17-compat
#           'begin' and 'end' returning different types (A and B) is incompatible with C++ standards before C++17
#           'static_assert' with no message is incompatible with C++ standards before C++17
#           <if|switch> initialization statements are incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           class template argument deduction is incompatible with C++ standards before C++17[; for compatibility, use explicit type name B]
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with A are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
#   -Wpre-c++20-compat-pedantic
#         designated initializers are incompatible with C++ standards before C++20
#         invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++20
#     -Wpre-c++20-compat
#           '<=>' operator is incompatible with C++ standards before C++20
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           <default construction|assignment> of lambda is incompatible with C++ standards before C++20
#           captured structured bindings are incompatible with C++ standards before C++20
#           class template argument deduction for alias templates is incompatible with C++ standards before C++20
#           constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20
#           constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20
#           decomposition declaration declared <'B'|with 'B' specifiers> is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++20
#           defaulted comparison operators are incompatible with C++ standards before C++20
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20
#           explicit template parameter list for lambdas is incompatible with C++ standards before C++20
#           explicit(bool) is incompatible with C++ standards before C++20
#           explicitly defaulting this <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> with a type different from the implicit type is incompatible with C++ standards before C++20
#           function try block in constexpr <function|constructor> is incompatible with C++ standards before C++20
#           initialized lambda capture packs are incompatible with C++ standards before C++20
#           inline nested namespace definition is incompatible with C++ standards before C++20
#           member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20
#           member using declaration naming non-class 'A' enumerator is incompatible with C++ standards before C++20
#           non-type template parameter of type A is incompatible with C++ standards before C++20
#           passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20
#           range-based for loop initialization statements are incompatible with C++ standards before C++20
#           uninitialized variable in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           using declaration naming a scoped enumerator is incompatible with C++ standards before C++20
#           using enum declaration is incompatible with C++ standards before C++20
#           virtual constexpr functions are incompatible with C++ standards before C++20
#   -Wpre-c++23-compat-pedantic
#     -Wpre-c++23-compat
#           #warning is incompatible with C++ standards before C++23
#           'auto' as a functional-style cast is incompatible with C++ standards before C++23
#           'size_t' suffix for literals is incompatible with C++ standards before C++23
#           <an attribute specifier sequence|B> in this position is incompatible with C++ standards before C++23
#           <delimited|named> escape sequences are incompatible with C++ standards before C++23
#           alias declaration in this context is incompatible with C++ standards before C++23
#           consteval if is incompatible with C++ standards before C++23
#           declaring overloaded A as 'static' is incompatible with C++ standards before C++23
#           definition of a <static variable|thread_local variable|variable of non-literal type> in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#           label at end of compound statement is incompatible with C++ standards before C++23
#           overloaded A with <no|a defaulted|more than one> parameter is a C++23 extension
#           static lambdas are incompatible with C++ standards before C++23
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C++ standards before C++23
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#   -Wpre-c++26-compat-pedantic
#     -Wpre-c++26-compat
#            'A' in a raw string literal delimiter is incompatible with standards before C++2c
#           '= delete' with a message is incompatible with C++ standards before C++2c
#           an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#           pack indexing is incompatible with C++ standards before C++2c
#           placeholder variables are incompatible with C++ standards before C++2c
-Wc++14-compat-pedantic
#   -Wc++14-compat
#     -Wpre-c++17-compat
#           'begin' and 'end' returning different types (A and B) is incompatible with C++ standards before C++17
#           'static_assert' with no message is incompatible with C++ standards before C++17
#           <if|switch> initialization statements are incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           class template argument deduction is incompatible with C++ standards before C++17[; for compatibility, use explicit type name B]
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with A are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
#     -Wpre-c++20-compat
#           '<=>' operator is incompatible with C++ standards before C++20
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           <default construction|assignment> of lambda is incompatible with C++ standards before C++20
#           captured structured bindings are incompatible with C++ standards before C++20
#           class template argument deduction for alias templates is incompatible with C++ standards before C++20
#           constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20
#           constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20
#           decomposition declaration declared <'B'|with 'B' specifiers> is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++20
#           defaulted comparison operators are incompatible with C++ standards before C++20
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20
#           explicit template parameter list for lambdas is incompatible with C++ standards before C++20
#           explicit(bool) is incompatible with C++ standards before C++20
#           explicitly defaulting this <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> with a type different from the implicit type is incompatible with C++ standards before C++20
#           function try block in constexpr <function|constructor> is incompatible with C++ standards before C++20
#           initialized lambda capture packs are incompatible with C++ standards before C++20
#           inline nested namespace definition is incompatible with C++ standards before C++20
#           member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20
#           member using declaration naming non-class 'A' enumerator is incompatible with C++ standards before C++20
#           non-type template parameter of type A is incompatible with C++ standards before C++20
#           passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20
#           range-based for loop initialization statements are incompatible with C++ standards before C++20
#           uninitialized variable in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           using declaration naming a scoped enumerator is incompatible with C++ standards before C++20
#           using enum declaration is incompatible with C++ standards before C++20
#           virtual constexpr functions are incompatible with C++ standards before C++20
#     -Wpre-c++23-compat
#           #warning is incompatible with C++ standards before C++23
#           'auto' as a functional-style cast is incompatible with C++ standards before C++23
#           'size_t' suffix for literals is incompatible with C++ standards before C++23
#           <an attribute specifier sequence|B> in this position is incompatible with C++ standards before C++23
#           <delimited|named> escape sequences are incompatible with C++ standards before C++23
#           alias declaration in this context is incompatible with C++ standards before C++23
#           consteval if is incompatible with C++ standards before C++23
#           declaring overloaded A as 'static' is incompatible with C++ standards before C++23
#           definition of a <static variable|thread_local variable|variable of non-literal type> in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#           label at end of compound statement is incompatible with C++ standards before C++23
#           overloaded A with <no|a defaulted|more than one> parameter is a C++23 extension
#           static lambdas are incompatible with C++ standards before C++23
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C++ standards before C++23
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#     -Wpre-c++26-compat
#            'A' in a raw string literal delimiter is incompatible with standards before C++2c
#           '= delete' with a message is incompatible with C++ standards before C++2c
#           an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#           pack indexing is incompatible with C++ standards before C++2c
#           placeholder variables are incompatible with C++ standards before C++2c
#   -Wpre-c++17-compat-pedantic
#         attributes on <a namespace|an enumerator> declaration are incompatible with C++ standards before C++17
#         hexadecimal floating literals are incompatible with C++ standards before C++17
#     -Wpre-c++17-compat
#           'begin' and 'end' returning different types (A and B) is incompatible with C++ standards before C++17
#           'static_assert' with no message is incompatible with C++ standards before C++17
#           <if|switch> initialization statements are incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           class template argument deduction is incompatible with C++ standards before C++17[; for compatibility, use explicit type name B]
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with A are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
#   -Wpre-c++20-compat-pedantic
#         designated initializers are incompatible with C++ standards before C++20
#         invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++20
#     -Wpre-c++20-compat
#           '<=>' operator is incompatible with C++ standards before C++20
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           <default construction|assignment> of lambda is incompatible with C++ standards before C++20
#           captured structured bindings are incompatible with C++ standards before C++20
#           class template argument deduction for alias templates is incompatible with C++ standards before C++20
#           constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20
#           constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20
#           decomposition declaration declared <'B'|with 'B' specifiers> is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++20
#           defaulted comparison operators are incompatible with C++ standards before C++20
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20
#           explicit template parameter list for lambdas is incompatible with C++ standards before C++20
#           explicit(bool) is incompatible with C++ standards before C++20
#           explicitly defaulting this <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> with a type different from the implicit type is incompatible with C++ standards before C++20
#           function try block in constexpr <function|constructor> is incompatible with C++ standards before C++20
#           initialized lambda capture packs are incompatible with C++ standards before C++20
#           inline nested namespace definition is incompatible with C++ standards before C++20
#           member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20
#           member using declaration naming non-class 'A' enumerator is incompatible with C++ standards before C++20
#           non-type template parameter of type A is incompatible with C++ standards before C++20
#           passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20
#           range-based for loop initialization statements are incompatible with C++ standards before C++20
#           uninitialized variable in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           using declaration naming a scoped enumerator is incompatible with C++ standards before C++20
#           using enum declaration is incompatible with C++ standards before C++20
#           virtual constexpr functions are incompatible with C++ standards before C++20
#   -Wpre-c++23-compat-pedantic
#     -Wpre-c++23-compat
#           #warning is incompatible with C++ standards before C++23
#           'auto' as a functional-style cast is incompatible with C++ standards before C++23
#           'size_t' suffix for literals is incompatible with C++ standards before C++23
#           <an attribute specifier sequence|B> in this position is incompatible with C++ standards before C++23
#           <delimited|named> escape sequences are incompatible with C++ standards before C++23
#           alias declaration in this context is incompatible with C++ standards before C++23
#           consteval if is incompatible with C++ standards before C++23
#           declaring overloaded A as 'static' is incompatible with C++ standards before C++23
#           definition of a <static variable|thread_local variable|variable of non-literal type> in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#           label at end of compound statement is incompatible with C++ standards before C++23
#           overloaded A with <no|a defaulted|more than one> parameter is a C++23 extension
#           static lambdas are incompatible with C++ standards before C++23
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C++ standards before C++23
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#   -Wpre-c++26-compat-pedantic
#     -Wpre-c++26-compat
#            'A' in a raw string literal delimiter is incompatible with standards before C++2c
#           '= delete' with a message is incompatible with C++ standards before C++2c
#           an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#           pack indexing is incompatible with C++ standards before C++2c
#           placeholder variables are incompatible with C++ standards before C++2c
-Wc++17-compat-pedantic
#   -Wc++17-compat
#     -Wc++17-compat-mangling
#           mangled name of A will change in C++17 due to non-throwing exception specification in function signature
#     -Wdeprecated-increment-bool
#           incrementing expression of type bool is deprecated and incompatible with C++17
#     -Wdeprecated-register
#           'register' storage class specifier is deprecated and incompatible with C++17
#     -Wpre-c++20-compat
#           '<=>' operator is incompatible with C++ standards before C++20
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           <default construction|assignment> of lambda is incompatible with C++ standards before C++20
#           captured structured bindings are incompatible with C++ standards before C++20
#           class template argument deduction for alias templates is incompatible with C++ standards before C++20
#           constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20
#           constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20
#           decomposition declaration declared <'B'|with 'B' specifiers> is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++20
#           defaulted comparison operators are incompatible with C++ standards before C++20
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20
#           explicit template parameter list for lambdas is incompatible with C++ standards before C++20
#           explicit(bool) is incompatible with C++ standards before C++20
#           explicitly defaulting this <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> with a type different from the implicit type is incompatible with C++ standards before C++20
#           function try block in constexpr <function|constructor> is incompatible with C++ standards before C++20
#           initialized lambda capture packs are incompatible with C++ standards before C++20
#           inline nested namespace definition is incompatible with C++ standards before C++20
#           member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20
#           member using declaration naming non-class 'A' enumerator is incompatible with C++ standards before C++20
#           non-type template parameter of type A is incompatible with C++ standards before C++20
#           passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20
#           range-based for loop initialization statements are incompatible with C++ standards before C++20
#           uninitialized variable in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           using declaration naming a scoped enumerator is incompatible with C++ standards before C++20
#           using enum declaration is incompatible with C++ standards before C++20
#           virtual constexpr functions are incompatible with C++ standards before C++20
#     -Wpre-c++23-compat
#           #warning is incompatible with C++ standards before C++23
#           'auto' as a functional-style cast is incompatible with C++ standards before C++23
#           'size_t' suffix for literals is incompatible with C++ standards before C++23
#           <an attribute specifier sequence|B> in this position is incompatible with C++ standards before C++23
#           <delimited|named> escape sequences are incompatible with C++ standards before C++23
#           alias declaration in this context is incompatible with C++ standards before C++23
#           consteval if is incompatible with C++ standards before C++23
#           declaring overloaded A as 'static' is incompatible with C++ standards before C++23
#           definition of a <static variable|thread_local variable|variable of non-literal type> in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#           label at end of compound statement is incompatible with C++ standards before C++23
#           overloaded A with <no|a defaulted|more than one> parameter is a C++23 extension
#           static lambdas are incompatible with C++ standards before C++23
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C++ standards before C++23
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#     -Wpre-c++26-compat
#            'A' in a raw string literal delimiter is incompatible with standards before C++2c
#           '= delete' with a message is incompatible with C++ standards before C++2c
#           an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#           pack indexing is incompatible with C++ standards before C++2c
#           placeholder variables are incompatible with C++ standards before C++2c
#   -Wpre-c++20-compat-pedantic
#         designated initializers are incompatible with C++ standards before C++20
#         invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++20
#     -Wpre-c++20-compat
#           '<=>' operator is incompatible with C++ standards before C++20
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           <default construction|assignment> of lambda is incompatible with C++ standards before C++20
#           captured structured bindings are incompatible with C++ standards before C++20
#           class template argument deduction for alias templates is incompatible with C++ standards before C++20
#           constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20
#           constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20
#           decomposition declaration declared <'B'|with 'B' specifiers> is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++20
#           defaulted comparison operators are incompatible with C++ standards before C++20
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20
#           explicit template parameter list for lambdas is incompatible with C++ standards before C++20
#           explicit(bool) is incompatible with C++ standards before C++20
#           explicitly defaulting this <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> with a type different from the implicit type is incompatible with C++ standards before C++20
#           function try block in constexpr <function|constructor> is incompatible with C++ standards before C++20
#           initialized lambda capture packs are incompatible with C++ standards before C++20
#           inline nested namespace definition is incompatible with C++ standards before C++20
#           member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20
#           member using declaration naming non-class 'A' enumerator is incompatible with C++ standards before C++20
#           non-type template parameter of type A is incompatible with C++ standards before C++20
#           passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20
#           range-based for loop initialization statements are incompatible with C++ standards before C++20
#           uninitialized variable in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           using declaration naming a scoped enumerator is incompatible with C++ standards before C++20
#           using enum declaration is incompatible with C++ standards before C++20
#           virtual constexpr functions are incompatible with C++ standards before C++20
#   -Wpre-c++23-compat-pedantic
#     -Wpre-c++23-compat
#           #warning is incompatible with C++ standards before C++23
#           'auto' as a functional-style cast is incompatible with C++ standards before C++23
#           'size_t' suffix for literals is incompatible with C++ standards before C++23
#           <an attribute specifier sequence|B> in this position is incompatible with C++ standards before C++23
#           <delimited|named> escape sequences are incompatible with C++ standards before C++23
#           alias declaration in this context is incompatible with C++ standards before C++23
#           consteval if is incompatible with C++ standards before C++23
#           declaring overloaded A as 'static' is incompatible with C++ standards before C++23
#           definition of a <static variable|thread_local variable|variable of non-literal type> in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#           label at end of compound statement is incompatible with C++ standards before C++23
#           overloaded A with <no|a defaulted|more than one> parameter is a C++23 extension
#           static lambdas are incompatible with C++ standards before C++23
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C++ standards before C++23
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#   -Wpre-c++26-compat-pedantic
#     -Wpre-c++26-compat
#            'A' in a raw string literal delimiter is incompatible with standards before C++2c
#           '= delete' with a message is incompatible with C++ standards before C++2c
#           an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#           pack indexing is incompatible with C++ standards before C++2c
#           placeholder variables are incompatible with C++ standards before C++2c
-Wc++1y-extensions
#   -Wc++14-extensions
#         'decltype(auto)' type specifier is a C++14 extension
#         initialized lambda captures are a C++14 extension
#         multiple return statements in constexpr function is a C++14 extension
#         type definition in a constexpr <function|constructor> is a C++14 extension
#         use of this statement in a constexpr <function|constructor> is a C++14 extension
#         variable declaration in a constexpr <function|constructor> is a C++14 extension
#         variable templates are a C++14 extension
#     -Wc++14-attribute-extensions
#           use of the A attribute is a C++14 extension
#     -Wc++14-binary-literal
#           binary integer literals are a C++14 extension
-Wc++1z-compat
#   -Wc++17-compat
#     -Wc++17-compat-mangling
#           mangled name of A will change in C++17 due to non-throwing exception specification in function signature
#     -Wdeprecated-increment-bool
#           incrementing expression of type bool is deprecated and incompatible with C++17
#     -Wdeprecated-register
#           'register' storage class specifier is deprecated and incompatible with C++17
#     -Wpre-c++20-compat
#           '<=>' operator is incompatible with C++ standards before C++20
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           <default construction|assignment> of lambda is incompatible with C++ standards before C++20
#           captured structured bindings are incompatible with C++ standards before C++20
#           class template argument deduction for alias templates is incompatible with C++ standards before C++20
#           constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20
#           constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20
#           decomposition declaration declared <'B'|with 'B' specifiers> is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++20
#           defaulted comparison operators are incompatible with C++ standards before C++20
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20
#           explicit template parameter list for lambdas is incompatible with C++ standards before C++20
#           explicit(bool) is incompatible with C++ standards before C++20
#           explicitly defaulting this <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> with a type different from the implicit type is incompatible with C++ standards before C++20
#           function try block in constexpr <function|constructor> is incompatible with C++ standards before C++20
#           initialized lambda capture packs are incompatible with C++ standards before C++20
#           inline nested namespace definition is incompatible with C++ standards before C++20
#           member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20
#           member using declaration naming non-class 'A' enumerator is incompatible with C++ standards before C++20
#           non-type template parameter of type A is incompatible with C++ standards before C++20
#           passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20
#           range-based for loop initialization statements are incompatible with C++ standards before C++20
#           uninitialized variable in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           using declaration naming a scoped enumerator is incompatible with C++ standards before C++20
#           using enum declaration is incompatible with C++ standards before C++20
#           virtual constexpr functions are incompatible with C++ standards before C++20
#     -Wpre-c++23-compat
#           #warning is incompatible with C++ standards before C++23
#           'auto' as a functional-style cast is incompatible with C++ standards before C++23
#           'size_t' suffix for literals is incompatible with C++ standards before C++23
#           <an attribute specifier sequence|B> in this position is incompatible with C++ standards before C++23
#           <delimited|named> escape sequences are incompatible with C++ standards before C++23
#           alias declaration in this context is incompatible with C++ standards before C++23
#           consteval if is incompatible with C++ standards before C++23
#           declaring overloaded A as 'static' is incompatible with C++ standards before C++23
#           definition of a <static variable|thread_local variable|variable of non-literal type> in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#           label at end of compound statement is incompatible with C++ standards before C++23
#           overloaded A with <no|a defaulted|more than one> parameter is a C++23 extension
#           static lambdas are incompatible with C++ standards before C++23
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C++ standards before C++23
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#     -Wpre-c++26-compat
#            'A' in a raw string literal delimiter is incompatible with standards before C++2c
#           '= delete' with a message is incompatible with C++ standards before C++2c
#           an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#           pack indexing is incompatible with C++ standards before C++2c
#           placeholder variables are incompatible with C++ standards before C++2c
-Wc++1z-extensions
#   -Wc++17-extensions
#         '<if|switch>' initialization statements are a C++17 extension
#         'begin' and 'end' returning different types (A and B) is a C++17 extension
#         'constexpr' on lambda expressions is a C++17 extension
#         'static_assert' with no message is a C++17 extension
#         ISO C++ standards before C++17 do not allow new expression for type A to use list-initialization
#         attributes on <a namespace|an enumerator> declaration are a C++17 extension
#         capture of '*this' by copy is a C++17 extension
#         constexpr if is a C++17 extension
#         decomposition declarations are a C++17 extension
#         default scope specifier for attributes is a C++17 extension
#         hexadecimal floating literals are a C++17 feature
#         inline variables are a C++17 extension
#         nested namespace definition is a C++17 extension; define each namespace separately
#         pack expansion of using declaration is a C++17 extension
#         pack fold expression is a C++17 extension
#         template template parameter using 'typename' is a C++17 extension
#         use of multiple declarators in a single using declaration is a C++17 extension
#     -Wc++17-attribute-extensions
#           use of the A attribute is a C++17 extension
-Wc++23-compat
#   -Wpre-c++26-compat
#          'A' in a raw string literal delimiter is incompatible with standards before C++2c
#         '= delete' with a message is incompatible with C++ standards before C++2c
#         an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#         pack indexing is incompatible with C++ standards before C++2c
#         placeholder variables are incompatible with C++ standards before C++2c
-Wc++2a-compat
#   -Wc++20-compat
#         '<=>' is a single token in C++20; add a space to avoid a change in behavior
#         'A' is a keyword in C++20
#         'consteval' specifier is incompatible with C++ standards before C++20
#         'constinit' specifier is incompatible with C++ standards before C++20
#         aggregate initialization of type A with user-declared constructors is incompatible with C++20
#         taking address of non-addressable standard library function is incompatible with C++20
#         this expression will be parsed as explicit(bool) in C++20
#         type of UTF-8 string literal will change from array of const char to array of const char8_t in C++20
#         use of implicit 'typename' is incompatible with C++ standards before C++20
#     -Wpre-c++23-compat
#           #warning is incompatible with C++ standards before C++23
#           'auto' as a functional-style cast is incompatible with C++ standards before C++23
#           'size_t' suffix for literals is incompatible with C++ standards before C++23
#           <an attribute specifier sequence|B> in this position is incompatible with C++ standards before C++23
#           <delimited|named> escape sequences are incompatible with C++ standards before C++23
#           alias declaration in this context is incompatible with C++ standards before C++23
#           consteval if is incompatible with C++ standards before C++23
#           declaring overloaded A as 'static' is incompatible with C++ standards before C++23
#           definition of a <static variable|thread_local variable|variable of non-literal type> in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#           label at end of compound statement is incompatible with C++ standards before C++23
#           overloaded A with <no|a defaulted|more than one> parameter is a C++23 extension
#           static lambdas are incompatible with C++ standards before C++23
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C++ standards before C++23
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#     -Wpre-c++26-compat
#            'A' in a raw string literal delimiter is incompatible with standards before C++2c
#           '= delete' with a message is incompatible with C++ standards before C++2c
#           an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#           pack indexing is incompatible with C++ standards before C++2c
#           placeholder variables are incompatible with C++ standards before C++2c
-Wc++2a-compat-pedantic
#   -Wc++20-compat-pedantic
#     -Wc++20-compat
#           '<=>' is a single token in C++20; add a space to avoid a change in behavior
#           'A' is a keyword in C++20
#           'consteval' specifier is incompatible with C++ standards before C++20
#           'constinit' specifier is incompatible with C++ standards before C++20
#           aggregate initialization of type A with user-declared constructors is incompatible with C++20
#           taking address of non-addressable standard library function is incompatible with C++20
#           this expression will be parsed as explicit(bool) in C++20
#           type of UTF-8 string literal will change from array of const char to array of const char8_t in C++20
#           use of implicit 'typename' is incompatible with C++ standards before C++20
#       -Wpre-c++23-compat
#             #warning is incompatible with C++ standards before C++23
#             'auto' as a functional-style cast is incompatible with C++ standards before C++23
#             'size_t' suffix for literals is incompatible with C++ standards before C++23
#             <an attribute specifier sequence|B> in this position is incompatible with C++ standards before C++23
#             <delimited|named> escape sequences are incompatible with C++ standards before C++23
#             alias declaration in this context is incompatible with C++ standards before C++23
#             consteval if is incompatible with C++ standards before C++23
#             declaring overloaded A as 'static' is incompatible with C++ standards before C++23
#             definition of a <static variable|thread_local variable|variable of non-literal type> in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#             label at end of compound statement is incompatible with C++ standards before C++23
#             overloaded A with <no|a defaulted|more than one> parameter is a C++23 extension
#             static lambdas are incompatible with C++ standards before C++23
#             use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C++ standards before C++23
#             use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#       -Wpre-c++26-compat
#              'A' in a raw string literal delimiter is incompatible with standards before C++2c
#             '= delete' with a message is incompatible with C++ standards before C++2c
#             an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#             pack indexing is incompatible with C++ standards before C++2c
#             placeholder variables are incompatible with C++ standards before C++2c
#     -Wpre-c++23-compat-pedantic
#       -Wpre-c++23-compat
#             #warning is incompatible with C++ standards before C++23
#             'auto' as a functional-style cast is incompatible with C++ standards before C++23
#             'size_t' suffix for literals is incompatible with C++ standards before C++23
#             <an attribute specifier sequence|B> in this position is incompatible with C++ standards before C++23
#             <delimited|named> escape sequences are incompatible with C++ standards before C++23
#             alias declaration in this context is incompatible with C++ standards before C++23
#             consteval if is incompatible with C++ standards before C++23
#             declaring overloaded A as 'static' is incompatible with C++ standards before C++23
#             definition of a <static variable|thread_local variable|variable of non-literal type> in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#             label at end of compound statement is incompatible with C++ standards before C++23
#             overloaded A with <no|a defaulted|more than one> parameter is a C++23 extension
#             static lambdas are incompatible with C++ standards before C++23
#             use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C++ standards before C++23
#             use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#     -Wpre-c++26-compat-pedantic
#       -Wpre-c++26-compat
#              'A' in a raw string literal delimiter is incompatible with standards before C++2c
#             '= delete' with a message is incompatible with C++ standards before C++2c
#             an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#             pack indexing is incompatible with C++ standards before C++2c
#             placeholder variables are incompatible with C++ standards before C++2c
-Wc++2a-extensions
#   -Wc++20-extensions
#         aggregate initialization of type A from a parenthesized list of values is a C++20 extension
#         captured structured bindings are a C++20 extension
#         constexpr constructor that does not initialize all members is a C++20 extension
#         constexpr union constructor that does not initialize any member is a C++20 extension
#         decomposition declaration declared <'B'|with 'B' specifiers> is a C++20 extension
#         default member initializer for bit-field is a C++20 extension
#         defaulted comparison operators are a C++20 extension
#         explicit capture of 'this' with a capture default of '=' is a C++20 extension
#         explicit template parameter list for lambdas is a C++20 extension
#         explicit(bool) is a C++20 extension
#         function try block in constexpr <function|constructor> is a C++20 extension
#         initialized lambda pack captures are a C++20 extension
#         inline nested namespace definition is a C++20 extension
#         invoking a pointer to a 'const &' member function on an rvalue is a C++20 extension
#         missing 'typename' prior to dependent type name AB; implicit 'typename' is a C++20 extension
#         passing no argument for the '...' parameter of a variadic macro is a C++20 extension
#         range-based for loop initialization statements are a C++20 extension
#         uninitialized variable in a constexpr <function|constructor> is a C++20 extension
#         use of function template name with no prior declaration in function call with explicit template arguments is a C++20 extension
#         use of this statement in a constexpr <function|constructor> is a C++20 extension
#         using declaration naming a scoped enumerator is a C++20 extension
#         using enum declaration is a C++20 extension
#     -Wc++20-attribute-extensions
#           use of the A attribute is a C++20 extension
#     -Wc++20-designator
#           designated initializers are a C++20 extension
-Wc++2c-extensions
#   -Wc++26-extensions
#          'A' in a raw string literal delimiter is a C++2c extension
#         '= delete' with a message is a C++2c extension
#         an attribute specifier sequence attached to a structured binding declaration is a C++2c extension
#         pack indexing is a C++2c extension
#         placeholder variables are a C++2c extension
-Wc++98-c++11-c++14-c++17-compat
#   -Wpre-c++20-compat
#         '<=>' operator is incompatible with C++ standards before C++20
#         'char8_t' type specifier is incompatible with C++ standards before C++20
#         <default construction|assignment> of lambda is incompatible with C++ standards before C++20
#         captured structured bindings are incompatible with C++ standards before C++20
#         class template argument deduction for alias templates is incompatible with C++ standards before C++20
#         constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20
#         constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20
#         decomposition declaration declared <'B'|with 'B' specifiers> is incompatible with C++ standards before C++20
#         default member initializer for bit-field is incompatible with C++ standards before C++20
#         defaulted comparison operators are incompatible with C++ standards before C++20
#         explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20
#         explicit template parameter list for lambdas is incompatible with C++ standards before C++20
#         explicit(bool) is incompatible with C++ standards before C++20
#         explicitly defaulting this <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> with a type different from the implicit type is incompatible with C++ standards before C++20
#         function try block in constexpr <function|constructor> is incompatible with C++ standards before C++20
#         initialized lambda capture packs are incompatible with C++ standards before C++20
#         inline nested namespace definition is incompatible with C++ standards before C++20
#         member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20
#         member using declaration naming non-class 'A' enumerator is incompatible with C++ standards before C++20
#         non-type template parameter of type A is incompatible with C++ standards before C++20
#         passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20
#         range-based for loop initialization statements are incompatible with C++ standards before C++20
#         uninitialized variable in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#         use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20
#         use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#         using declaration naming a scoped enumerator is incompatible with C++ standards before C++20
#         using enum declaration is incompatible with C++ standards before C++20
#         virtual constexpr functions are incompatible with C++ standards before C++20
-Wc++98-c++11-c++14-c++17-compat-pedantic
#   -Wpre-c++20-compat-pedantic
#         designated initializers are incompatible with C++ standards before C++20
#         invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++20
#     -Wpre-c++20-compat
#           '<=>' operator is incompatible with C++ standards before C++20
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           <default construction|assignment> of lambda is incompatible with C++ standards before C++20
#           captured structured bindings are incompatible with C++ standards before C++20
#           class template argument deduction for alias templates is incompatible with C++ standards before C++20
#           constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20
#           constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20
#           decomposition declaration declared <'B'|with 'B' specifiers> is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++20
#           defaulted comparison operators are incompatible with C++ standards before C++20
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20
#           explicit template parameter list for lambdas is incompatible with C++ standards before C++20
#           explicit(bool) is incompatible with C++ standards before C++20
#           explicitly defaulting this <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> with a type different from the implicit type is incompatible with C++ standards before C++20
#           function try block in constexpr <function|constructor> is incompatible with C++ standards before C++20
#           initialized lambda capture packs are incompatible with C++ standards before C++20
#           inline nested namespace definition is incompatible with C++ standards before C++20
#           member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20
#           member using declaration naming non-class 'A' enumerator is incompatible with C++ standards before C++20
#           non-type template parameter of type A is incompatible with C++ standards before C++20
#           passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20
#           range-based for loop initialization statements are incompatible with C++ standards before C++20
#           uninitialized variable in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           using declaration naming a scoped enumerator is incompatible with C++ standards before C++20
#           using enum declaration is incompatible with C++ standards before C++20
#           virtual constexpr functions are incompatible with C++ standards before C++20
-Wc++98-c++11-c++14-compat
#   -Wpre-c++17-compat
#         'begin' and 'end' returning different types (A and B) is incompatible with C++ standards before C++17
#         'static_assert' with no message is incompatible with C++ standards before C++17
#         <if|switch> initialization statements are incompatible with C++ standards before C++17
#         by value capture of '*this' is incompatible with C++ standards before C++17
#         class template argument deduction is incompatible with C++ standards before C++17[; for compatibility, use explicit type name B]
#         constexpr if is incompatible with C++ standards before C++17
#         constexpr on lambda expressions is incompatible with C++ standards before C++17
#         decomposition declarations are incompatible with C++ standards before C++17
#         default scope specifier for attributes is incompatible with C++ standards before C++17
#         inline variables are incompatible with C++ standards before C++17
#         nested namespace definition is incompatible with C++ standards before C++17
#         non-type template parameters declared with A are incompatible with C++ standards before C++17
#         pack expansion using declaration is incompatible with C++ standards before C++17
#         pack fold expression is incompatible with C++ standards before C++17
#         template template parameter using 'typename' is incompatible with C++ standards before C++17
#         unicode literals are incompatible with C++ standards before C++17
#         use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
-Wc++98-c++11-c++14-compat-pedantic
#   -Wpre-c++17-compat-pedantic
#         attributes on <a namespace|an enumerator> declaration are incompatible with C++ standards before C++17
#         hexadecimal floating literals are incompatible with C++ standards before C++17
#     -Wpre-c++17-compat
#           'begin' and 'end' returning different types (A and B) is incompatible with C++ standards before C++17
#           'static_assert' with no message is incompatible with C++ standards before C++17
#           <if|switch> initialization statements are incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           class template argument deduction is incompatible with C++ standards before C++17[; for compatibility, use explicit type name B]
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with A are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
-Wc++98-c++11-compat
#   -Wpre-c++14-compat
#         'decltype(auto)' type specifier is incompatible with C++ standards before C++14
#         constexpr function with no return statements is incompatible with C++ standards before C++14
#         digit separators are incompatible with C++ standards before C++14
#         generic lambdas are incompatible with C++11
#         initialized lambda captures are incompatible with C++ standards before C++14
#         multiple return statements in constexpr function is incompatible with C++ standards before C++14
#         return type deduction is incompatible with C++ standards before C++14
#         type definition in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#         use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#         variable declaration in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#         variable templates are incompatible with C++ standards before C++14
-Wc++98-c++11-compat-pedantic
#   -Wpre-c++14-compat-pedantic
#     -Wc++98-c++11-compat-binary-literal
#           binary integer literals are incompatible with C++ standards before C++14
#     -Wpre-c++14-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++14
#           constexpr function with no return statements is incompatible with C++ standards before C++14
#           digit separators are incompatible with C++ standards before C++14
#           generic lambdas are incompatible with C++11
#           initialized lambda captures are incompatible with C++ standards before C++14
#           multiple return statements in constexpr function is incompatible with C++ standards before C++14
#           return type deduction is incompatible with C++ standards before C++14
#           type definition in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           variable declaration in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           variable templates are incompatible with C++ standards before C++14
-Wc++98-compat-pedantic
#     #line number greater than 32767 is incompatible with C++98
#     'long long' is incompatible with C++98
#     C++98 requires newline at end of file
#     cast between pointer-to-function and pointer-to-object is incompatible with C++98
#     commas at the end of enumerator lists are incompatible with C++98
#     empty macro arguments are incompatible with C++98
#     extern templates are incompatible with C++98
#     implicit conversion from array size expression of type A to <integral|enumeration> type C is incompatible with C++98
#     variadic macros are incompatible with C++98
#   -Wc++98-compat
#         '<::' is treated as digraph '<:' (aka '[') followed by ':' in C++98
#         'A' keyword is incompatible with C++98
#         'A' type specifier is incompatible with C++98
#         'alignas' is incompatible with C++98
#         'auto' type specifier is incompatible with C++98
#         'constexpr' specifier is incompatible with C++98
#         'decltype' type specifier is incompatible with C++98
#         'nullptr' is incompatible with C++98
#         'static_assert' declarations are incompatible with C++98
#         <anonymous struct|union> member B with a non-trivial <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> is incompatible with C++98
#         <defaulted|deleted> function definitions are incompatible with C++98
#         [[]] attributes are incompatible with C++ standards before C++11
#         alias declarations are incompatible with C++98
#         alignof expressions are incompatible with C++98
#         befriending B without '<struct|interface|union|class|enum>' keyword is incompatible with C++98
#         consecutive right angle brackets are incompatible with C++98 (use '> >')
#         constructor call from initializer list is incompatible with C++98
#         default member initializer for non-static data members is incompatible with C++98
#         default template arguments for a function template are incompatible with C++98
#         delegating constructors are incompatible with C++98
#         enumeration type in nested name specifier is incompatible with C++98
#         enumeration types with a fixed underlying type are incompatible with C++98
#         explicit conversion functions are incompatible with C++98
#         friend declaration naming a member of the declaring class is incompatible with C++98
#         generalized initializer lists are incompatible with C++98
#         inheriting constructors are incompatible with C++98
#         initialization of initializer_list object is incompatible with C++98
#         initializing A from an empty initializer list is incompatible with C++98
#         inline namespaces are incompatible with C++98
#         jump from switch statement to this case label is incompatible with C++98
#         jump from this <indirect|asm> goto statement to one of its possible targets is incompatible with C++98
#         jump from this goto statement to its label is incompatible with C++98
#         lambda expressions are incompatible with C++98
#         literal operators are incompatible with C++98
#         noexcept expressions are incompatible with C++98
#         noexcept specifications are incompatible with C++98
#         non-class friend type A is incompatible with C++98
#         non-type template argument referring to <function|object> B with internal linkage is incompatible with C++98
#         passing object of trivial but non-POD type A through variadic <function|block|method|constructor> is incompatible with C++98
#         range-based for loop is incompatible with C++98
#         raw string literals are incompatible with C++98
#         redundant parentheses surrounding address non-type template argument are incompatible with C++98
#         reference initialized from initializer list is incompatible with C++98
#         reference qualifiers on functions are incompatible with C++98
#         rvalue references are incompatible with C++98
#         scalar initialized from empty initializer list is incompatible with C++98
#         scoped enumerations are incompatible with C++98
#         specifying character 'A' with a universal character name is incompatible with C++98
#         static data member A in union is incompatible with C++98
#         substitution failure due to access control is incompatible with C++98
#         trailing return types are incompatible with C++98
#         unicode literals are incompatible with C++98
#         universal character name referring to a control character is incompatible with C++98
#         use of 'template' keyword outside of a template is incompatible with C++98
#         use of 'typename' outside of a template is incompatible with C++98
#         use of non-static data member A in an unevaluated context is incompatible with C++98
#         use of null pointer as non-type template argument is incompatible with C++98
#         variadic templates are incompatible with C++98
#     -Wc++98-compat-local-type-template-args
#           local type A as template argument is incompatible with C++98
#     -Wc++98-compat-unnamed-type-template-args
#           unnamed type as template argument is incompatible with C++98
#     -Wpre-c++14-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++14
#           constexpr function with no return statements is incompatible with C++ standards before C++14
#           digit separators are incompatible with C++ standards before C++14
#           generic lambdas are incompatible with C++11
#           initialized lambda captures are incompatible with C++ standards before C++14
#           multiple return statements in constexpr function is incompatible with C++ standards before C++14
#           return type deduction is incompatible with C++ standards before C++14
#           type definition in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           variable declaration in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           variable templates are incompatible with C++ standards before C++14
#     -Wpre-c++17-compat
#           'begin' and 'end' returning different types (A and B) is incompatible with C++ standards before C++17
#           'static_assert' with no message is incompatible with C++ standards before C++17
#           <if|switch> initialization statements are incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           class template argument deduction is incompatible with C++ standards before C++17[; for compatibility, use explicit type name B]
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with A are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
#     -Wpre-c++20-compat
#           '<=>' operator is incompatible with C++ standards before C++20
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           <default construction|assignment> of lambda is incompatible with C++ standards before C++20
#           captured structured bindings are incompatible with C++ standards before C++20
#           class template argument deduction for alias templates is incompatible with C++ standards before C++20
#           constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20
#           constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20
#           decomposition declaration declared <'B'|with 'B' specifiers> is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++20
#           defaulted comparison operators are incompatible with C++ standards before C++20
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20
#           explicit template parameter list for lambdas is incompatible with C++ standards before C++20
#           explicit(bool) is incompatible with C++ standards before C++20
#           explicitly defaulting this <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> with a type different from the implicit type is incompatible with C++ standards before C++20
#           function try block in constexpr <function|constructor> is incompatible with C++ standards before C++20
#           initialized lambda capture packs are incompatible with C++ standards before C++20
#           inline nested namespace definition is incompatible with C++ standards before C++20
#           member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20
#           member using declaration naming non-class 'A' enumerator is incompatible with C++ standards before C++20
#           non-type template parameter of type A is incompatible with C++ standards before C++20
#           passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20
#           range-based for loop initialization statements are incompatible with C++ standards before C++20
#           uninitialized variable in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           using declaration naming a scoped enumerator is incompatible with C++ standards before C++20
#           using enum declaration is incompatible with C++ standards before C++20
#           virtual constexpr functions are incompatible with C++ standards before C++20
#     -Wpre-c++23-compat
#           #warning is incompatible with C++ standards before C++23
#           'auto' as a functional-style cast is incompatible with C++ standards before C++23
#           'size_t' suffix for literals is incompatible with C++ standards before C++23
#           <an attribute specifier sequence|B> in this position is incompatible with C++ standards before C++23
#           <delimited|named> escape sequences are incompatible with C++ standards before C++23
#           alias declaration in this context is incompatible with C++ standards before C++23
#           consteval if is incompatible with C++ standards before C++23
#           declaring overloaded A as 'static' is incompatible with C++ standards before C++23
#           definition of a <static variable|thread_local variable|variable of non-literal type> in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#           label at end of compound statement is incompatible with C++ standards before C++23
#           overloaded A with <no|a defaulted|more than one> parameter is a C++23 extension
#           static lambdas are incompatible with C++ standards before C++23
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C++ standards before C++23
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#     -Wpre-c++26-compat
#            'A' in a raw string literal delimiter is incompatible with standards before C++2c
#           '= delete' with a message is incompatible with C++ standards before C++2c
#           an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#           pack indexing is incompatible with C++ standards before C++2c
#           placeholder variables are incompatible with C++ standards before C++2c
#   -Wc++98-compat-bind-to-temporary-copy
#         <copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value> of type C when binding a reference to a temporary would <invoke an inaccessible constructor|find no viable constructor|find ambiguous constructors|invoke a deleted constructor> in C++98
#   -Wc++98-compat-extra-semi
#         extra ';' outside of a function is incompatible with C++98
#   -Wpre-c++14-compat-pedantic
#     -Wc++98-c++11-compat-binary-literal
#           binary integer literals are incompatible with C++ standards before C++14
#     -Wpre-c++14-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++14
#           constexpr function with no return statements is incompatible with C++ standards before C++14
#           digit separators are incompatible with C++ standards before C++14
#           generic lambdas are incompatible with C++11
#           initialized lambda captures are incompatible with C++ standards before C++14
#           multiple return statements in constexpr function is incompatible with C++ standards before C++14
#           return type deduction is incompatible with C++ standards before C++14
#           type definition in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           variable declaration in a constexpr <function|constructor> is incompatible with C++ standards before C++14
#           variable templates are incompatible with C++ standards before C++14
#   -Wpre-c++17-compat-pedantic
#         attributes on <a namespace|an enumerator> declaration are incompatible with C++ standards before C++17
#         hexadecimal floating literals are incompatible with C++ standards before C++17
#     -Wpre-c++17-compat
#           'begin' and 'end' returning different types (A and B) is incompatible with C++ standards before C++17
#           'static_assert' with no message is incompatible with C++ standards before C++17
#           <if|switch> initialization statements are incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           class template argument deduction is incompatible with C++ standards before C++17[; for compatibility, use explicit type name B]
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with A are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
#   -Wpre-c++20-compat-pedantic
#         designated initializers are incompatible with C++ standards before C++20
#         invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++20
#     -Wpre-c++20-compat
#           '<=>' operator is incompatible with C++ standards before C++20
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           <default construction|assignment> of lambda is incompatible with C++ standards before C++20
#           captured structured bindings are incompatible with C++ standards before C++20
#           class template argument deduction for alias templates is incompatible with C++ standards before C++20
#           constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20
#           constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20
#           decomposition declaration declared <'B'|with 'B' specifiers> is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++20
#           defaulted comparison operators are incompatible with C++ standards before C++20
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20
#           explicit template parameter list for lambdas is incompatible with C++ standards before C++20
#           explicit(bool) is incompatible with C++ standards before C++20
#           explicitly defaulting this <default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> with a type different from the implicit type is incompatible with C++ standards before C++20
#           function try block in constexpr <function|constructor> is incompatible with C++ standards before C++20
#           initialized lambda capture packs are incompatible with C++ standards before C++20
#           inline nested namespace definition is incompatible with C++ standards before C++20
#           member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20
#           member using declaration naming non-class 'A' enumerator is incompatible with C++ standards before C++20
#           non-type template parameter of type A is incompatible with C++ standards before C++20
#           passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20
#           range-based for loop initialization statements are incompatible with C++ standards before C++20
#           uninitialized variable in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++20
#           using declaration naming a scoped enumerator is incompatible with C++ standards before C++20
#           using enum declaration is incompatible with C++ standards before C++20
#           virtual constexpr functions are incompatible with C++ standards before C++20
#   -Wpre-c++23-compat-pedantic
#     -Wpre-c++23-compat
#           #warning is incompatible with C++ standards before C++23
#           'auto' as a functional-style cast is incompatible with C++ standards before C++23
#           'size_t' suffix for literals is incompatible with C++ standards before C++23
#           <an attribute specifier sequence|B> in this position is incompatible with C++ standards before C++23
#           <delimited|named> escape sequences are incompatible with C++ standards before C++23
#           alias declaration in this context is incompatible with C++ standards before C++23
#           consteval if is incompatible with C++ standards before C++23
#           declaring overloaded A as 'static' is incompatible with C++ standards before C++23
#           definition of a <static variable|thread_local variable|variable of non-literal type> in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#           label at end of compound statement is incompatible with C++ standards before C++23
#           overloaded A with <no|a defaulted|more than one> parameter is a C++23 extension
#           static lambdas are incompatible with C++ standards before C++23
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C++ standards before C++23
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++23
#   -Wpre-c++26-compat-pedantic
#     -Wpre-c++26-compat
#            'A' in a raw string literal delimiter is incompatible with standards before C++2c
#           '= delete' with a message is incompatible with C++ standards before C++2c
#           an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#           pack indexing is incompatible with C++ standards before C++2c
#           placeholder variables are incompatible with C++ standards before C++2c
-Wc2x-compat
#   -Wc23-compat
#         'A' is a keyword in C23
#         type of UTF-8 string literal will change from array of char to array of char8_t in C23
-Wc2x-extensions
#   -Wc23-extensions
#         #embed is a <C23|Clang> extension
#         '_BitInt' suffix for literals is a C23 extension
#         '_Static_assert' with no message is a C23 extension
#         'nullptr' is a C23 extension
#         [[]] attributes are a C23 extension
#         binary integer literals are a C23 extension
#         defining a type within '<__builtin_offsetof|offsetof>' is a C23 extension
#         label at end of compound statement is a C23 extension
#         label followed by a declaration is a C23 extension
#         omitting the parameter name in a function definition is a C23 extension
#         passing no argument for the '...' parameter of a variadic macro is a C23 extension
#         use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is a C23 extension
#         use of an empty initializer is a C23 extension
-Wc99-compat
#     'A' is a keyword in C99
#     <using this character in an identifier|starting an identifier with this character> is incompatible with C99
#     integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C89; this literal will <have type 'long long'|be ill-formed> in C99 onwards
#     unicode literals are incompatible with C99
-Wc99-extensions
#     'A' is a C99 extension
#     ISO C99 requires whitespace after the macro name
#     [qualifier in |static ]array size ['[*] ']is a C99 feature
#     commas at the end of enumerator lists are a C99-specific feature
#     compound literals are a C99-specific feature
#     empty macro arguments are a C99 feature
#     flexible array members are a C99 feature
#     hexadecimal floating constants are a C99 feature
#     initializer for aggregate is not a compile-time constant
#     variable declaration in for loop is a C99-specific feature
#   -Wc99-designator
#         array designators are a C99 extension
#         brace elision for designated initializer is a C99 extension
#         designated initializers are a C99 feature
#         mixture of designated and non-designated initializers in the same initializer list is a C99 extension
#         nested designators are a C99 extension
#     -Wc++20-designator
#           designated initializers are a C++20 extension
-Wcalled-once-parameter
#     A parameter marked 'called_once' is called twice
#     A parameter marked 'called_once' is never <used|called> when <taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches>
#     [captured ]A parameter marked 'called_once' is never called
#   -Wcompletion-handler
#         [captured ]completion handler is never called
#         completion handler is called twice
#         completion handler is never <used|called> when <taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches>
-Wcast-align
#     cast from A to B increases required alignment from C to D
-Wcast-function-type
#   -Wcast-function-type-mismatch
#         cast converts to incompatible function type
#   -Wcast-function-type-strict
#         cast converts to incompatible function type
-Wcast-qual
#     cast from A to B drops <const and volatile qualifiers|const qualifier|volatile qualifier>
#     cast from A to B must have all intermediate pointers const qualified to be safe
-Wchar-align # IGNORED switch
-WCL4
#   -Wall
#     -Wmisleading-indentation
#           misleading indentation; statement is not part of the previous '<if|else|for|while>'
#     -Wmost
#       -Warray-parameter
#             argument A of type B with mismatched bound
#       -Wbool-operation
#             bitwise negation of a boolean expression<;| always evaluates to 'true';> did you mean logical negation?
#         -Wbitwise-instead-of-logical
#               use of bitwise 'A' with boolean operands
#       -Wcast-of-sel-type
#             cast of type A to B is deprecated; use sel_getName instead
#       -Wchar-subscripts
#             array section <lower bound|length> is of type 'char'
#             array subscript is of type 'char'
#       -Wcomment
#             '/*' within block comment
#             // comments are not allowed in this language
#             escaped newline between */ characters at block comment end
#             multi-line // comment
#       -Wdelete-non-virtual-dtor
#         -Wdelete-abstract-non-virtual-dtor
#               <delete|destructor> called on B that is abstract but has non-virtual destructor
#         -Wdelete-non-abstract-non-virtual-dtor
#               <delete|destructor> called on non-final B that has virtual functions but non-virtual destructor
#       -Wextern-c-compat
#             [empty ]<struct|union> has size 0 in C, <size 1|non-zero size> in C++
#       -Wfor-loop-analysis
#             variable A is <decremented|incremented> both in the loop header and in the loop body
#             variable<s| B|s B and C|s B, C, and D|s B, C, D, and E> used in loop condition not modified in loop body
#       -Wformat
#             '%n' specifier not supported on this platform
#             '<*|.*>' specified field <width|precision> is missing a matching 'int' argument
#             'A' is not a valid object format flag
#             <field width|precision> used with 'B' conversion specifier, resulting in undefined behavior
#             <values of type|enum values with underlying type> 'A' should not be used as format arguments; add an explicit cast to B instead
#             cannot mix positional and non-positional arguments in format string
#             data argument position 'A' exceeds the number of data arguments (B)
#             field <width|precision> should have type B, but argument has type C
#             flag 'A' is ignored when flag 'B' is present
#             flag 'A' results in undefined behavior with 'B' conversion specifier
#             format specifies type A but the argument has <type|underlying type> B
#             format string contains '\0' within the string body
#             format string is not null-terminated
#             format string missing
#             format string should not be a wide string
#             incomplete format specifier
#             invalid position specified for <field width|field precision>
#             length modifier 'A' results in undefined behavior or no effect with 'B' conversion specifier
#             missing object format flag
#             no closing ']' for '%[' in scanf format string
#             object format flags cannot be used with 'A' conversion specifier
#             position arguments in format strings start counting at 1 (not 0)
#             using '%P' format specifier with an Objective-C pointer results in dumping runtime object structure, not object value
#             using '%P' format specifier without precision
#             using 'A' format specifier annotation outside of os_log()/os_trace()
#             using 'A' format specifier, but argument has boolean value
#             zero field width in scanf format string is unused
#         -Wformat-extra-args
#               data argument not used by format string
#         -Wformat-insufficient-args
#               more '%' conversions than data arguments
#         -Wformat-invalid-specifier
#               invalid conversion specifier 'A'
#         -Wformat-overflow
#               'A' will always overflow; destination buffer has size B, but format string expands to at least C,1,2
#           -Wformat-overflow-non-kprintf
#                 'A' will always overflow; destination buffer has size B, but format string expands to at least C,1,2
#         -Wformat-security
#               format string is not a string literal (potentially insecure)
#         -Wformat-truncation
#               'A' will always be truncated; specified size is B, but format string expands to at least C,1,2
#           -Wformat-truncation-non-kprintf
#                 'A' will always be truncated; specified size is B, but format string expands to at least C,1,2
#         -Wformat-y2k # IGNORED switch
#         -Wformat-zero-length
#               format string is empty
#         -Wnonnull
#               null passed to a callee that requires a non-null argument
#               null returned from <function|method> that requires a non-null return value
#       -Wframe-address
#             calling 'A' with a nonzero argument is unsafe
#       -Wimplicit
#         -Wimplicit-function-declaration
#               call to undeclared function A; ISO C99 and later do not support implicit function declarations
#               call to undeclared library function 'A' with type B; ISO C99 and later do not support implicit function declarations
#               implicit declaration of function A
#               implicitly declaring library function 'A' with type B
#               use of unknown builtin A
#         -Wimplicit-int
#               parameter A was not declared, defaults to 'int'; ISO C99 and later do not support implicit int
#               type specifier missing, defaults to 'int'
#               type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int
#       -Winfinite-recursion
#             all paths through this function will call itself
#       -Wint-in-bool-context
#             converting the enum constant to a boolean
#             converting the result of '<<' to a boolean; did you mean '(A) != 0'?
#       -Wmismatched-tags
#             <struct|interface|class>[ template] C was previously declared as a <struct|interface|class>[ template]; this is valid, but may result in linker errors under the Microsoft C++ ABI
#             C defined as <a struct|an interface|a class>[ template] here but previously declared as <a struct|an interface|a class>[ template]; this is valid, but may result in linker errors under the Microsoft C++ ABI
#       -Wmissing-braces
#             suggest braces around initialization of subobject
#       -Wmove
#         -Wpessimizing-move
#               moving a local object in a return statement prevents copy elision
#               moving a temporary object prevents copy elision
#         -Wredundant-move
#               redundant move in return statement
#         -Wreturn-std-move # IGNORED switch
#         -Wself-move
#               explicitly moving variable of type A to itself[; did you mean to move to member C?]
#       -Wmultichar
#             multi-character character constant
#       -Wobjc-designated-initializers
#             convenience initializer missing a 'self' call to another initializer
#             convenience initializer should not invoke an initializer on 'super'
#             designated initializer invoked a non-designated initializer
#             designated initializer missing a 'super' call to a designated initializer of the super class
#             designated initializer should only invoke a designated initializer on 'super'
#             method override for the designated initializer of the superclass A not found
#       -Wobjc-flexible-array
#             field A can overwrite instance variable B with variable sized type C in superclass D
#             field A with variable sized type B is not visible to subclasses and can conflict with their instance variables
#       -Wobjc-missing-super-calls
#             method possibly missing a [super A] call
#       -Woverloaded-virtual
#             A hides overloaded virtual <function|functions>
#       -Wprivate-extern
#             use of __private_extern__ on a declaration may not produce external symbol private to the linkage unit and is deprecated
#       -Wrange-loop-construct
#             loop variable A binds to a temporary constructed from a different type
#             loop variable A creates a copy from type B
#       -Wreorder
#         -Wreorder-ctor
#               <field|base class> B will be initialized after <field|base> D
#               initializer order does not match the declaration order
#         -Wreorder-init-list
#               ISO C++ requires field designators to be specified in declaration order; field B will be initialized after field A
#       -Wreturn-type
#             non-void coroutine does not return a value
#             non-void coroutine does not return a value in all control paths
#             non-void function does not return a value
#             non-void function does not return a value in all control paths
#             non-void lambda does not return a value
#             non-void lambda does not return a value in all control paths
#         -Wreturn-mismatch
#               <void function|void method|constructor|destructor> A should not return a value
#               non-void <function|method> A should return a value
#         -Wreturn-type-c-linkage
#               A has C-linkage specified, but returns incomplete type B which could be incompatible with C
#               A has C-linkage specified, but returns user-defined type B which is incompatible with C
#       -Wself-assign
#             explicitly assigning value of variable of type A to itself[; did you mean to assign to member C?]
#         -Wself-assign-field
#               assigning <field|instance variable> to itself
#         -Wself-assign-overloaded
#               explicitly assigning value of variable of type A to itself[; did you mean to assign to member C?]
#       -Wself-move
#             explicitly moving variable of type A to itself[; did you mean to move to member C?]
#       -Wsizeof-array-argument
#             sizeof on array function parameter will return size of A instead of B
#       -Wsizeof-array-decay
#             sizeof on pointer operation will return size of A instead of B
#       -Wstring-plus-int
#             adding A to a string does not append to the string
#       -Wtautological-compare
#             <aligning a value|the result of checking whether a value is aligned> to 1 byte is <a no-op|always true>
#             <self-|array >comparison always evaluates to <a constant|true|false|'std::strong_ordering::equal'>
#         -Wtautological-bitwise-compare
#               bitwise comparison always evaluates to <false|true>
#               bitwise or with non-zero value always evaluates to true
#         -Wtautological-constant-compare
#               converting the result of '<<' to a boolean always evaluates to <false|true>
#               converting the result of '?:' with integer constants to a boolean always evaluates to 'true'
#               result of comparison of <constant A|true|false> with <expression of type C|boolean expression> is always E
#           -Wtautological-constant-out-of-range-compare
#                 result of comparison of <constant A|true|false> with <expression of type C|boolean expression> is always E
#         -Wtautological-negation-compare
#               '&&' of a value and its negation always evaluates to false
#               '||' of a value and its negation always evaluates to true
#         -Wtautological-objc-bool-compare
#               result of comparison of constant A with expression of type 'BOOL' is always B, as the only well defined values for 'BOOL' are YES and NO
#         -Wtautological-overlap-compare
#               overlapping comparisons always evaluate to <false|true>
#         -Wtautological-pointer-compare
#               comparison of <address of|function|array> 'B' [not ]equal to a null pointer is always <true|false>
#               comparison of nonnull <function call|parameter> 'B' [not ]equal to a null pointer is '<true|false>' on first encounter
#         -Wtautological-undefined-compare
#               'this' pointer cannot be null in well-defined C++ code; comparison may be assumed to always evaluate to <true|false>
#               reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to always evaluate to <true|false>
#       -Wtrigraphs
#             ignored trigraph would end block comment
#             trigraph converted to 'A' character
#             trigraph ends block comment
#             trigraph ignored
#       -Wuninitialized
#             base class A is uninitialized when used here to access B
#             block pointer variable A is <uninitialized|null> when captured by block
#             field A is uninitialized when used here
#             reference A is not yet bound to a value when used here
#             reference A is not yet bound to a value when used within its own initialization
#             variable A is uninitialized when <used here|captured by block>
#             variable A is uninitialized when used within its own initialization
#         -Wsometimes-uninitialized
#               variable A is <used|captured> uninitialized whenever <'D' condition is <true|false>|'D' loop <is entered|exits because its condition is false>|'D' loop <condition is true|exits because its condition is false>|switch D is taken|its declaration is reached|D is called>
#         -Wstatic-self-init
#               static variable A is suspiciously used within its own initialization
#         -Wuninitialized-const-reference
#               variable A is uninitialized when passed as a const reference argument here
#       -Wunknown-pragmas
#             #pragma execution_character_set expected 'A'
#             #pragma execution_character_set expected 'push' or 'pop'
#             #pragma execution_character_set invalid value 'A', only 'UTF-8' is supported
#             #pragma warning expected 'A'
#             #pragma warning expected 'push', 'pop', 'default', 'disable', 'error', 'once', 'suppress', 1, 2, 3, or 4
#             #pragma warning expected a warning number
#             #pragma warning(push, level) requires a level between 0 and 4
#             angle-bracketed include <A> cannot be aliased to double-quoted include "B"
#             double-quoted include "A" cannot be aliased to angle-bracketed include <B>
#             expected 'ON' or 'OFF' or 'DEFAULT' in pragma
#             expected end of directive in pragma
#             pragma STDC FENV_ROUND is not supported
#             pragma diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'
#             pragma diagnostic expected option name (e.g. "-Wundef")
#             pragma diagnostic pop could not pop, no matching push
#             pragma include_alias expected 'A'
#             pragma include_alias expected include filename
#             unexpected token in pragma diagnostic
#             unknown pragma ignored
#             unknown pragma in STDC namespace
#       -Wunused
#         -Wunused-argument # IGNORED switch
#         -Wunused-but-set-variable
#               variable A set but not used
#         -Wunused-function
#               unused function A
#           -Wunneeded-internal-declaration
#                 'static' function A declared in header file should be declared 'static inline'
#                 <function|variable> B is not needed and will not be emitted
#         -Wunused-label
#               unused label A
#         -Wunused-lambda-capture
#               lambda capture A is not <used|required to be captured for this use>
#         -Wunused-local-typedef
#               unused <typedef|type alias> B
#         -Wunused-private-field
#               private field A is not used
#         -Wunused-property-ivar
#               ivar A which backs the property is not referenced in this property's accessor
#         -Wunused-value
#               container access result unused - container access should not be used for side effects
#               expression result unused
#               expression result unused; should this cast be to 'void'?
#               ignoring return value of function declared with A attribute
#               ignoring temporary created by a constructor declared with A attribute
#               ignoring temporary created by a constructor declared with A attribute: B
#               left operand of comma operator has no effect
#           -Wunevaluated-expression
#                 expression with side effects has no effect in an unevaluated context
#             -Wpotentially-evaluated-expression
#                   expression with side effects will be evaluated despite being used as an operand to 'typeid'
#           -Wunused-comparison
#                 <equality|inequality|relational|three-way> comparison result unused
#           -Wunused-result
#                 ignoring return value of function declared with A attribute
#                 ignoring return value of function declared with A attribute: B
#         -Wunused-variable
#               unused variable A
#           -Wunused-const-variable
#                 unused variable A
#       -Wuser-defined-warnings
#             The text of this diagnostic is not controlled by Clang
#       -Wvolatile-register-var # IGNORED switch
#     -Wpacked-non-pod
#           not packing field A as it is non-POD for the purposes of layout
#     -Wparentheses
#           A has lower precedence than B; B will be evaluated first
#           comparisons like 'X<=Y<=Z' don't have their mathematical meaning
#           operator '?:' has lower precedence than 'A'; 'A' will be evaluated first
#           using the result of an assignment as a condition without parentheses
#       -Wbitwise-conditional-parentheses
#             operator '?:' has lower precedence than 'A'; 'A' will be evaluated first
#       -Wbitwise-op-parentheses
#             'A' within 'B'
#       -Wdangling-else
#             add explicit braces to avoid dangling else
#       -Wlogical-not-parentheses
#             logical not is only applied to the left hand side of this <comparison|bitwise operator>
#       -Wlogical-op-parentheses
#             '&&' within '||'
#       -Woverloaded-shift-op-parentheses
#             overloaded operator <>>|<<> has higher precedence than comparison operator
#       -Wparentheses-equality
#             equality comparison with extraneous parentheses
#       -Wshift-op-parentheses
#             operator 'A' has lower precedence than 'B'; 'B' will be evaluated first
#     -Wswitch
#           <enumeration value B not handled in switch|enumeration values B and C not handled in switch|enumeration values B, C, and D not handled in switch|A enumeration values not handled in switch>
#           case value not in enumerated type A
#           overflow converting case value to switch condition type (A to B)
#     -Wswitch-bool
#           switch condition has boolean value
#     -Wvla-cxx-extension
#           variable length arrays in C++ are a Clang extension
#       -Wvla-extension-static-assert
#             variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?
#   -Wextra
#     -Wcast-function-type-mismatch
#           cast converts to incompatible function type
#     -Wdeprecated-copy
#           definition of implicit copy <constructor|assignment operator> for A is deprecated because it has a user-declared copy <assignment operator|constructor>
#       -Wdeprecated-copy-with-user-provided-copy
#             definition of implicit copy <constructor|assignment operator> for A is deprecated because it has a user-provided copy <assignment operator|constructor>
#     -Wempty-init-stmt
#           empty initialization statement of '<if|switch|range-based for>' has no effect
#     -Wfuse-ld-path
#           '-fuse-ld=' taking a path is deprecated; use '--ld-path=' instead
#     -Wignored-qualifiers
#           'A' qualifier on function type B has no effect
#           'A' qualifier on omitted return type B has no effect
#           'A' type qualifier(s) on return type <has|have> no effect
#           ARC <unused|__unsafe_unretained|__strong|__weak|__autoreleasing> lifetime qualifier on return type is ignored
#       -Wignored-reference-qualifiers
#             'A' qualifier on reference type B has no effect
#     -Winitializer-overrides
#           initializer [partially ]overrides prior initialization of this subobject
#     -Wmissing-field-initializers
#           missing field A initializer
#       -Wmissing-designated-field-initializers
#             missing field A initializer
#     -Wmissing-method-return-type
#           method has no return type specified; defaults to 'id'
#     -Wnull-pointer-arithmetic
#           performing pointer arithmetic on a null pointer has undefined behavior[ if the offset is nonzero]
#       -Wgnu-null-pointer-arithmetic
#             arithmetic on a null pointer treated as a cast from integer to pointer is a GNU extension
#     -Wnull-pointer-subtraction
#           performing pointer subtraction with a null pointer <has|may have> undefined behavior
#     -Wsemicolon-before-method-body
#           semicolon before method body is ignored
#     -Wsign-compare
#           comparison of integers of different signs: A and B
#     -Wstring-concatenation
#           suspicious concatenation of string literals in an array initialization; did you mean to separate the elements with a comma?
#     -Wunused-but-set-parameter
#           parameter A set but not used
#     -Wunused-parameter
#           unused parameter A
-Wclass-varargs
#     passing object of class type A through variadic <function|block|method|constructor>[; did you mean to call 'D'?]
#   -Wnon-pod-varargs
#         cannot pass <non-POD|non-trivial> object of type B to variadic <function|block|method|constructor>; expected type from format string was D
#         cannot pass object of <non-POD|non-trivial> type B through variadic <function|block|method|constructor>; call will abort at runtime
#         second argument to 'va_arg' is of ARC ownership-qualified type A
#         second argument to 'va_arg' is of non-POD type A
-Wcomma
#     possible misuse of comma operator here
-Wcomments
#   -Wcomment
#         '/*' within block comment
#         // comments are not allowed in this language
#         escaped newline between */ characters at block comment end
#         multi-line // comment
-Wcompound-token-split
#   -Wcompound-token-split-by-macro
#         [B and ]C tokens <introducing statement expression|terminating statement expression|introducing attribute|terminating attribute|forming pointer to member type>,1,2,3 appear in different macro expansion contexts
#   -Wcompound-token-split-by-space
#         [B and ]C tokens <introducing statement expression|terminating statement expression|introducing attribute|terminating attribute|forming pointer to member type>,1,2,3 are separated by whitespace
-Wconditional-uninitialized
#     variable A may be uninitialized when <used here|captured by block>
-Wconsumed
#     argument not in expected state; expected 'A', observed 'B'
#     consumed analysis attribute is attached to member of class A which isn't marked as consumable
#     invalid invocation of method 'A' on a temporary object while it is in the 'B' state
#     invalid invocation of method 'A' on object 'B' while it is in the 'C' state
#     parameter 'A' not in expected state when the function returns: expected 'B', observed 'C'
#     return state set for an unconsumable type 'A'
#     return value not in expected state; expected 'A', observed 'B'
#     state of variable 'A' must match at the entry and exit of loop
-Wcovered-switch-default
#     default label in switch which covers all enumeration values
-Wcstring-format-directive
#     using A directive in <NSString|CFString> which is being passed as a formatting argument to the formatting <method|CFfunction>
-Wctad-maybe-unsupported
#     A may not intend to support class template argument deduction
-Wctor-dtor-privacy # IGNORED switch
-Wcuda-compat
#     A attribute parameter B is negative and will be ignored
#     argument to '#pragma unroll' should not be in parentheses in CUDA C/C++
#     ignored 'inline' attribute on kernel function A
#     kernel function A is a member function; this may not be accepted by nvcc
#     nvcc does not allow '__A__' to appear after the parameter list in lambdas
-Wdangling
#     <temporary <whose address is used as value of|[implicitly ]bound to> <[reference ]member of local variable|local <variable|reference>>|array backing <initializer list subobject of local variable|local initializer list>> [D ]will be destroyed at the end of the full-expression
#     lifetime extension of <temporary|backing array of initializer list> created by aggregate initialization using a default member initializer is not yet supported; lifetime of <temporary|backing array> will end at the end of the full-expression
#   -Wdangling-assignment
#         object backing the pointer A will be destroyed at the end of the full-expression
#   -Wdangling-assignment-gsl
#         object backing the pointer A will be destroyed at the end of the full-expression
#   -Wdangling-field
#         <reference|backing array for 'std::initializer_list'> [subobject of ]member A <binds to|is> a temporary object whose lifetime is shorter than the lifetime of the constructed object
#         binding reference member A to stack allocated <variable|parameter> B
#         initializing pointer member A with the stack address of <variable|parameter> B
#         temporary bound to reference member of allocated object will be destroyed at the end of the full-expression
#   -Wdangling-gsl
#         initializing pointer member A to point to a temporary object whose lifetime is shorter than the lifetime of the constructed object
#         object backing the pointer will be destroyed at the end of the full-expression
#   -Wdangling-initializer-list
#         array backing <initializer list subobject of the allocated object|the allocated initializer list> will be destroyed at the end of the full-expression
#   -Wreturn-stack-address
#         <address of|reference to> stack memory associated with <local variable|parameter|compound literal> B returned
#         returning <address of|reference to> local temporary object
#         returning address of label, which is local
-Wdate-time
#     expansion of date or time macro is not reproducible
-Wdeclaration-after-statement
#     mixing declarations and code is a C99 extension
#     mixing declarations and code is incompatible with standards before C99
-Wdeprecated
#     'depend' clause for 'ordered' is deprecated; use 'doacross' instead
#     -O4 is equivalent to -O3
#     A does not support the option 'B'
#     access declarations are deprecated; use using declarations instead
#     argument 'A' is deprecated, B
#     argument 'A' is deprecated[, use 'C' instead]
#     minus(-) operator for reductions is deprecated; use + or user defined reduction instead
#     treating 'A' input as 'B' when in C++ mode, this behavior is deprecated
#     use of 'long' with '__vector' is deprecated
#   -Wdeprecated-anon-enum-enum-conversion
#         <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#   -Wdeprecated-array-compare
#         comparison between two arrays is deprecated; to compare array addresses, use unary '+' to decay operands to pointers
#   -Wdeprecated-attributes
#         applying attribute A to a declaration is deprecated; apply it to the type instead
#         specifying vector types with the 'mode' attribute is deprecated; use the 'vector_size' attribute instead
#         the '[[_Noreturn]]' attribute spelling is deprecated in C23; use '[[noreturn]]' instead
#   -Wdeprecated-builtins
#         builtin A is deprecated; use B instead
#   -Wdeprecated-comma-subscript
#         top-level comma expression in array subscript is deprecated in C++20 and unsupported in C++23
#   -Wdeprecated-copy
#         definition of implicit copy <constructor|assignment operator> for A is deprecated because it has a user-declared copy <assignment operator|constructor>
#     -Wdeprecated-copy-with-user-provided-copy
#           definition of implicit copy <constructor|assignment operator> for A is deprecated because it has a user-provided copy <assignment operator|constructor>
#   -Wdeprecated-copy-with-dtor
#         definition of implicit copy <constructor|assignment operator> for A is deprecated because it has a user-declared destructor
#     -Wdeprecated-copy-with-user-provided-dtor
#           definition of implicit copy <constructor|assignment operator> for A is deprecated because it has a user-provided destructor
#   -Wdeprecated-declarations
#         A is deprecated
#         A is deprecated: B
#         A may be deprecated because the receiver type is unknown
#         property access is using A method which is deprecated
#         specifying 'uuid' as an ATL attribute is deprecated; use __declspec instead
#         use of C-style parameters in Objective-C method declarations is deprecated
#   -Wdeprecated-dynamic-exception-spec
#         dynamic exception specifications are deprecated
#   -Wdeprecated-enum-compare
#         <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#   -Wdeprecated-enum-compare-conditional
#         <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#   -Wdeprecated-enum-enum-conversion
#         <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#   -Wdeprecated-enum-float-conversion
#         <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> <floating-point|enumeration> type C <with|from|and> <enumeration|floating-point> type D is deprecated
#   -Wdeprecated-increment-bool
#         incrementing expression of type bool is deprecated and incompatible with C++17
#   -Wdeprecated-literal-operator
#         identifier A preceded by whitespace in a literal operator declaration is deprecated
#   -Wdeprecated-no-relaxed-template-template-args
#         argument '-fno-relaxed-template-template-args' is deprecated
#   -Wdeprecated-ofast
#         argument '-Ofast' is deprecated; use '-O3 -ffast-math' for the same behavior, or '-O3' to enable only conforming optimizations
#   -Wdeprecated-pragma
#         macro A has been marked as deprecated[: C]
#   -Wdeprecated-redundant-constexpr-static-def
#         out-of-line definition of constexpr static data member is redundant in C++17 and is deprecated
#   -Wdeprecated-register
#         'register' storage class specifier is deprecated and incompatible with C++17
#   -Wdeprecated-this-capture
#         implicit capture of 'this' with a capture default of '=' is deprecated
#   -Wdeprecated-type
#         '_ExtInt' is deprecated; use '_BitInt' instead
#   -Wdeprecated-volatile
#         <decrement|increment> of object of volatile-qualified type B is deprecated
#         use of result of assignment to object of volatile-qualified type A is deprecated
#         volatile qualifier in structured binding declaration is deprecated
#         volatile-qualified parameter type A is deprecated
#         volatile-qualified return type A is deprecated
#   -Wdeprecated-writable-strings
#     -Wc++11-compat-deprecated-writable-strings
#           conversion from string literal to A is deprecated
-Wdeprecated-copy-dtor
#   -Wdeprecated-copy-with-dtor
#         definition of implicit copy <constructor|assignment operator> for A is deprecated because it has a user-declared destructor
#     -Wdeprecated-copy-with-user-provided-dtor
#           definition of implicit copy <constructor|assignment operator> for A is deprecated because it has a user-provided destructor
-Wdeprecated-implementations
#     implementing deprecated <method|class|category>
#     implementing unavailable method
-Wdirect-ivar-access
#     instance variable A is being directly accessed
-Wdisabled-macro-expansion
#     disabled expansion of recursive macro
-Wdisabled-optimization # IGNORED switch
-Wdiscard-qual # IGNORED switch
-Wdocumentation
#     '<\|@><classdesign|coclass|dependency|helper|helperclass|helps|instancesize|ownership|performance|security|superclass>' command should not be used in a comment attached to a non-container declaration
#     '<\|@><class|interface|protocol|struct|union>' command should not be used in a comment attached to a non-<class|interface|protocol|struct|union> declaration
#     '<\|@><function|functiongroup|method|methodgroup|callback>' command should be used in a comment attached to <a function|an Objective-C method|a pointer to function> declaration
#     '<\|@>B' command does not terminate a verbatim text block
#     '<\|@>B' command has <no|C> word argument(s), expected D
#     '<\|@>B' command used in a comment that is attached to a <function returning void|constructor|destructor|method returning void>
#     '<\|@>B' command used in a comment that is not attached to a function or method declaration
#     '<\|@>param' command used in a comment that is not attached to a function declaration
#     '<\|@>tparam' command used in a comment that is not attached to a template declaration
#     HTML start tag prematurely ended, expected attribute name or '>'
#     duplicated command '<\|@>B'
#     empty paragraph passed to '<\|@>B' command
#     expected quoted string after equals sign
#     line splicing in Doxygen comments are not supported
#     not a Doxygen trailing comment
#     parameter 'A' is already documented
#     parameter 'A' not found in the function declaration
#     template parameter 'A' is already documented
#     template parameter 'A' not found in the template declaration
#     unrecognized parameter passing direction, valid directions are '[in]', '[out]' and '[in,out]'
#   -Wdocumentation-deprecated-sync
#         declaration is marked with '<\|@>deprecated' command but does not have a deprecation attribute
#   -Wdocumentation-html
#         HTML end tag 'A' is forbidden
#         HTML end tag does not match any start tag
#         HTML start tag 'A' closed by 'B'
#         HTML tag 'A' requires an end tag
-Wdocumentation-pedantic
#     whitespace is not allowed in parameter passing direction
#   -Wdocumentation-unknown-command
#         unknown command tag name
#         unknown command tag name 'A'; did you mean 'B'?
-Wdouble-promotion
#     implicit conversion increases floating-point precision: A to B
-Wdtor-name
#     ISO C++ considers this destructor name lookup to be ambiguous
#     ISO C++ requires the name after '::~' to be found in the same scope as the name before '::~'
#     qualified destructor name only found in lexical scope; omit the qualifier to find this type name by unqualified lookup
-Wduplicate-decl-specifier
#     duplicate 'A' declaration specifier
#     multiple identical address spaces specified for type
-Wduplicate-enum
#     element A has been implicitly assigned B which another element has been assigned
-Wduplicate-method-arg
#     redeclaration of method parameter A
-Wduplicate-method-match
#     multiple declarations of method A found and ignored
-Wdynamic-exception-spec
#     ISO C++17 does not allow dynamic exception specifications
#   -Wdeprecated-dynamic-exception-spec
#         dynamic exception specifications are deprecated
-Weffc++
#   -Wnon-virtual-dtor
#         A has virtual functions but non-virtual destructor
-Wexit-time-destructors
#     declaration requires an exit-time destructor
-Wexpansion-to-defined
#     macro expansion producing 'defined' has undefined behavior
-Wexplicit-ownership-type
#     method parameter of type A with no explicit ownership
-Wexport-unnamed # IGNORED switch
-Wextra-semi
#     extra ';' <outside of a function|inside a B|inside instance variable list|after member function definition>
#     extra ';' after member function definition
#   -Wc++11-extra-semi
#         extra ';' outside of a function is a C++11 extension
#   -Wc++98-compat-extra-semi
#         extra ';' outside of a function is incompatible with C++98
-Wextra-semi-stmt
#     empty expression statement has no effect; remove unnecessary ';' to silence this warning
#   -Wempty-init-stmt
#         empty initialization statement of '<if|switch|range-based for>' has no effect
-Wfloat-equal
#     comparing floating point with == or != is unsafe
-Wformat-non-iso
#     'A' <length modifier|conversion specifier> is not supported by ISO C
#     positional arguments are not supported by ISO C
#     using length modifier 'A' with conversion specifier 'B' is not supported by ISO C
-Wformat-pedantic
#     <values of type|enum values with underlying type> 'A' should not be used as format arguments; add an explicit cast to B instead
#     format specifies type A but the argument has <type|underlying type> B
-Wformat-signedness
#     format specifies type A but the argument has <type|underlying type> B
-Wformat-type-confusion
#     format specifies type A but the argument has <type|underlying type> B
-Wformat=2
#   -Wformat-nonliteral
#         format string is not a string literal
#   -Wformat-security
#         format string is not a string literal (potentially insecure)
#   -Wformat-y2k # IGNORED switch
-Wfour-char-constants
#     multi-character character constant
-Wfuture-compat # IGNORED switch
-Wgcc-compat
#     'A' is bound to current loop, GCC binds it to the enclosing loop
#     'break' is bound to loop, GCC binds it to switch
#     'diagnose_if' is a clang extension
#     'enable_if' is a clang extension
#     GCC does not allow A attribute in this position on a function definition
#     GCC does not allow an attribute in this position on a function declaration
#     GCC does not allow the 'cleanup' attribute argument to be anything other than a simple identifier
#     GCC does not allow the A attribute to be written on a type
#     GCC does not allow variable declarations in for loop initializers before C99
#     GCC requires a function with the A attribute to be variadic
#     __final is a GNU extension, consider using C++11 final
-Wglobal-constructors
#     declaration requires a global constructor
#     declaration requires a global destructor
-Wgnu
#   -Wgnu-alignof-expression
#         A applied to an expression is a GNU extension
#   -Wgnu-anonymous-struct
#         anonymous structs are a GNU extension
#   -Wgnu-auto-type
#         '__auto_type' is a GNU extension
#   -Wgnu-binary-literal # IGNORED switch
#   -Wgnu-case-range
#         use of GNU case range extension
#   -Wgnu-complex-integer
#         complex integer types are a GNU extension
#   -Wgnu-compound-literal-initializer
#         initialization of an array from a compound literal is a GNU extension
#   -Wgnu-conditional-omitted-operand
#         use of GNU ?: conditional expression extension, omitting middle operand
#   -Wgnu-designator
#         use of GNU 'missing =' extension in designator
#         use of GNU array range extension
#         use of GNU old-style field designator extension
#   -Wgnu-empty-struct
#         <struct|union> without named members is a GNU extension
#         empty <struct|union> is a GNU extension
#         flexible array member A in otherwise empty <struct|interface|union|class|enum> is a GNU extension
#   -Wgnu-flexible-array-initializer
#         flexible array initialization is a GNU extension
#   -Wgnu-flexible-array-union-member
#         flexible array member A in a union is a GNU extension
#   -Wgnu-folding-constant
#         expression is not an <integer|integral> constant expression; folding it to a constant is a GNU extension
#         in-class initializer for static data member is not a constant expression; folding it to a constant is a GNU extension
#         variable length array folded to constant array as an extension
#   -Wgnu-imaginary-constant
#         imaginary constants are a GNU extension
#   -Wgnu-include-next
#         #include_next is a language extension
#   -Wgnu-label-as-value
#         use of GNU address-of-label extension
#         use of GNU indirect-goto extension
#   -Wgnu-line-marker
#         this style of line directive is a GNU extension
#   -Wgnu-null-pointer-arithmetic
#         arithmetic on a null pointer treated as a cast from integer to pointer is a GNU extension
#   -Wgnu-offsetof-extensions # IGNORED switch
#   -Wgnu-pointer-arith
#         arithmetic on[ a] pointer[s] to void is a GNU extension
#         arithmetic on[ a] pointer[s] to[ the] function type[s] B[ and D] is a GNU extension
#         subscript of a pointer to void is a GNU extension
#   -Wgnu-redeclared-enum
#         redeclaration of already-defined enum A is a GNU extension
#   -Wgnu-statement-expression
#         use of GNU statement expression extension
#     -Wgnu-statement-expression-from-macro-expansion
#           use of GNU statement expression extension from macro expansion
#   -Wgnu-static-float-init
#         in-class initializer for static data member of type A is a GNU extension
#   -Wgnu-string-literal-operator-template
#         string literal operator templates are a GNU extension
#   -Wgnu-union-cast
#         cast to union type is a GNU extension
#   -Wgnu-variable-sized-type-not-at-end
#         field A with variable sized type B not at the end of a struct or class is a GNU extension
#   -Wgnu-zero-line-directive
#         #line directive with zero argument is a GNU extension
#   -Wgnu-zero-variadic-macro-arguments
#         token pasting of ',' and __VA_ARGS__ is a GNU extension
#   -Wredeclared-class-member
#         class member cannot be redeclared
#   -Wvla-extension
#         variable length arrays are a C99 feature
#     -Wvla-cxx-extension
#           variable length arrays in C++ are a Clang extension
#       -Wvla-extension-static-assert
#             variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?
#   -Wzero-length-array
#         zero size arrays are an extension
-Wgnu-empty-initializer # IGNORED switch
-Wheader-hygiene
#     using namespace directive in global context in header
-Widiomatic-parentheses
#     using the result of an assignment as a condition without parentheses
-Wimplicit-fallthrough
#     unannotated fall-through between switch labels
#   -Wimplicit-fallthrough-per-function
#         unannotated fall-through between switch labels in partly-annotated function
-Wimplicit-retain-self
#     block implicitly retains 'self'; explicitly mention 'self' to indicate this is intended behavior
-Wimport # IGNORED switch
-Wincompatible-function-pointer-types-strict
#     incompatible function pointer types <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
-Wincomplete-module
#   -Wincomplete-umbrella
#         missing submodule 'A'
#         umbrella directory 'A' not found
#         umbrella header for module 'A' does not include header 'B'
#   -Wnon-modular-include-in-module
#         include of non-modular header inside module 'A': 'B'
#     -Wnon-modular-include-in-framework-module
#           include of non-modular header inside framework module 'A': 'B'
-Winconsistent-missing-destructor-override
#     A overrides a destructor but is not marked 'override'
-Winit-self # IGNORED switch
-Winline # IGNORED switch
-Winvalid-or-nonexistent-directory
#     unable to find A directory, expected to be in 'B' found via C
-Winvalid-pch # IGNORED switch
-Wliblto # IGNORED switch
-Wlocal-type-template-args
#     template argument uses local type A
#   -Wc++98-compat-local-type-template-args
#         local type A as template argument is incompatible with C++98
-Wloop-analysis
#   -Wfor-loop-analysis
#         variable A is <decremented|incremented> both in the loop header and in the loop body
#         variable<s| B|s B and C|s B, C, and D|s B, C, D, and E> used in loop condition not modified in loop body
#   -Wrange-loop-analysis
#     -Wrange-loop-bind-reference
#           loop variable A binds to a temporary value produced by a range of type B
#     -Wrange-loop-construct
#           loop variable A binds to a temporary constructed from a different type
#           loop variable A creates a copy from type B
-Wmain
#     'main' is not allowed to be declared _Noreturn
#     'main' is not allowed to be declared variadic
#     'main' should not be declared static
#     bool literal returned from 'main'
#     only one parameter on 'main' declaration
#     referring to 'main' within an expression is a Clang extension
#     variable named 'main' with external linkage has undefined behavior
-Wmax-tokens
#     the number of preprocessor source tokens (A) exceeds this token limit (B)
#     the total number of preprocessor source tokens (A) exceeds the token limit (B)
-Wmethod-signatures
#     conflicting parameter types in implementation of A: B vs C
#     conflicting return type in implementation of A: B vs C
-Wmicrosoft
#   -Winconsistent-dllimport
#         A redeclared without 'dllimport' attribute: 'dllexport' attribute added
#         A redeclared without B attribute: previous B ignored
#   -Wmicrosoft-abstract
#         'abstract' keyword is a Microsoft extension
#   -Wmicrosoft-anon-tag
#         anonymous <structs|unions> are a Microsoft extension
#         types declared in an anonymous <struct|union> are a Microsoft extension
#   -Wmicrosoft-cast
#         implicit conversion between pointer-to-function and pointer-to-object is a Microsoft extension
#         static_cast between pointer-to-function and pointer-to-object is a Microsoft extension
#   -Wmicrosoft-charize
#         charizing operator #@ is a Microsoft extension
#   -Wmicrosoft-comment-paste
#         pasting two '/' tokens into a '//' comment is a Microsoft extension
#   -Wmicrosoft-const-init
#         default initialization of an object of const type A[ without a user-provided default constructor] is a Microsoft extension
#   -Wmicrosoft-cpp-macro
#         C++ operator A (aka B) used as a macro name
#   -Wmicrosoft-default-arg-redefinition
#         redefinition of default argument
#   -Wmicrosoft-drectve-section
#         #pragma A(".drectve") has undefined behavior, use #pragma comment(linker, ...) instead
#   -Wmicrosoft-end-of-file
#         treating Ctrl-Z as end-of-file is a Microsoft extension
#   -Wmicrosoft-enum-forward-reference
#         forward references to 'enum' types are a Microsoft extension
#   -Wmicrosoft-enum-value
#         enumerator value is not representable in the underlying type A
#   -Wmicrosoft-exception-spec
#         [pointer to |reference to ]incomplete type B is not allowed in exception specification
#         exception specification in declaration does not match previous declaration
#         exception specification in explicit instantiation does not match instantiated one
#         exception specification of '...' is a Microsoft extension
#         exception specification of overriding function is more lax than base version
#   -Wmicrosoft-explicit-constructor-call
#         explicit constructor calls are a Microsoft extension
#   -Wmicrosoft-extra-qualification
#         extra qualification on member A
#   -Wmicrosoft-fixed-enum
#         enumeration types with a fixed underlying type are a Microsoft extension
#   -Wmicrosoft-flexible-array
#         flexible array member A in a union is a Microsoft extension
#         flexible array member A in otherwise empty <struct|interface|union|class|enum> is a Microsoft extension
#   -Wmicrosoft-goto
#         jump from this goto statement to its label is a Microsoft extension
#   -Wmicrosoft-include
#         #include resolved using non-portable Microsoft search rules as: A
#   -Wmicrosoft-init-from-predefined
#         initializing an array from a 'A' predefined identifier is a Microsoft extension
#   -Wmicrosoft-mutable-reference
#         'mutable' on a reference type is a Microsoft extension
#   -Wmicrosoft-pure-definition
#         function definition with pure-specifier is a Microsoft extension
#   -Wmicrosoft-redeclare-static
#         redeclaring non-static A as static is a Microsoft extension
#   -Wmicrosoft-sealed
#         'sealed' keyword is a Microsoft extension
#   -Wmicrosoft-static-assert
#         use of 'static_assert' without inclusion of <assert.h> is a Microsoft extension
#   -Wmicrosoft-string-literal-from-predefined
#         expansion of predefined identifier 'A' to a string literal is a Microsoft extension
#   -Wmicrosoft-template
#         'static' can only be specified inside the class definition
#         <class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration> specialization of B not in <a namespace enclosing C|class C or an enclosing namespace> is a Microsoft extension
#         duplicate explicit instantiation of A ignored as a Microsoft extension
#         non-type template argument containing a dereference operation is a Microsoft extension
#         template argument for template type parameter must be a type; omitted 'typename' is a Microsoft extension
#         unqualified base initializer of class templates is a Microsoft extension
#         use of member A before its declaration is a Microsoft extension
#         use of member A found via unqualified lookup into dependent bases of class templates is a Microsoft extension
#         use of undeclared identifier A; unqualified lookup into dependent bases of class template B is a Microsoft extension
#         using the undeclared type A as a default template argument is a Microsoft extension
#     -Wmicrosoft-template-shadow
#           declaration of A shadows template parameter
#   -Wmicrosoft-union-member-reference
#         union member A has reference type B, which is a Microsoft extension
#   -Wmicrosoft-unqualified-friend
#         unqualified friend declaration referring to type outside of the nearest enclosing namespace is a Microsoft extension; add a nested name specifier
#   -Wmicrosoft-using-decl
#         using declaration referring to inaccessible member 'A' (which refers to accessible member 'B') is a Microsoft compatibility extension
#   -Wmicrosoft-void-pseudo-dtor
#         pseudo-destructors on type void are a Microsoft extension
-Wmissing-format-attribute # IGNORED switch
-Wmissing-include-dirs
#     no such include directory: 'A'
-Wmissing-noreturn
#     <function|method> B could be declared with attribute 'noreturn'
#     block could be declared with attribute 'noreturn'
-Wmissing-prototypes
#     no previous prototype for function A
-Wmissing-variable-declarations
#     no previous extern declaration for non-static variable A
-Rmodule-build
#     building module 'A' as 'B'
#     could not acquire lock file for module 'A': B
#     finished building module 'A'
#     timed out waiting to acquire lock file for module 'A'
-Rmodule-import
#     importing module 'A'[ into 'D'] from 'B'
-Rmodule-include-translation
#     treating #<include|import|include_next|__include_macros> as an import of module 'B'
-Rmodule-lock
#     locking 'A' to build module 'B'
-Wnarrowing
#   -Wc++11-narrowing
#         <case value|enumerator value|non-type template argument|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#         constant expression evaluates to A which cannot be narrowed to type B
#         constant expression evaluates to A which cannot be narrowed to type B in C++11
#         non-constant-expression cannot be narrowed from type A to B in initializer list
#         non-constant-expression cannot be narrowed from type A to B in initializer list in C++11
#         type A cannot be narrowed to B in initializer list
#         type A cannot be narrowed to B in initializer list in C++11
#     -Wc++11-narrowing-const-reference
#           constant expression evaluates to A which cannot be narrowed to type B
#           non-constant-expression cannot be narrowed from type A to B in initializer list
#           type A cannot be narrowed to B in initializer list
-Wnested-externs # IGNORED switch
-Wnewline-eof
#     no newline at end of file
-Wnon-gcc
#   -Wconversion
#         implicit conversion discards imaginary component: A to B
#         implicit conversion truncates vector: A to B
#         implicit conversion turns vector to scalar: A to B
#         non-type template argument value 'A' truncated to 'B' for template parameter of type C
#         non-type template argument with value 'A' converted to 'B' for unsigned template parameter of type C
#         passing non-generic address space pointer to A may cause dynamic conversion affecting performance
#     -Wbitfield-enum-conversion
#           assigning value of signed enum type B to unsigned bit-field A; negative enumerators of enum B will be converted to positive values
#           bit-field A is not wide enough to store all enumerators of B
#           signed bit-field A needs an extra bit to represent the largest positive enumerators of B
#     -Wbool-conversion
#           initialization of pointer of type A to null from a constant boolean expression
#       -Wpointer-bool-conversion
#             address of <'B'|function 'B'|array 'B'|lambda function pointer conversion operator> will always evaluate to 'true'
#             nonnull <function call|parameter> 'B' will evaluate to 'true' on first encounter
#       -Wundefined-bool-conversion
#             'this' pointer cannot be null in well-defined C++ code; pointer may be assumed to always convert to true
#             reference cannot be bound to dereferenced null pointer in well-defined C++ code; pointer may be assumed to always convert to true
#     -Wconstant-conversion
#           implicit conversion from C to D changes value from A to B
#       -Wbitfield-constant-conversion
#             implicit truncation from C to bit-field changes value from A to B
#         -Wsingle-bit-bitfield-constant-conversion
#               implicit truncation from C to a one-bit wide bit-field changes value from A to B
#       -Wobjc-bool-constant-conversion
#             implicit conversion from constant value A to 'BOOL'; the only well defined values for 'BOOL' are YES and NO
#     -Wenum-conversion
#           implicit conversion from enumeration type A to different enumeration type B
#       -Wenum-compare-conditional
#             <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types
#         -Wdeprecated-enum-compare-conditional
#               <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#       -Wenum-enum-conversion
#             <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types
#         -Wdeprecated-enum-enum-conversion
#               <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> different enumeration types is deprecated
#       -Wenum-float-conversion
#             <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> <floating-point|enumeration> type C <with|from|and> <enumeration|floating-point> type D
#         -Wdeprecated-enum-float-conversion
#               <arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of> <floating-point|enumeration> type C <with|from|and> <enumeration|floating-point> type D is deprecated
#     -Wfloat-conversion
#           implicit conversion turns floating-point number into integer: A to B
#       -Wfloat-overflow-conversion
#             implicit conversion from A to B changes value from C to D
#             implicit conversion of out of range value from A to B is undefined
#       -Wfloat-zero-conversion
#             implicit conversion from A to B changes non-zero value from C to D
#     -Wimplicit-float-conversion
#           implicit conversion loses floating-point precision: A to B
#           implicit conversion when assigning computation result loses floating-point precision: A to B
#       -Wimplicit-int-float-conversion
#             implicit conversion from A to B may lose precision
#         -Wimplicit-const-int-float-conversion
#               implicit conversion from C to D changes value from A to B
#       -Wobjc-signed-char-bool-implicit-float-conversion
#             implicit conversion from floating-point type A to 'BOOL'
#     -Wimplicit-int-conversion
#           higher order bits are zeroes after implicit conversion
#           implicit conversion loses integer precision: A to B
#       -Wobjc-signed-char-bool-implicit-int-conversion
#             implicit conversion from integral type A to 'BOOL'
#       -Wshorten-64-to-32
#             implicit conversion loses integer precision: A to B
#     -Wint-conversion
#           incompatible integer to pointer conversion <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#           incompatible pointer to integer conversion <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#     -Wliteral-conversion
#           implicit conversion from A to B changes value from C to D
#           implicit conversion of out of range value from A to B is undefined
#     -Wnon-literal-null-conversion
#           expression which evaluates to zero treated as a null pointer constant of type A
#     -Wnull-conversion
#           implicit conversion of <NULL|nullptr> constant to B
#     -Wobjc-literal-conversion
#           implicit boolean conversion of Objective-C object literal always evaluates to true
#           object of type A is not compatible with <array element type|dictionary key type|dictionary value type> C
#     -Wsign-conversion
#           implicit conversion changes signedness: A to B
#           operand of ? changes signedness: A to B
#           the resulting value is always non-negative after implicit conversion
#     -Wstring-conversion
#           implicit conversion turns string literal into bool: A to B
#   -Wliteral-range
#         floating-point comparison is always <true|false>; constant cannot be represented exactly in type B
#         magnitude of floating-point constant too large for type A; maximum is B
#         magnitude of floating-point constant too small for type A; minimum is B
#   -Wsign-compare
#         comparison of integers of different signs: A and B
-Wnonportable-cfstrings # IGNORED switch
-Wnonportable-private-system-apinotes-path
#     private API notes file for module 'A' should be named 'A_private.apinotes', not 'B'
-Wnonportable-system-include-path
#     non-portable path to file 'A'; specified path differs in case from file name on disk
-Wnullable-to-nonnull-conversion
#     implicit conversion from nullable pointer A to non-nullable pointer type B
-Wnvcc-compat
#     target-attribute based function overloads are not supported by NVCC and will be treated as a function redeclaration:new declaration is <__device__|__global__|__host__|__host__ __device__> function, old declaration is <__device__|__global__|__host__|__host__ __device__> function
-Wobjc-interface-ivars
#     declaration of instance variables in the interface is deprecated
-Wobjc-messaging-id
#     messaging unqualified id
-Wobjc-missing-property-synthesis
#     auto property synthesis is synthesizing property not explicitly synthesized
-Wobjc-property-assign-on-object-type
#     'assign' property of object type may become a dangling reference; consider using 'unsafe_unretained'
-Wobjc-signed-char-bool
#   -Wobjc-bool-constant-conversion
#         implicit conversion from constant value A to 'BOOL'; the only well defined values for 'BOOL' are YES and NO
#   -Wobjc-signed-char-bool-implicit-float-conversion
#         implicit conversion from floating-point type A to 'BOOL'
#   -Wobjc-signed-char-bool-implicit-int-conversion
#         implicit conversion from integral type A to 'BOOL'
#   -Wtautological-objc-bool-compare
#         result of comparison of constant A with expression of type 'BOOL' is always B, as the only well defined values for 'BOOL' are YES and NO
-Wold-style-cast
#     use of old-style cast
-Wold-style-definition # IGNORED switch
-Wopenacc
#   -Wsource-uses-openacc
#         OpenACC clause 'A' not yet implemented, clause ignored
#         OpenACC construct 'A' not yet implemented, pragma ignored
#         unexpected '#pragma acc ...' in program
-Wopenmp
#   -Wopenmp-51-extensions
#         specifying OpenMP directives with [[]] is an OpenMP 5.1 extension
#   -Wopenmp-clauses
#         'A' is not a valid context property for the context selector 'B' and the context set 'C'; property ignored
#         'A' is not a valid context selector for the context set 'B'; selector ignored
#         'A' is not a valid context set in a `declare variant`; set ignored
#         A clause should not be followed by arguments; tokens will be ignored
#         aligned clause will be ignored because the requested alignment is not a power of 2
#         allocate directive specifies <default|'B'> allocator while previously used <default|'D'>
#         allocator with the 'thread' trait access has unspecified behavior on 'A' directive
#         expected 'A' after the B; 'A' assumed
#         expected identifier or string literal describing a context <set|selector|property>; <set|selector|property> skipped
#         interop type 'A' cannot be specified more than once
#         more than one 'device_type' clause is specified
#         reserved locator 'omp_all_memory' cannot be specified more than once
#         the context <set|selector|property> 'B' was used already in the same 'omp declare variant' directive; <set|selector|property> ignored
#         the context property 'A' is not valid for the context selector 'B' and the context set 'C'; property ignored
#         the context selector 'A' in context set 'B' requires a context property defined in parentheses; selector ignored
#         the context selector 'A' in the context set 'B' cannot have a score ('C'); score ignored
#         the context selector 'A' is not valid for the context set 'B'; selector ignored
#         valid A clauses start with B; <token|tokens> will be ignored
#         zero linear step (A [and other variables in clause ]should probably be const)
#   -Wopenmp-extensions
#         'ompx_attribute' clause only allows 'amdgpu_flat_work_group_size', 'amdgpu_waves_per_eu', and 'launch_bounds'; A is ignored
#   -Wopenmp-loop-form
#         OpenMP loop iteration variable cannot have more than 64 bits size and will be narrowed
#         initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')
#   -Wopenmp-mapping
#         type A is not trivially copyable and not guaranteed to be mapped correctly
#   -Wopenmp-target
#         OpenMP offloading target 'A' is similar to target 'B' already specified; will be ignored
#         declaration is not declared in any declare target region
#         declaration marked as declare target after first use, it may lead to incorrect results
#     -Wopenmp-mapping
#           type A is not trivially copyable and not guaranteed to be mapped correctly
#   -Wopenmp-target-exception
#         target 'A' does not support exception handling; 'catch' block is ignored
#         target 'A' does not support exception handling; 'throw' is assumed to be never reached
#   -Wsource-uses-openmp
#         '#pragma omp declare variant' cannot be applied for function after first usage; the original function might be used
#         '#pragma omp declare variant' cannot be applied to the function that was defined already; the original function might be used
#         OpenMP only allows an ordered construct with the simd clause nested in a simd construct
#         expected '#pragma omp end declare target' at end of file to match '#pragma omp A'
#         isa trait 'A' is not known to the current target; verify the spelling or consider restricting the context selector with the 'arch' selector further
#         score expressions in the OpenMP context selector need to be constant; A is not and will be ignored
#         unexpected '#pragma omp ...' in program
#         variant function in '#pragma omp declare variant' is itself marked as '#pragma omp declare variant'
-Wover-aligned
#     type A requires B bytes of alignment and the default allocator only guarantees C bytes
-Woverflow # IGNORED switch
-Woverriding-method-mismatch
#     conflicting distributed object modifiers on parameter type in declaration of A
#     conflicting distributed object modifiers on return type in declaration of A
#     conflicting parameter types in declaration of A
#     conflicting parameter types in declaration of A: B vs C
#     conflicting return type in declaration of A
#     conflicting return type in declaration of A: B vs C
#     conflicting variadic declaration of method and its implementation
-Wpacked
#     packed attribute is unnecessary for A
#   -Wpacked-non-pod
#         not packing field A as it is non-POD for the purposes of layout
-Wpadded
#     padding <struct|interface|class> B with C <byte|bit>(s) to align E
#     padding <struct|interface|class> B with C <byte|bit>(s) to align anonymous field
#     padding size of A with B <byte|bit>(s) to alignment boundary
#   -Wpadded-bitfield
#         padding <struct|interface|class> B with C <byte|bit>(s) to align E
#         padding <struct|interface|class> B with C <byte|bit>(s) to align anonymous bit-field
-Wpartial-availability
#   -Wunguarded-availability
#         A is only available [in E environment ]on B C or newer
#         A is unavailable
#     -Wunguarded-availability-new
#           A is only available [in E environment ]on B C or newer
#           A is unavailable
-Rpass
#     The text of this diagnostic is not controlled by Clang
-Rpass-analysis
#     A; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop or by providing the compiler option '-ffast-math'
#     A; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop; if the arrays will always be independent, specify '#pragma clang loop vectorize(assume_safety)' before the loop or provide the '__restrict__' qualifier with the independent array arguments -- erroneous results will occur if these options are incorrectly applied
#     The text of this diagnostic is not controlled by Clang
-Rpass-missed
#     The text of this diagnostic is not controlled by Clang
-Wpedantic
#     #ident is a language extension
#     #warning is a <C23|C++23> extension
#     '__thread' before 'A'
#     <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types> converts between void pointer and function pointer
#     C requires #line number to be less than A, allowed as extension
#     C99 forbids casting nonscalar type A to the same type
#     C99 forbids conditional expressions with only one void side
#     Clang permits use of type 'double' regardless pragma if 'cl_khr_fp64' is supported
#     ISO C does not support '~' for complex conjugation of A
#     ISO C forbids forward references to 'enum' types
#     ISO C forbids taking the address of an expression of type 'void'
#     ISO C restricts enumerator values to range of 'int' (A is too <small|large>)
#     ISO C90 does not allow subscripting non-lvalue array
#     __VA_ARGS__ can only appear in the expansion of a C99 variadic macro
#     anonymous <struct|union> cannot be 'B'
#     cast between pointer-to-function and pointer-to-object is an extension
#     comma operator in operand of #if
#     complex numbers are an extension in a freestanding C99 implementation
#     equality comparison between function pointer and void pointer (A and B)
#     ordered comparison between pointer and zero (A and B) is an extension
#     qualifier in explicit instantiation of A requires a template-id (a typedef is not permitted)
#     type-less parameter names in function declaration
#     use of non-standard escape character '\A'
#     variadic macros are a Clang extension in OpenCL
#     void <function|method|block> A should not return void expression
#   -Wauto-decl-extensions
#         type inference of a declaration other than a plain identifier with optional trailing attributes is a Clang extension
#   -Wbit-int-extension
#         '_BitInt' in <C17 and earlier|C++> is a Clang extension
#         '_BitInt' suffix for literals is a Clang extension
#   -Wc++11-extra-semi
#         extra ';' outside of a function is a C++11 extension
#   -Wc++14-binary-literal
#         binary integer literals are a C++14 extension
#   -Wc++20-designator
#         designated initializers are a C++20 extension
#   -Wc11-extensions
#         'A' is a C11 extension
#         anonymous structs are a C11 extension
#         anonymous unions are a C11 extension
#         pointer comparisons before C11 need to be between two complete or two incomplete types; A is [in]complete and B is [in]complete
#   -Wc2y-extensions
#         '<--|++>' on an object of complex type is a C2y extension
#         'alignof' on an incomplete array type is a C2y extension
#         passing a type argument as the first operand to '_Generic' is a C2y extension
#   -Wcomplex-component-init
#         complex initialization specifying real and imaginary components is an extension
#   -Wdelimited-escape-sequence-extension
#         <delimited|named> escape sequences are a <Clang|C++23> extension
#   -Wdollar-in-identifier-extension
#         '$' in identifier
#   -Wembedded-directive
#         embedding a directive within macro arguments has undefined behavior
#   -Wempty-translation-unit
#         ISO C requires a translation unit to contain at least one declaration
#   -Wfixed-enum-extension
#         enumeration types with a fixed underlying type are a Clang extension
#   -Wflexible-array-extensions
#         A may not be nested in a struct due to flexible array member
#         A may not be used as an array element due to flexible array member
#   -Wfuture-attribute-extensions
#     -Wc++14-attribute-extensions
#           use of the A attribute is a C++14 extension
#     -Wc++17-attribute-extensions
#           use of the A attribute is a C++17 extension
#     -Wc++20-attribute-extensions
#           use of the A attribute is a C++20 extension
#     -Wc++23-attribute-extensions
#           use of the A attribute is a C++23 extension
#   -Wgnu-anonymous-struct
#         anonymous structs are a GNU extension
#   -Wgnu-auto-type
#         '__auto_type' is a GNU extension
#   -Wgnu-case-range
#         use of GNU case range extension
#   -Wgnu-complex-integer
#         complex integer types are a GNU extension
#   -Wgnu-compound-literal-initializer
#         initialization of an array from a compound literal is a GNU extension
#   -Wgnu-conditional-omitted-operand
#         use of GNU ?: conditional expression extension, omitting middle operand
#   -Wgnu-empty-struct
#         <struct|union> without named members is a GNU extension
#         empty <struct|union> is a GNU extension
#         flexible array member A in otherwise empty <struct|interface|union|class|enum> is a GNU extension
#   -Wgnu-flexible-array-initializer
#         flexible array initialization is a GNU extension
#   -Wgnu-flexible-array-union-member
#         flexible array member A in a union is a GNU extension
#   -Wgnu-imaginary-constant
#         imaginary constants are a GNU extension
#   -Wgnu-include-next
#         #include_next is a language extension
#   -Wgnu-label-as-value
#         use of GNU address-of-label extension
#         use of GNU indirect-goto extension
#   -Wgnu-line-marker
#         this style of line directive is a GNU extension
#   -Wgnu-null-pointer-arithmetic
#         arithmetic on a null pointer treated as a cast from integer to pointer is a GNU extension
#   -Wgnu-pointer-arith
#         arithmetic on[ a] pointer[s] to void is a GNU extension
#         arithmetic on[ a] pointer[s] to[ the] function type[s] B[ and D] is a GNU extension
#         subscript of a pointer to void is a GNU extension
#   -Wgnu-redeclared-enum
#         redeclaration of already-defined enum A is a GNU extension
#   -Wgnu-statement-expression
#         use of GNU statement expression extension
#     -Wgnu-statement-expression-from-macro-expansion
#           use of GNU statement expression extension from macro expansion
#   -Wgnu-union-cast
#         cast to union type is a GNU extension
#   -Wgnu-zero-line-directive
#         #line directive with zero argument is a GNU extension
#   -Wgnu-zero-variadic-macro-arguments
#         token pasting of ',' and __VA_ARGS__ is a GNU extension
#   -Wimport-preprocessor-directive-pedantic
#         #import is a language extension
#   -Winvalid-utf8
#         invalid UTF-8 in comment
#   -Wkeyword-macro
#         keyword is hidden by macro definition
#   -Wlanguage-extension-token
#         extension used
#   -Wlong-long
#         'long long' is an extension when C99 mode is not enabled
#     -Wc++11-long-long
#           'long long' is a C++11 extension
#   -Wmicrosoft-charize
#         charizing operator #@ is a Microsoft extension
#   -Wmicrosoft-comment-paste
#         pasting two '/' tokens into a '//' comment is a Microsoft extension
#   -Wmicrosoft-cpp-macro
#         C++ operator A (aka B) used as a macro name
#   -Wmicrosoft-end-of-file
#         treating Ctrl-Z as end-of-file is a Microsoft extension
#   -Wmicrosoft-enum-value
#         enumerator value is not representable in the underlying type A
#   -Wmicrosoft-fixed-enum
#         enumeration types with a fixed underlying type are a Microsoft extension
#   -Wmicrosoft-flexible-array
#         flexible array member A in a union is a Microsoft extension
#         flexible array member A in otherwise empty <struct|interface|union|class|enum> is a Microsoft extension
#   -Wmicrosoft-redeclare-static
#         redeclaring non-static A as static is a Microsoft extension
#   -Wnested-anon-types
#         anonymous types declared in an anonymous <struct|union> are an extension
#   -Wnullability-extension
#         type nullability specifier A is a Clang extension
#   -Woverlength-strings
#         string literal of length A exceeds maximum length B that <C90|ISO C99|C++> compilers are required to support
#   -Wretained-language-linkage
#         friend function A retaining previous language linkage is an extension
#   -Wundefined-internal-type
#         ISO C++ requires a definition in this translation unit for <function|variable> B because its type does not have linkage
#   -Wzero-length-array
#         zero size arrays are an extension
-Wpedantic-core-features
#     A is a core feature in <OpenCL C|C++ for OpenCL> version C but not supported on this target
#     OpenCL extension A is core feature or supported optional core feature - ignoring
-Wpointer-arith
#     invalid application of 'A' to a function type
#     invalid application of 'A' to a void type
#     subtraction of pointers to type A of zero size has undefined behavior
#   -Wgnu-pointer-arith
#         arithmetic on[ a] pointer[s] to void is a GNU extension
#         arithmetic on[ a] pointer[s] to[ the] function type[s] B[ and D] is a GNU extension
#         subscript of a pointer to void is a GNU extension
-Wpoison-system-directories
#     include location 'A' is unsafe for cross-compilation
-Wpragmas
#     #pragma redefine_extname is applicable to external C declarations only; not applied to <function|variable> B
#     setting the floating point evaluation method to `source` on a target without SSE is not supported
#   -Wignored-pragmas
#         #pragma A(pop, ...) failed: B
#         #pragma options align=reset failed: A
#         '#pragma A' is not supported on this target - ignored
#         '#pragma comment A' ignored
#         '#pragma init_seg' is only supported when targeting a Microsoft environment
#         <value|type>-dependent expression passed as an argument to debug command
#         OpenCL extension A unknown or does not require pragma - ignoring
#         expected #pragma pack parameter to be '1', '2', '4', '8', or '16'
#         expected '#pragma unused' argument to be a variable name
#         expected ')' or ',' in '#pragma A'
#         expected ',' in '#pragma A'
#         expected '=' following '#pragma <align|options align>' - ignored
#         expected 'align' following '#pragma options' - ignored
#         expected 'compiler', 'lib', 'user', or a string literal for the section name in '#pragma A' - ignored
#         expected <'enable', 'disable', 'begin' or 'end'|'disable'> - ignoring
#         expected a stack label or a string literal for the section name in '#pragma A' - ignored
#         expected a string literal for the section name in '#pragma A' - ignored
#         expected action or ')' in '#pragma A' - ignored
#         expected identifier in '#pragma A' - ignored
#         expected integer between A and B inclusive in '#pragma C' - ignored
#         expected integer or identifier in '#pragma pack' - ignored
#         expected non-wide string literal in '#pragma A'
#         expected push, pop or a string literal for the section name in '#pragma A' - ignored
#         expected string literal in '#pragma A' - ignoring
#         expected string literal in 'clause A' - ignoring
#         extra tokens at end of '#pragma A' - ignored
#         incorrect use of #pragma clang force_cuda_host_device begin|end
#         incorrect use of '#pragma fenv_access (on|off)' - ignored
#         incorrect use of '#pragma ms_struct on|off' - ignored
#         invalid alignment option in '#pragma <align|options align>' - ignored
#         invalid or unsupported rounding mode in '#pragma STDC FENV_ROUND' - ignored
#         known but unsupported action 'B' for '#pragma A' - ignored
#         missing '(' after '#pragma A' - ignoring
#         missing ')' after '#pragma A' - ignoring
#         missing ':' after A - ignoring
#         missing ':' or ')' after A - ignoring
#         missing argument to '#pragma A'[; expected C]
#         missing argument to debug command 'A'
#         missing debug command
#         only variables can be arguments to '#pragma unused'
#         pragma pop_macro could not pop 'A', no matching push_macro
#         undeclared variable A used as an argument for '#pragma unused'
#         unexpected argument 'A' to '#pragma B'[; expected D]
#         unexpected argument to debug command
#         unexpected debug command 'A'
#         unknown action 'B' for '#pragma A' - ignored
#         unknown action for '#pragma A' - ignored
#         unknown module 'A'
#         unsupported OpenCL extension A - ignoring
#     -Wignored-pragma-intrinsic
#           A is not a recognized builtin[; consider including <intrin.h> to access non-builtin intrinsics]
#     -Wignored-pragma-optimize # IGNORED switch
#   -Wpragma-clang-attribute
#         unused attribute A in '#pragma clang attribute push' region
#   -Wpragma-pack
#         the current #pragma pack alignment value is modified in the included file
#         unterminated '#pragma pack (push, ...)' at end of file
#     -Wpragma-pack-suspicious-include
#           non-default #pragma pack value changes the alignment of struct or union members in the included file
#   -Wunknown-pragmas
#         #pragma execution_character_set expected 'A'
#         #pragma execution_character_set expected 'push' or 'pop'
#         #pragma execution_character_set invalid value 'A', only 'UTF-8' is supported
#         #pragma warning expected 'A'
#         #pragma warning expected 'push', 'pop', 'default', 'disable', 'error', 'once', 'suppress', 1, 2, 3, or 4
#         #pragma warning expected a warning number
#         #pragma warning(push, level) requires a level between 0 and 4
#         angle-bracketed include <A> cannot be aliased to double-quoted include "B"
#         double-quoted include "A" cannot be aliased to angle-bracketed include <B>
#         expected 'ON' or 'OFF' or 'DEFAULT' in pragma
#         expected end of directive in pragma
#         pragma STDC FENV_ROUND is not supported
#         pragma diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'
#         pragma diagnostic expected option name (e.g. "-Wundef")
#         pragma diagnostic pop could not pop, no matching push
#         pragma include_alias expected 'A'
#         pragma include_alias expected include filename
#         unexpected token in pragma diagnostic
#         unknown pragma ignored
#         unknown pragma in STDC namespace
-Wpre-c++2c-compat
#   -Wpre-c++26-compat
#          'A' in a raw string literal delimiter is incompatible with standards before C++2c
#         '= delete' with a message is incompatible with C++ standards before C++2c
#         an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#         pack indexing is incompatible with C++ standards before C++2c
#         placeholder variables are incompatible with C++ standards before C++2c
-Wpre-c++2c-compat-pedantic
#   -Wpre-c++26-compat-pedantic
#     -Wpre-c++26-compat
#            'A' in a raw string literal delimiter is incompatible with standards before C++2c
#           '= delete' with a message is incompatible with C++ standards before C++2c
#           an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c
#           pack indexing is incompatible with C++ standards before C++2c
#           placeholder variables are incompatible with C++ standards before C++2c
-Wpre-c11-compat-pedantic
#   -Wpre-c11-compat
#         'A' is incompatible with C standards before C11
-Wpre-c2x-compat
#   -Wpre-c23-compat
#         #embed is incompatible with C standards before C23
#         #warning is incompatible with C standards before C23
#         '...' as the only parameter of a function is incompatible with C standards before C23
#         'A' is incompatible with C standards before C23
#         '_BitInt' suffix for literals is incompatible with C standards before C23
#         '_Static_assert' with no message is incompatible with C standards before C23
#         [[]] attributes are incompatible with C standards before C23
#         binary integer literals are incompatible with C standards before C23
#         digit separators are incompatible with C standards before C23
#         label at end of compound statement is incompatible with C standards before C23
#         label followed by a declaration is incompatible with C standards before C23
#         passing no argument for the '...' parameter of a variadic macro is incompatible with C standards before C23
#         specifying character 'A' with a universal character name is incompatible with C standards before C23
#         universal character name referring to a control character is incompatible with C standards before C23
#         use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C standards before C23
#         use of an empty initializer is incompatible with C standards before C23
-Wpre-c2x-compat-pedantic
#   -Wpre-c23-compat-pedantic
#     -Wpre-c23-compat
#           #embed is incompatible with C standards before C23
#           #warning is incompatible with C standards before C23
#           '...' as the only parameter of a function is incompatible with C standards before C23
#           'A' is incompatible with C standards before C23
#           '_BitInt' suffix for literals is incompatible with C standards before C23
#           '_Static_assert' with no message is incompatible with C standards before C23
#           [[]] attributes are incompatible with C standards before C23
#           binary integer literals are incompatible with C standards before C23
#           digit separators are incompatible with C standards before C23
#           label at end of compound statement is incompatible with C standards before C23
#           label followed by a declaration is incompatible with C standards before C23
#           passing no argument for the '...' parameter of a variadic macro is incompatible with C standards before C23
#           specifying character 'A' with a universal character name is incompatible with C standards before C23
#           universal character name referring to a control character is incompatible with C standards before C23
#           use of a '#<<BUG IF SEEN>|elifdef|elifndef>' directive is incompatible with C standards before C23
#           use of an empty initializer is incompatible with C standards before C23
-Wpre-c2y-compat-pedantic
#   -Wpre-c2y-compat
#         '<--|++>' on an object of complex type is incompatible with C standards before C2y
#         'alignof' on an incomplete array type is incompatible with C standards before C2y
#         passing a type argument as the first operand to '_Generic' is incompatible with C standards before C2y
-Wpre-openmp-51-compat
#     specifying OpenMP directives with [[]] is incompatible with OpenMP standards before OpenMP 5.1
-Wprofile-instr-missing
#     profile data may be incomplete: of A function(s), B <has|have> no data
-Wquoted-include-in-framework-header
#     double-quoted include "A" in framework header, expected angle-bracketed instead
-Wreceiver-forward-class
#     receiver A is a forward class and corresponding @interface may not exist
#     receiver type A for instance message is a forward declaration
-Wredundant-decls # IGNORED switch
-Wredundant-parens
#     redundant parentheses surrounding declarator
-Rremark-backend-plugin
#     The text of this diagnostic is not controlled by Clang
-Wreserved-id-macro
#   -Wreserved-macro-identifier
#         macro name is a reserved identifier
-Wreserved-identifier
#     identifier A is reserved because <<ERROR>|it starts with '_' at global scope|it starts with '_' and has C language linkage|it starts with '__'|it starts with '_' followed by a capital letter|it contains '__'>
#   -Wreserved-macro-identifier
#         macro name is a reserved identifier
#   -Wreserved-module-identifier
#         A is a reserved name for a module
#   -Wuser-defined-literals
#         user-defined literal suffixes <<ERROR>|not starting with '_'|containing '__'> are reserved[; no literal will invoke this operator]
-Wreserved-user-defined-literal
#     invalid suffix on literal; C++11 requires a space between literal and identifier
#   -Wc++11-compat-reserved-user-defined-literal
#         identifier after literal will be treated as a reserved user-defined literal suffix in C++11
-Rround-trip-cc1-args
#     generated arguments #A in round-trip: B
-Rsanitize-address
#     -fsanitize-address-field-padding applied to A
#     -fsanitize-address-field-padding ignored for A because it <is not C++|is packed|is a union|is trivially copyable|has trivial destructor|is standard layout|is in a ignorelisted file|is ignorelisted>
-Rsearch-path-usage
#     search path used: 'A'
-Wselector
#     no method with selector A is implemented in this translation unit
#   -Wselector-type-mismatch
#         several methods with selector A of mismatched types are found for the @selector expression
-Wshadow-all
#   -Wshadow
#         declaration shadows a <local variable|variable in C|static data member of C|field of C|typedef in C|type alias in C|structured binding>
#     -Wshadow-field-in-constructor-modified
#           modifying constructor parameter A that shadows a field of B
#     -Wshadow-ivar
#           local declaration of A hides instance variable
#   -Wshadow-field
#         <parameter|non-static data member> A [of B ]shadows member inherited from type C
#   -Wshadow-field-in-constructor
#         constructor parameter A shadows the field B of C
#     -Wshadow-field-in-constructor-modified
#           modifying constructor parameter A that shadows a field of B
#   -Wshadow-uncaptured-local
#         declaration shadows a <local variable|variable in C|static data member of C|field of C|typedef in C|type alias in C|structured binding>
-Wshift-sign-overflow
#     signed shift result (A) sets the sign bit of the shift expression's type (B) and becomes negative
-Wsign-promo # IGNORED switch
-Wsigned-enum-bitfield
#     enums in the Microsoft ABI are signed integers by default; consider giving the enum A an unsigned underlying type to make this code portable
-Wspirv-compat
#   -Wspir-compat
#         sampler initializer has invalid A bits
-Wstatic-in-inline
#     static <function|variable> B is used in an inline function with external linkage
-Wstrict-aliasing # IGNORED switch
-Wstrict-aliasing=0 # IGNORED switch
-Wstrict-aliasing=1 # IGNORED switch
-Wstrict-aliasing=2 # IGNORED switch
-Wstrict-overflow # IGNORED switch
-Wstrict-overflow=0 # IGNORED switch
-Wstrict-overflow=1 # IGNORED switch
-Wstrict-overflow=2 # IGNORED switch
-Wstrict-overflow=3 # IGNORED switch
-Wstrict-overflow=4 # IGNORED switch
-Wstrict-overflow=5 # IGNORED switch
-Wstrict-potentially-direct-selector
#     @selector expression formed with potentially direct selector A
#   -Wpotentially-direct-selector
#         @selector expression formed with potentially direct selector A
-Wstrict-prototypes
#     a <function|block> declaration without a prototype is deprecated [in all versions of C]
#   -Wdeprecated-non-prototype
#         a function <declaration|definition> without a prototype is deprecated in all versions of C <and is not supported in C23|and is treated as a zero-parameter prototype in C23, conflicting with a <previous|subsequent> <declaration|definition>>
#         passing arguments to <a function|B> without a prototype is deprecated in all versions of C and is not supported in C23
-Wstrict-selector-match
#     multiple methods named A found
-Wsuggest-destructor-override
#     A overrides a destructor but is not marked 'override'
-Wsuggest-override
#     A overrides a member function but is not marked 'override'
-Wsuper-class-method-mismatch
#     method parameter type does not match super class method parameter type
-Wswitch-default
#     'switch' missing 'default' label
-Wswitch-enum
#     <enumeration value B not explicitly handled in switch|enumeration values B and C not explicitly handled in switch|enumeration values B, C, and D not explicitly handled in switch|A enumeration values not explicitly handled in switch>
-Wsynth # IGNORED switch
-Wtautological-constant-in-range-compare
#   -Wtautological-value-range-compare
#         result of comparison of <E|A-bit <signed|unsigned> value,2> D <A-bit <signed|unsigned> value,2|E> is always F
#   -Wtype-limits
#     -Wtautological-type-limit-compare
#           result of comparison <D|B> C <B|D> is always E
#     -Wtautological-unsigned-char-zero-compare
#           result of comparison of <D|char expression> C <char expression|D> is always E, since char is interpreted as unsigned
#     -Wtautological-unsigned-enum-zero-compare
#           result of comparison of <D|unsigned enum expression> C <unsigned enum expression|D> is always E
#     -Wtautological-unsigned-zero-compare
#           result of comparison of <D|unsigned expression> C <unsigned expression|D> is always E
-Wthread-safety
#   -Wthread-safety-analysis
#         <reading|writing> the value pointed to by A requires holding <any mutex|any mutex exclusively>
#         <reading|writing> the value pointed to by B requires holding A <'C'|'C' exclusively>
#         <reading|writing> variable A requires holding <any mutex|any mutex exclusively>
#         <reading|writing> variable B requires holding A <'C'|'C' exclusively>
#         A 'B' is acquired exclusively and shared in the same scope
#         A 'B' is not held on every path through here
#         A 'B' is still held at the end of function
#         A 'B' must be acquired before 'C'
#         acquiring A 'B' that is already held
#         calling function A requires negative capability 'B'
#         calling function B requires holding A <'C'|'C' exclusively>
#         cannot call function 'B' while A 'C' is held
#         cannot resolve lock expression
#         cycle in acquired_before/after dependencies, starting with 'A'
#         expecting A 'B' to be held at start of each loop
#         expecting A 'B' to be held at the end of function
#         releasing A 'B' that was not held
#         releasing A 'B' using <shared|exclusive> access, expected <shared|exclusive> access
#   -Wthread-safety-attributes
#         A attribute can only be applied in a context annotated with 'capability' attribute
#         A attribute requires arguments whose type is annotated with 'capability' attribute; type here is B
#         A attribute without capability arguments can only be applied to non-static methods of a class
#         A attribute without capability arguments refers to 'this', but B isn't annotated with 'capability' or 'scoped_lockable' attribute
#         A only applies to pointer types; type here is B
#         ignoring A attribute because its argument is invalid
#   -Wthread-safety-precise
#         <reading|writing> the value pointed to by B requires holding A <'C'|'C' exclusively>
#         <reading|writing> variable B requires holding A <'C'|'C' exclusively>
#         calling function B requires holding A <'C'|'C' exclusively>
#   -Wthread-safety-reference
#         passing the value that B points to by reference requires holding A <'C'|'C' exclusively>
#         passing variable B by reference requires holding A <'C'|'C' exclusively>
#     -Wthread-safety-reference-return
#           returning the value that B points to by reference requires holding A <'C'|'C' exclusively>
#           returning variable B by reference requires holding A <'C'|'C' exclusively>
-Wthread-safety-beta
#     thread safety beta warning
-Wthread-safety-negative
#     acquiring A 'B' requires negative capability 'C'
-Wthread-safety-verbose
#     thread safety verbose warning
-Wunaligned-access
#     field B within A is less aligned than C and is usually due to A being packed, which can lead to unaligned accesses
-Wundeclared-selector
#     undeclared selector A
#     undeclared selector A; did you mean B?
-Wundef
#     A is not defined, evaluates to 0
-Wundef-prefix
#     A is not defined, evaluates to 0
-Wundefined-func-template
#     instantiation of function A required here, but no definition is available
-Wundefined-reinterpret-cast
#     dereference of type B that was reinterpret_cast from type A has undefined behavior
#     reinterpret_cast from A to B has undefined behavior
-Wunnamed-type-template-args
#     template argument uses unnamed type
#   -Wc++98-compat-unnamed-type-template-args
#         unnamed type as template argument is incompatible with C++98
-Wunreachable-code-aggressive
#   -Wunreachable-code
#         code will never be executed
#     -Wunreachable-code-fallthrough
#           fallthrough annotation in unreachable code
#     -Wunreachable-code-generic-assoc
#           due to lvalue conversion of the controlling expression, association of type A will never be selected because it is <of array type|qualified>
#     -Wunreachable-code-loop-increment
#           loop will run at most once (loop increment never executed)
#   -Wunreachable-code-break
#         'break' will never be executed
#   -Wunreachable-code-return
#         'return' will never be executed
-Wunsafe-buffer-usage
#     <unsafe pointer operation|unsafe pointer arithmetic|unsafe buffer access|function introduces unsafe buffer manipulation|unsafe invocation of span::data>
#     A is an <unsafe pointer used for buffer access|unsafe buffer that does not perform bounds checks>
#   -Wunsafe-buffer-usage-in-container
#         the two-parameter std::span construction is unsafe as it can introduce mismatch between buffer size and the bound information
-Wunsupported-dll-base-class-template
#     propagating dll attribute to <already instantiated|explicitly specialized> base class template without dll attribute is not supported
-Wunused-exception-parameter
#     unused exception parameter A
-Wunused-local-typedefs
#   -Wunused-local-typedef
#         unused <typedef|type alias> B
-Wunused-macros
#     macro is not used
-Wunused-member-function
#     unused member function A
#   -Wunneeded-member-function
#         member function A is not needed and will not be emitted
-Wunused-template
#     unused <function|variable> template B
#   -Wunneeded-internal-declaration
#         'static' function A declared in header file should be declared 'static inline'
#         <function|variable> B is not needed and will not be emitted
-Wused-but-marked-unused
#     A was marked unused but was used
-Wvariadic-macros
#     __VA_OPT__ can only appear in the expansion of a variadic macro
#     named variadic macros are a GNU extension
#     variadic macros are a C99 feature
-Wvector-conversions
#   -Wvector-conversion
#         incompatible vector types <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>
-Wvla
#     variable length array used
#   -Wvla-extension
#         variable length arrays are a C99 feature
#     -Wvla-cxx-extension
#           variable length arrays in C++ are a Clang extension
#       -Wvla-extension-static-assert
#             variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?
-Wweak-template-vtables
#     this warning is no longer in use and will be removed in the next release
-Wweak-vtables
#     A has no out-of-line virtual method definitions; its vtable will be emitted in every translation unit
-Wzero-as-null-pointer-constant
#     zero as null pointer constant
