# enabled by default:
#   -W (partial)
#     -Wextra (partial)
#       -Wignored-qualifiers (partial)
#             ARC <unused|__unsafe_unretained|__strong|__weak|__autoreleasing> lifetime qualifier on return type is ignored
#       -Winitializer-overrides
#             initializer overrides prior initialization of this subobject
#             subobject initialization overrides initialization of other fields within its enclosing subobject
#   -W#pragma-messages
#         The text of this diagnostic is not controlled by Clang
#   -W#warnings
#         The text of this diagnostic is not controlled by Clang
#   -Wabstract-final-class
#         abstract class is marked 'final'
#   -Waddress-of-array-temporary
#         pointer is initialized by a temporary array, which will be destroyed at the end of the full-expression
#   -Waddress-of-temporary
#         taking the address of a temporary object of type A
#   -Wall (partial)
#     -Wmost (partial)
#       -Wcast-of-sel-type
#             cast of type A to B is deprecated; use sel_getName instead
#       -Wcomment (partial)
#             '/*' within block comment
#             escaped newline between */ characters at block comment end
#       -Wdelete-non-virtual-dtor (partial)
#             delete called on A that is abstract but has non-virtual destructor
#       -Wformat
#             '<*|.*>' specified field <width|precision> is missing a matching 'int' argument
#             <field width|precision> used with 'B' conversion specifier, resulting in undefined behavior
#             cannot mix positional and non-positional arguments in format string
#             data argument position 'A' exceeds the number of data arguments (B)
#             field <width|precision> should have type B, but argument has type C
#             flag 'A' is ignored when flag 'B' is present
#             flag 'A' results in undefined behavior with 'B' conversion specifier
#             format specifies type A but the argument has type B
#             format string contains '\0' within the string body
#             format string missing
#             format string should not be a wide string
#             incomplete format specifier
#             invalid position specified for <field width|field precision>
#             length modifier 'A' results in undefined behavior or no effect with 'B' conversion specifier
#             more '%' conversions than data arguments
#             no closing ']' for '%[' in scanf format string
#             position arguments in format strings start counting at 1 (not 0)
#             values of type 'A' should not be used as format arguments; add an explicit cast to B instead
#             zero field width in scanf format string is unused
#         -Wformat-extra-args
#               data argument not used by format string
#         -Wformat-invalid-specifier
#               invalid conversion specifier 'A'
#         -Wformat-security
#               format string is not a string literal (potentially insecure)
#         -Wformat-zero-length
#               format string is empty
#         -Wnonnull
#               null passed to a callee which requires a non-null argument
#       -Wimplicit (partial)
#         -Wimplicit-function-declaration (partial)
#               implicit declaration of function A is invalid in C99
#               use of unknown builtin A
#         -Wimplicit-int
#               type specifier missing, defaults to 'int'
#       -Wmultichar
#             multi-character character constant
#       -Wobjc-missing-super-calls
#             method possibly missing a [super A] call
#       -Wprivate-extern
#             use of __private_extern__ on a declaration may not produce external symbol private to the linkage unit and is deprecated
#       -Wreturn-type
#             <void function|void method|constructor|destructor> A should not return a value
#             control may reach end of non-void function
#             control may reach end of non-void lambda
#             control reaches end of non-void function
#             control reaches end of non-void lambda
#             non-void <function|method> A should return a value
#         -Wreturn-type-c-linkage
#               A has C-linkage specified, but returns incomplete type B which could be incompatible with C
#               A has C-linkage specified, but returns user-defined type B which is incompatible with C
#       -Wself-assign (partial)
#         -Wself-assign-field
#               assigning <field|instance variable> to itself
#       -Wsizeof-array-argument
#             sizeof on array function parameter will return size of A instead of B
#       -Wsizeof-array-decay
#             sizeof on pointer operation will return size of A instead of B
#       -Wstring-plus-int
#             adding A to a string does not append to the string
#       -Wtrigraphs
#             ignored trigraph would end block comment
#             trigraph converted to 'A' character
#             trigraph ends block comment
#             trigraph ignored
#       -Wuninitialized (partial)
#             field A is uninitialized when used here
#             reference A is not yet bound to a value when used here
#             reference A is not yet bound to a value when used within its own initialization
#             variable A is uninitialized when used within its own initialization
#         -Wstatic-self-init
#               static variable A is suspiciously used within its own initialization
#       -Wunknown-pragmas (partial)
#             angle-bracketed include <A> cannot be aliased to double-quoted include "B"
#             double-quoted include "A" cannot be aliased to angle-bracketed include <B>
#             expected 'ON' or 'OFF' or 'DEFAULT' in pragma
#             expected end of directive in pragma
#             pragma STDC FENV_ACCESS ON is not supported, ignoring pragma
#             pragma diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'
#             pragma diagnostic expected option name (e.g. "-Wundef")
#             pragma diagnostic pop could not pop, no matching push
#             pragma include_alias expected 'A'
#             pragma include_alias expected include filename
#             unexpected token in pragma diagnostic
#             unknown pragma in STDC namespace
#             unknown warning group 'A', ignored
#       -Wunused (partial)
#         -Wunused-value
#               container access result unused - container access should not be used for side effects
#               expression result unused
#               expression result unused; should this cast be to 'void'?
#               ignoring return value of function declared with A attribute
#               property access result unused - getters should not be used for side effects
#           -Wunused-comparison
#                 <equality|inequality> comparison result unused
#           -Wunused-result
#                 ignoring return value of function declared with warn_unused_result attribute
#     -Wparentheses
#           A has lower precedence than B; B will be evaluated first
#           operator '?:' has lower precedence than 'A'; 'A' will be evaluated first
#           using the result of an assignment as a condition without parentheses
#       -Wbitwise-op-parentheses
#             '&' within '|'
#       -Wdangling-else
#             add explicit braces to avoid dangling else
#       -Wlogical-op-parentheses
#             '&&' within '||'
#       -Woverloaded-shift-op-parentheses
#             overloaded operator <>>|<<> has lower precedence than comparison operator
#       -Wparentheses-equality
#             equality comparison with extraneous parentheses
#       -Wshift-op-parentheses
#             operator 'A' has lower precedence than 'B'; 'B' will be evaluated first
#     -Wswitch
#           A enumeration values not handled in switch: B, C, D...
#           case value not in enumerated type A
#           enumeration value A not handled in switch
#           enumeration values A and B not handled in switch
#           enumeration values A, B, and C not handled in switch
#           overflow converting case value to switch condition type (A to B)
#   -Wambiguous-macro
#         ambiguous expansion of macro A
#   -Wambiguous-member-template
#         lookup of A in member access expression is ambiguous; using member of B
#   -Wanalyzer-incompatible-plugin
#         checker plugin 'A' is not compatible with this version of the analyzer
#   -Wanonymous-pack-parens
#         ISO C++11 requires a parenthesized pack declaration to have a name
#   -Warc
#     -Warc-non-pod-memaccess
#           <destination for|source of> this B call is a pointer to ownership-qualified type C
#     -Warc-retain-cycles
#           capturing A strongly in this block is likely to lead to a retain cycle
#     -Warc-unsafe-retained-assign
#           assigning <array literal|dictionary literal|numeric literal|boxed expression|<should not happen>|block literal> to a weak <property|variable>; object will be released after assignment
#           assigning retained object to <weak|unsafe_unretained> <property|variable>; object will be released after assignment
#           assigning retained object to unsafe property; object will be released after assignment
#   -Warc-bridge-casts-disallowed-in-nonarc
#         'A' casts have no effect when not using ARC
#   -Warc-performSelector-leaks
#         performSelector may cause a leak because its selector is unknown
#   -Warray-bounds
#         'static' has no effect on zero-length arrays
#         array argument is too small; contains A elements, callee requires at least B
#         array index A is before the beginning of the array
#         array index A is past the end of the array (which contains B element(s))
#   -Wasm
#     -Wasm-operand-widths
#           the value is truncated when put into register, use a modifier to specify the size
#   -Watomic-property-with-user-defined-accessor
#         writable atomic property A cannot pair a synthesized <getter|setter> with a user defined <getter|setter>
#   -Wattributes
#         unknown __declspec attribute A ignored
#         unknown attribute A ignored
#   -Wauto-storage-class
#         'auto' storage class specifier is not permitted in C++11, and will not be supported in future releases
#   -Wauto-var-id
#         'auto' deduced as 'id' in declaration of A
#   -Wavailability
#         'unavailable' availability overrides all other availability information
#         availability does not match previous declaration
#         feature cannot be <introduced|deprecated|obsoleted> in B version C before it was <introduced|deprecated|obsoleted> in version E; attribute ignored
#         overriding method <introduced after|deprecated before|obsoleted before> overridden method on B (C vs. D)
#         overriding method cannot be unavailable on A when its overridden method is available
#         unknown platform A in availability macro
#   -Wbackslash-newline-escape
#         backslash and newline separated by space
#   -Wbad-array-new-length
#         array is too large (A elements)
#         array size is negative
#   -Wbind-to-temporary-copy (partial)
#         C++98 requires an accessible copy constructor for class C when binding a reference to a temporary; was <private|protected>
#         no viable constructor <copying variable|copying parameter|returning object|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value> of type B; C++98 requires a copy constructor when binding a reference to a temporary
#   -Wbool-conversions
#     -Wbool-conversion
#           address of function A will always evaluate to 'true'
#           initialization of pointer of type A to null from a constant boolean expression
#   -Wbuiltin-macro-redefined
#         redefining builtin macro
#         undefining builtin macro
#   -Wbuiltin-requires-header
#         declaration of built-in function 'A' requires inclusion of the header <setjmp.h>
#         declaration of built-in function 'A' requires inclusion of the header <stdio.h>
#         declaration of built-in function 'A' requires inclusion of the header <ucontext.h>
#   -Wc++0x-compat (partial)
#     -Wc++11-compat (partial)
#           use of right-shift operator ('>>') in template argument will require parentheses in C++11
#       -Wc++11-narrowing (partial)
#             <case value|enumerator value|non-type template argument> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#             constant expression evaluates to A which cannot be narrowed to type B
#             non-constant-expression cannot be narrowed from type A to B in initializer list
#             type A cannot be narrowed to B in initializer list
#   -Wc++0x-extensions (partial)
#     -Wc++11-extensions (partial)
#           'A' keyword is a C++11 extension
#           'auto' type specifier is a C++11 extension
#           'template' keyword outside of a template
#           'typename' occurs outside of a template
#           alias declarations are a C++11 extension
#           default template arguments for a function template are a C++11 extension
#           defaulted function definitions are a C++11 extension
#           deleted function definitions are a C++11 extension
#           explicit conversion functions are a C++11 extension
#           first declaration of <class template|class template partial|function template|member function|static data member|member class|member enumeration> specialization of B outside namespace C is a C++11 extension
#           generalized initializer lists are a C++11 extension
#           in-class initialization of non-static data member is a C++11 extension
#           inline namespaces are a C++11 feature
#           non-class friend type A is a C++11 extension
#           non-type template argument referring to <function|object> B with internal linkage is a C++11 extension
#           range-based for loop is a C++11 extension
#           reference qualifiers on functions are a C++11 extension
#           rvalue references are a C++11 extension
#           scoped enumerations are a C++11 extension
#           static data member A in union is a C++11 extension
#           unelaborated friend declaration is a C++11 extension; specify '<struct|interface|union|class|enum>' to befriend B
#           variadic templates are a C++11 extension
#   -Wc++0x-narrowing (partial)
#     -Wc++11-narrowing (partial)
#           <case value|enumerator value|non-type template argument> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#           constant expression evaluates to A which cannot be narrowed to type B
#           non-constant-expression cannot be narrowed from type A to B in initializer list
#           type A cannot be narrowed to B in initializer list
#   -Wc++1y-extensions (partial)
#         'decltype(auto)' type specifier is a C++1y extension
#         multiple return statements in constexpr function is a C++1y extension
#         type definition in a constexpr <function|constructor> is a C++1y extension
#         use of this statement in a constexpr <function|constructor> is a C++1y extension
#         variable declaration in a constexpr <function|constructor> is a C++1y extension
#   -Wc99-extensions (partial)
#         ISO C99 requires whitespace after the macro name
#   -WCFString-literal
#         input conversion stopped due to an input byte that does not belong to the input codeset UTF-8
#   -Wcomments (partial)
#     -Wcomment (partial)
#           '/*' within block comment
#           escaped newline between */ characters at block comment end
#   -Wcompare-distinct-pointer-types
#         comparison of distinct pointer types
#         comparison of distinct pointer types (A and B) uses non-standard composite pointer type C
#   -Wconditional-type-mismatch
#         pointer/integer type mismatch in conditional expression
#   -Wconfig-macros
#         <definition|#undef> of configuration macro 'B' has no effect on the import of 'C'; pass '<-DB=...|-UB>' on the command line to configure the module
#   -Wconstant-logical-operand
#         use of logical 'A' with constant operand
#   -Wconstexpr-not-const
#         'constexpr' non-static member function will not be implicitly 'const' in C++1y; add 'const' to avoid a change in behavior
#   -Wconversion-null
#     -Wnull-conversion
#           implicit conversion of NULL constant to A
#   -Wdangling-field
#         binding reference member A to a temporary value
#         binding reference member A to stack allocated parameter B
#         initializing pointer member A with the stack address of parameter B
#   -Wdangling-initializer-list
#         array backing the initializer list will be destroyed at the end of <the full-expression|the constructor>
#   -Wdelegating-ctor-cycles
#         constructor for A creates a delegation cycle
#   -Wdelete-incomplete
#         deleting pointer to incomplete type A may cause undefined behavior
#   -Wdeprecated
#         Use of 'long' with '__vector' is deprecated
#         access declarations are deprecated; use using declarations instead
#         argument 'A' is deprecated, use 'B' instead
#         incrementing expression of type bool is deprecated
#         treating 'A' input as 'B' when in C++ mode, this behavior is deprecated
#     -Wdeprecated-declarations
#           A is deprecated
#           A is deprecated: B
#           A maybe deprecated because receiver type is unknown
#           use of C-style parameters in Objective-C method declarations is deprecated
#   -Wdeprecated-objc-isa-usage
#         assignment to Objective-C's isa is deprecated in favor of object_setClass()
#         direct access to Objective-C's isa is deprecated in favor of object_getClass()
#   -Wdeprecated-objc-pointer-introspection
#         bitmasking for introspection of Objective-C object pointers is strongly discouraged
#   -Wdistributed-object-modifiers
#         conflicting distributed object modifiers on parameter type in implementation of A
#         conflicting distributed object modifiers on return type in implementation of A
#   -Wdivision-by-zero
#         division by zero is undefined
#         remainder by zero is undefined
#   -Wduplicate-decl-specifier
#         duplicate 'A' declaration specifier
#   -Wdynamic-class-memaccess
#         <destination for|source of|first operand of|second operand of> this B call is a pointer to dynamic class C; vtable pointer will be <overwritten|copied|moved|compared>
#   -Wempty-body
#         for loop has empty body
#         if statement has empty body
#         range-based for loop has empty body
#         switch statement has empty body
#         while loop has empty body
#   -Wendif-labels
#     -Wextra-tokens
#           extra tokens at end of #A directive
#           extra tokens at end of '#pragma omp A' are ignored
#   -Wenum-compare
#         comparison of two values with different enumeration types
#   -Wextern-initializer
#         'extern' variable has an initializer
#   -Wformat=2 (partial)
#     -Wformat-nonliteral (partial)
#       -Wformat-security
#             format string is not a string literal (potentially insecure)
#     -Wformat-security
#           format string is not a string literal (potentially insecure)
#   -Wgcc-compat
#         GCC does not allow A attribute in this position on a function definition
#   -Wgnu (partial)
#         A applied to an expression is a GNU extension
#         field A with variable sized type B not at the end of a struct or class is a GNU extension
#     -Wgnu-designator (partial)
#           use of GNU 'missing =' extension in designator
#           use of GNU old-style field designator extension
#     -Wgnu-static-float-init
#           in-class initializer for static data member of type A is a GNU extension
#   -Wgnu-array-member-paren-init
#         parenthesized initialization of a member array is a GNU extension
#   -Wignored-attributes
#         'A' attribute argument not supported: B
#         'A' only applies to Objective-C object or block pointer types; type here is B
#         'A' only applies to function types; type here is B
#         'A' only applies to pointer types; type here is B
#         'gnu_inline' attribute requires function to be marked 'inline', attribute ignored
#         'malloc' attribute only applies to functions returning a pointer type
#         'nonnull' attribute applied to function with no pointer arguments
#         'sentinel' attribute only supported for variadic <functions|blocks>
#         'sentinel' attribute requires named arguments
#         'weak_import' attribute cannot be specified on a definition
#         <alignment|size> of field B (C bits) does not match the <alignment|size> of the first field in transparent union; transparent_union attribute ignored
#         A attribute can only be applied to instance variables or properties
#         A attribute ignored
#         A attribute ignored for field of type B
#         A attribute ignored when parsing type
#         A attribute only applies to <Objective-C object|pointer> parameters
#         A attribute only applies to <functions|methods> that return <an Objective-C object|a pointer|a non-retainable pointer>
#         A attribute only applies to <functions|unions|variables and functions|functions and methods|parameters|functions, methods and blocks|functions, methods, and classes|functions, methods, and parameters|classes|variables|methods|variables, functions and labels|fields and global variables|structs|variables, functions and tag types|thread-local variables|variables and fields|variables, data members and tag types|types and namespaces>
#         A only applies to variables with static storage duration and functions
#         Objective-C GC does not allow weak variables on the stack
#         __declspec attribute A is not supported
#         __weak attribute cannot be specified on a field declaration
#         __weak attribute cannot be specified on an automatic variable when ARC is not enabled
#         attribute A after definition is ignored
#         attribute A cannot be applied to <functions|Objective-C method> without return value
#         attribute A ignored, because it cannot be applied to a type
#         attribute A ignored, because it is not attached to a declaration
#         attribute A is already applied with different parameters
#         attribute A is ignored, place it after "<class|struct|union|interface|enum>" to apply attribute to type declaration
#         attribute declaration must precede definition
#         calling convention A ignored for this target
#         first field of a transparent union cannot have <floating point|vector> type B; transparent_union attribute ignored
#         ibaction attribute can only be applied to Objective-C instance methods
#         transparent union definition must contain at least one field; transparent_union attribute ignored
#         transparent_union attribute can only be applied to a union definition; attribute ignored
#         unknown attribute 'A'
#         unknown endian 'A'
#         unknown visibility 'A'
#   -Wimplicit-conversion-floating-point-to-bool
#         implicit conversion turns floating-point number into bool: A to B
#   -Wimplicit-exception-spec-mismatch
#         function previously declared with an <explicit|implicit> exception specification redeclared with an <implicit|explicit> exception specification
#   -Wimplicit-fallthrough (partial)
#         fallthrough annotation does not directly precede switch label
#         fallthrough annotation in unreachable code
#   -Wincompatible-library-redeclaration
#         incompatible redeclaration of library function A
#   -Wincompatible-pointer-types
#         incompatible pointer types <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#     -Wincompatible-pointer-types-discards-qualifiers
#           <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types> discards qualifiers
#           <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types> discards qualifiers in nested pointer types
#   -Wincomplete-implementation
#         method definition for A not found
#   -Wincomplete-umbrella
#         missing submodule 'A'
#         umbrella header for module 'A' does not include header 'B'
#   -Winherited-variadic-ctor
#         inheriting constructor does not inherit ellipsis
#   -Wint-conversions
#     -Wint-conversion
#           incompatible integer to pointer conversion <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#           incompatible pointer to integer conversion <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#   -Wint-to-pointer-cast
#         cast to B from smaller integer type A
#   -Winteger-overflow
#         overflow in expression; result is A with type B
#   -Winvalid-constexpr
#         constexpr <function|constructor> never produces a constant expression
#   -Winvalid-iboutlet
#         <instance variable|property> with A attribute must be an object type (invalid B)
#   -Winvalid-noreturn
#         function A declared 'noreturn' should not return
#         function declared 'noreturn' should not return
#   -Winvalid-offsetof
#         offset of on non-POD type A
#         offset of on non-standard-layout type A
#   -Winvalid-pp-token
#         empty character constant
#         missing terminating ' character
#         missing terminating '"' character
#   -Winvalid-source-encoding
#         illegal character encoding in character literal
#         illegal character encoding in string literal
#   -Winvalid-token-paste
#         pasting formed 'A', an invalid preprocessing token
#   -Wknr-promoted-parameter
#         promoted type of K&R function parameter is not compatible with parameter type declared in a previous prototype
#   -Wlarge-by-value-copy
#         A is a large (B bytes) pass-by-value argument; pass it by reference instead ?
#         return value of A is a large (B bytes) pass-by-value object; pass it by reference instead ?
#   -Wlocal-type-template-args (partial)
#         template argument uses local type A
#   -Wmain
#         'main' is not allowed to be declared _Noreturn
#         'main' should not be declared static
#         only one parameter on 'main' declaration
#   -Wmain-return-type
#         return type of 'main' is not 'int'
#   -Wmalformed-warning-check
#         __has_warning expected option name (e.g. "-Wundef")
#   -Wmicrosoft (partial)
#         anonymous structs are a Microsoft extension
#         enumerator value is not representable in the underlying type A
#         exception specification of overriding function is more lax than base version
#         explicit constructor calls are a Microsoft extension
#         explicit specialization of A within class scope is a Microsoft extension
#         extra qualification on member A
#         function definition with pure-specifier is a Microsoft extension
#         goto into protected scope
#         pseudo-destructors on type void are a Microsoft extension
#         use of identifier A found via unqualified lookup into dependent bases of class templates is a Microsoft extension
#         using declaration referring to inaccessible member 'A' (which refers to accessible member 'B') is a Microsoft compatibility extension
#   -Wmicrosoft-exists
#         dependent <__if_not_exists|__if_exists> declarations are ignored
#   -Wmismatched-method-attributes
#         attributes on method implementation and its declaration must match
#   -Wmismatched-parameter-types
#         conflicting parameter types in implementation of A
#   -Wmismatched-return-types
#         conflicting return type in implementation of A
#   -Wmissing-declarations
#         'A' ignored on this declaration
#         'A' is not permitted on a declaration of a type
#         declaration does not declare anything
#         typedef requires a name
#   -Wmissing-selector-name
#         A used as the name of the previous parameter rather than as part of the selector
#   -Wmissing-sysroot
#         no such sysroot directory: 'A'
#   -Wmodule-conflict
#         module 'A' conflicts with already-imported module 'B': C
#   -Wnarrowing (partial)
#     -Wc++11-narrowing (partial)
#           <case value|enumerator value|non-type template argument> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#           constant expression evaluates to A which cannot be narrowed to type B
#           non-constant-expression cannot be narrowed from type A to B in initializer list
#           type A cannot be narrowed to B in initializer list
#   -Wnon-gcc (partial)
#     -Wconversion (partial)
#       -Wbool-conversion
#             address of function A will always evaluate to 'true'
#             initialization of pointer of type A to null from a constant boolean expression
#       -Wconstant-conversion
#             implicit conversion from C to D changes value from A to B
#         -Wbitfield-constant-conversion
#               implicit truncation from C to bitfield changes value from A to B
#       -Wenum-conversion
#             implicit conversion from enumeration type A to different enumeration type B
#       -Wint-conversion
#             incompatible integer to pointer conversion <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#             incompatible pointer to integer conversion <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#       -Wliteral-conversion
#             implicit conversion from A to B changes value from C to D
#       -Wnon-literal-null-conversion
#             expression which evaluates to zero treated as a null pointer constant of type A
#       -Wnull-conversion
#             implicit conversion of NULL constant to A
#     -Wliteral-range
#           magnitude of floating-point constant too large for type A; maximum is B
#           magnitude of floating-point constant too small for type A; minimum is B
#   -Wnon-pod-varargs
#         cannot pass <non-POD|non-trivial> object of type B to variadic <function|block|method|constructor>; expected type from format string was D
#         cannot pass object of <non-POD|non-trivial> type B through variadic <function|block|method|constructor>; call will abort at runtime
#         second argument to 'va_arg' is of ARC ownership-qualified type A
#         second argument to 'va_arg' is of non-POD type A
#   -WNSObject-attribute
#         __attribute ((NSObject)) may be put on a typedef only, attribute is ignored
#   -Wnull-arithmetic
#         comparison between NULL and non-pointer <(B and NULL)|(NULL and B)>
#         use of NULL in arithmetic operation
#   -Wnull-character
#         null character ignored
#         null character(s) preserved in character literal
#         null character(s) preserved in string literal
#   -Wnull-dereference
#         indirection of non-volatile null pointer will be deleted, not trap
#   -Wobjc-autosynthesis-property-ivar-name-match
#         autosynthesized property A will use [synthesized] instance variable C, not existing instance variable D
#   -Wobjc-cocoa-api
#     -Wobjc-redundant-api-use
#       -Wobjc-redundant-literal-use
#             using A with a literal is redundant
#   -Wobjc-forward-class-redefinition
#         redefinition of forward class A of a typedef name of an object type is ignored
#   -Wobjc-literal-compare
#         direct comparison of [an array literal|a dictionary literal|a numeric literal|a boxed expression] has undefined behavior
#     -Wobjc-string-compare
#           direct comparison of a string literal has undefined behavior
#   -Wobjc-method-access
#         class method A not found (return type defaults to 'id')
#         instance method A found instead of class method B
#         instance method A is being used on 'Class' which is not in the root class
#         instance method A not found (return type defaults to 'id')
#   -Wobjc-noncopy-retain-block-property
#         retain'ed block property does not copy the block - use copy attribute instead
#   -Wobjc-nonunified-exceptions
#         can not catch an exception thrown with @throw in C++ in the non-unified exception model
#   -Wobjc-property-implementation
#         property A requires method B to be defined - use @dynamic or provide a method implementation in this category
#         property A requires method B to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation
#   -Wobjc-property-matches-cocoa-ownership-rule
#         property's synthesized getter follows Cocoa naming convention for returning 'owned' objects
#   -Wobjc-property-no-attribute
#         default property attribute 'assign' not appropriate for non-GC object
#         no 'assign', 'retain', or 'copy' attribute is specified - 'assign' is assumed
#   -Wobjc-property-synthesis
#         auto property synthesis will not synthesize property 'A' because it cannot share an ivar with another synthesized property
#         auto property synthesis will not synthesize property 'A' because it is 'readwrite' but it will be synthesized 'readonly' via another property
#   -Wobjc-protocol-method-implementation
#         category is implementing a method which will also be implemented by its primary class
#   -Wobjc-protocol-property-synthesis
#         auto property synthesis will not synthesize property declared in a protocol
#   -Wobjc-readonly-with-setter-property
#         setter cannot be specified for a readonly property
#   -Wobjc-root-class
#         class A defined without specifying a base class
#   -Wodr
#         type A has incompatible definitions in different translation units
#   -Wout-of-line-declaration
#         out-of-line declaration of a member must be a definition
#   -Wpointer-sign
#         <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types> converts between pointers to integer types with different sign
#   -Wpointer-type-mismatch
#         pointer type mismatch
#   -Wpredefined-identifier-outside-function
#         predefined identifier is only valid inside function
#   -Wprotocol
#         method A in protocol not implemented
#   -Wreadonly-iboutlet-property
#         readonly IBOutlet property 'A' when auto-synthesized may not work correctly with 'nib' loader
#   -Wreceiver-expr
#         receiver type A is not 'id' or interface pointer, consider casting it to 'id'
#   -Wreceiver-forward-class (partial)
#         receiver A is a forward class and corresponding @interface may not exist
#   -Wreinterpret-base-class
#         'reinterpret_cast' <from|to> class A <to|from> its <virtual base|base at non-zero offset> B behaves differently from 'static_cast'
#   -Wrequires-super-attribute
#         A attribute cannot be applied to <methods in protocols|dealloc>
#   -Wreserved-user-defined-literal (partial)
#         invalid suffix on literal; C++11 requires a space between literal and identifier
#   -Wreturn-stack-address
#         address of stack memory associated with local variable A returned
#         reference to stack memory associated with local variable A returned
#         returning address of label, which is local
#         returning address of local temporary object
#         returning reference to local temporary object
#   -Wsection
#         section does not match previous declaration
#   -Wsentinel
#         missing sentinel in <function call|method dispatch|block call>
#         not enough variable arguments in A declaration to fit a sentinel
#   -Wsequence-point
#     -Wunsequenced
#           multiple unsequenced modifications to A
#           unsequenced modification and access to A
#   -Wserialized-diagnostics
#         unable to open file A for serializing diagnostics (B)
#   -Wshadow-ivar
#         local declaration of A hides instance variable
#   -Wshift-count-negative
#         shift count is negative
#   -Wshift-count-overflow
#         shift count >= width of type
#   -Wshift-overflow
#         signed shift result (A) requires B bits to represent, but C only has D bits
#   -Wsizeof-pointer-memaccess
#         'A' call operates on objects of type B while the size is based on a different type C
#         argument to 'sizeof' in A call is the same pointer type B as the <destination|source>; expected D or an explicit length
#   -Wstatic-float-init
#         in-class initializer for static data member of type A requires 'constexpr' specifier
#     -Wgnu-static-float-init
#           in-class initializer for static data member of type A is a GNU extension
#   -Wstatic-in-inline (partial)
#         static <function|variable> B is used in an inline function with external linkage
#   -Wstatic-local-in-inline
#         non-constant static local variable in inline function may be different in different files
#   -Wstring-compare
#         result of comparison against <a string literal|@encode> is unspecified (use strncmp instead)
#   -Wstrlcpy-strlcat-size
#         size argument in A call appears to be size of the source; expected the size of the destination
#   -Wstrncat-size
#         size argument in 'strncat' call appears to be size of the source
#         the value of the size argument in 'strncat' is too large, might lead to a buffer overflow
#         the value of the size argument to 'strncat' is wrong
#   -Wtautological-compare
#         <self-|array >comparison always evaluates to <false|true|a constant>
#         comparison of A unsigned[ enum] expression is always B
#         comparison of unsigned[ enum] expression A is always B
#     -Wtautological-constant-out-of-range-compare
#           comparison of constant A with expression of type B is always <false|true>
#   -Wtentative-definition-incomplete-type
#         tentative definition of variable with internal linkage has incomplete non-array type A
#   -Wtype-safety
#         argument type A doesn't match specified 'B' type tag [that requires D]
#         specified A type tag requires a null pointer
#         this type tag was not designed to be used with this function
#   -Wtypedef-redefinition
#         redefinition of typedef A is a C11 feature
#   -Wtypename-missing
#         missing 'typename' prior to dependent type name 'AB'
#   -Wundefined-inline
#         inline function A is not defined
#   -Wundefined-internal
#         <function|variable> B has internal linkage but is not defined
#   -Wunicode
#         \A used with no following hex digits; treating as '\' followed by identifier
#         incomplete universal character name; treating as '\' followed by identifier
#         universal character name refers to a surrogate character
#         universal character names are only valid in C99 or C++
#         universal character names are only valid in C99 or C++; treating as '\' followed by identifier
#   -Wunicode-whitespace
#         treating Unicode character as whitespace
#   -Wunknown-warning-option
#         unknown A warning specifier: 'B'
#         unknown warning option 'A'
#         unknown warning option 'A'; did you mean 'B'?
#   -Wunnamed-type-template-args (partial)
#         template argument uses unnamed type
#   -Wunsupported-visibility
#         target does not support 'protected' visibility; using 'default'
#   -Wunused-command-line-argument
#         A: 'B' input unused in cpp mode
#         A: 'B' input unused[ when 'D' is present]
#         A: previously preprocessed input[ unused when 'C' is present]
#         argument unused during compilation: 'A'
#         joined argument expects additional value: 'A'
#     -Wunused-sanitize-argument
#           'A' is ignored in absence of 'B'
#   -Wunused-volatile-lvalue
#         expression result unused; assign into a variable to force a volatile load
#   -Wuser-defined-literals
#         user-defined literal suffixes not starting with '_' are reserved; no literal will invoke this operator
#   -Wvexing-parse
#         empty parentheses interpreted as a function declaration
#         parentheses were disambiguated as a function declaration
#   -Wvisibility
#         declaration of A will not be visible outside of this function
#         redefinition of A will not be visible outside of this function
#   -Wwrite-strings
#     -Wdeprecated-writable-strings
#           conversion from string literal to A is deprecated
-W
#   -Wextra
#     -Wignored-qualifiers
#           'A' type qualifier(s) on return type <has|have> no effect
#           ARC <unused|__unsafe_unretained|__strong|__weak|__autoreleasing> lifetime qualifier on return type is ignored
#     -Winitializer-overrides
#           initializer overrides prior initialization of this subobject
#           subobject initialization overrides initialization of other fields within its enclosing subobject
#     -Wmissing-field-initializers
#           missing field 'A' initializer
#     -Wmissing-method-return-type
#           method has no return type specified; defaults to 'id'
#     -Wsemicolon-before-method-body
#           semicolon before method body is ignored
#     -Wsign-compare
#           comparison of integers of different signs: A and B
#     -Wunused-parameter
#           unused parameter A
-Wabi # DUMMY switch
-Waddress # DUMMY switch
-Waggregate-return # DUMMY switch
-Wall
#   -Wmost
#     -Wcast-of-sel-type
#           cast of type A to B is deprecated; use sel_getName instead
#     -Wchar-subscripts
#           array subscript is of type 'char'
#     -Wcomment
#           '/*' within block comment
#           // comments are not allowed in this language
#           escaped newline between */ characters at block comment end
#           multi-line // comment
#     -Wdelete-non-virtual-dtor
#           delete called on A that has virtual functions but non-virtual destructor
#           delete called on A that is abstract but has non-virtual destructor
#     -Wformat
#           '<*|.*>' specified field <width|precision> is missing a matching 'int' argument
#           <field width|precision> used with 'B' conversion specifier, resulting in undefined behavior
#           cannot mix positional and non-positional arguments in format string
#           data argument position 'A' exceeds the number of data arguments (B)
#           field <width|precision> should have type B, but argument has type C
#           flag 'A' is ignored when flag 'B' is present
#           flag 'A' results in undefined behavior with 'B' conversion specifier
#           format specifies type A but the argument has type B
#           format string contains '\0' within the string body
#           format string missing
#           format string should not be a wide string
#           incomplete format specifier
#           invalid position specified for <field width|field precision>
#           length modifier 'A' results in undefined behavior or no effect with 'B' conversion specifier
#           more '%' conversions than data arguments
#           no closing ']' for '%[' in scanf format string
#           position arguments in format strings start counting at 1 (not 0)
#           values of type 'A' should not be used as format arguments; add an explicit cast to B instead
#           zero field width in scanf format string is unused
#       -Wformat-extra-args
#             data argument not used by format string
#       -Wformat-invalid-specifier
#             invalid conversion specifier 'A'
#       -Wformat-security
#             format string is not a string literal (potentially insecure)
#       -Wformat-y2k # DUMMY switch
#       -Wformat-zero-length
#             format string is empty
#       -Wnonnull
#             null passed to a callee which requires a non-null argument
#     -Wimplicit
#       -Wimplicit-function-declaration
#             implicit declaration of function A
#             implicit declaration of function A is invalid in C99
#             use of unknown builtin A
#       -Wimplicit-int
#             type specifier missing, defaults to 'int'
#     -Wmismatched-tags
#           <struct|interface|class>[ template] C was previously declared as a <struct|interface|class>[ template]
#           C defined as <a struct|an interface|a class>[ template] here but previously declared as <a struct|an interface|a class>[ template]
#     -Wmissing-braces
#           suggest braces around initialization of subobject
#     -Wmultichar
#           multi-character character constant
#     -Wobjc-missing-super-calls
#           method possibly missing a [super A] call
#     -Woverloaded-virtual
#           A hides overloaded virtual <function|functions>
#     -Wprivate-extern
#           use of __private_extern__ on a declaration may not produce external symbol private to the linkage unit and is deprecated
#     -Wreorder
#           <field|base class> B will be initialized after <field|base> D
#     -Wreturn-type
#           <void function|void method|constructor|destructor> A should not return a value
#           control may reach end of non-void function
#           control may reach end of non-void lambda
#           control reaches end of non-void function
#           control reaches end of non-void lambda
#           non-void <function|method> A should return a value
#       -Wreturn-type-c-linkage
#             A has C-linkage specified, but returns incomplete type B which could be incompatible with C
#             A has C-linkage specified, but returns user-defined type B which is incompatible with C
#     -Wself-assign
#           explicitly assigning a variable of type A to itself
#       -Wself-assign-field
#             assigning <field|instance variable> to itself
#     -Wsizeof-array-argument
#           sizeof on array function parameter will return size of A instead of B
#     -Wsizeof-array-decay
#           sizeof on pointer operation will return size of A instead of B
#     -Wstring-plus-int
#           adding A to a string does not append to the string
#     -Wtrigraphs
#           ignored trigraph would end block comment
#           trigraph converted to 'A' character
#           trigraph ends block comment
#           trigraph ignored
#     -Wuninitialized
#           block pointer variable A is uninitialized when captured by block
#           field A is uninitialized when used here
#           reference A is not yet bound to a value when used here
#           reference A is not yet bound to a value when used within its own initialization
#           variable A is uninitialized when <used here|captured by block>
#           variable A is uninitialized when used within its own initialization
#       -Wsometimes-uninitialized
#             variable A is <used|captured> uninitialized whenever <'D' condition is <true|false>|'D' loop <is entered|exits because its condition is false>|'D' loop <condition is true|exits because its condition is false>|switch D is taken>
#       -Wstatic-self-init
#             static variable A is suspiciously used within its own initialization
#     -Wunknown-pragmas
#           angle-bracketed include <A> cannot be aliased to double-quoted include "B"
#           double-quoted include "A" cannot be aliased to angle-bracketed include <B>
#           expected 'ON' or 'OFF' or 'DEFAULT' in pragma
#           expected end of directive in pragma
#           pragma STDC FENV_ACCESS ON is not supported, ignoring pragma
#           pragma diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'
#           pragma diagnostic expected option name (e.g. "-Wundef")
#           pragma diagnostic pop could not pop, no matching push
#           pragma include_alias expected 'A'
#           pragma include_alias expected include filename
#           unexpected token in pragma diagnostic
#           unknown pragma ignored
#           unknown pragma in STDC namespace
#           unknown warning group 'A', ignored
#     -Wunused
#       -Wunused-argument # DUMMY switch
#       -Wunused-function
#             unused function A
#         -Wunneeded-internal-declaration
#               'static' function A declared in header file should be declared 'static inline'
#               <function|variable> B is not needed and will not be emitted
#       -Wunused-label
#             unused label A
#       -Wunused-private-field
#             private field A is not used
#       -Wunused-value
#             container access result unused - container access should not be used for side effects
#             expression result unused
#             expression result unused; should this cast be to 'void'?
#             ignoring return value of function declared with A attribute
#             property access result unused - getters should not be used for side effects
#         -Wunused-comparison
#               <equality|inequality> comparison result unused
#         -Wunused-result
#               ignoring return value of function declared with warn_unused_result attribute
#       -Wunused-variable
#             unused variable A
#     -Wvolatile-register-var # DUMMY switch
#   -Wparentheses
#         A has lower precedence than B; B will be evaluated first
#         operator '?:' has lower precedence than 'A'; 'A' will be evaluated first
#         using the result of an assignment as a condition without parentheses
#     -Wbitwise-op-parentheses
#           '&' within '|'
#     -Wdangling-else
#           add explicit braces to avoid dangling else
#     -Wlogical-op-parentheses
#           '&&' within '||'
#     -Woverloaded-shift-op-parentheses
#           overloaded operator <>>|<<> has lower precedence than comparison operator
#     -Wparentheses-equality
#           equality comparison with extraneous parentheses
#     -Wshift-op-parentheses
#           operator 'A' has lower precedence than 'B'; 'B' will be evaluated first
#   -Wswitch
#         A enumeration values not handled in switch: B, C, D...
#         case value not in enumerated type A
#         enumeration value A not handled in switch
#         enumeration values A and B not handled in switch
#         enumeration values A, B, and C not handled in switch
#         overflow converting case value to switch condition type (A to B)
-Warc-abi # DUMMY switch
-Warc-repeated-use-of-weak
#     weak <variable|property|implicit property|instance variable> B is accessed multiple times in this <function|method|block|lambda> but may be unpredictably set to nil; assign to a strong variable to keep the object alive
#   -Warc-maybe-repeated-use-of-weak
#         weak <variable|property|implicit property|instance variable> B may be accessed multiple times in this <function|method|block|lambda> and may be unpredictably set to nil; assign to a strong variable to keep the object alive
-Warray-bounds-pointer-arithmetic
#     the pointer decremented by A refers before the beginning of the array
#     the pointer incremented by A refers past the end of the array (that contains B element(s))
-Wassign-enum
#     integer constant not in range of enumerated type A
-Watomic-properties
#   -Wcustom-atomic-properties
#         atomic by default property A has a user defined <getter|setter> (property should be marked 'atomic' if this is intended)
#   -Wimplicit-atomic-properties
#         property is assumed atomic by default
#         property is assumed atomic when auto-synthesizing the property
-Wauto-import
#     treating #<include|import|include_next|__include_macros> as an import of module 'B'
-Wbad-function-cast
#     cast from function call of type A to non-matching type B
-Wbind-to-temporary-copy
#     C++98 requires an accessible copy constructor for class C when binding a reference to a temporary; was <private|protected>
#     no viable constructor <copying variable|copying parameter|returning object|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value> of type B; C++98 requires a copy constructor when binding a reference to a temporary
#   -Wc++98-compat-bind-to-temporary-copy
#         <copying variable|copying parameter|returning object|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element> of type C when binding a reference to a temporary would <invoke an inaccessible constructor|find no viable constructor|find ambiguous constructors|invoke a deleted constructor> in C++98
-Wc++-compat
#     empty <struct|union> has size 0 in C, size 1 in C++
-Wc++0x-compat
#   -Wc++11-compat
#         'A' is a keyword in C++11
#         'auto' storage class specifier is redundant and incompatible with C++11
#         explicit instantiation cannot be 'inline'
#         explicit instantiation of A must occur at global scope
#         explicit instantiation of A must occur in namespace B
#         explicit instantiation of A not in a namespace enclosing B
#         identifier after literal will be treated as a user-defined literal suffix in C++11
#         use of right-shift operator ('>>') in template argument will require parentheses in C++11
#     -Wc++11-compat-reserved-user-defined-literal
#           identifier after literal will be treated as a reserved user-defined literal suffix in C++11
#     -Wc++11-narrowing
#           <case value|enumerator value|non-type template argument> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#           constant expression evaluates to A which cannot be narrowed to type B
#           constant expression evaluates to A which cannot be narrowed to type B in C++11
#           non-constant-expression cannot be narrowed from type A to B in initializer list
#           non-constant-expression cannot be narrowed from type A to B in initializer list in C++11
#           type A cannot be narrowed to B in initializer list
#           type A cannot be narrowed to B in initializer list in C++11
#     -Wcxx98-cxx11-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++1y
#           constexpr function with no return statements is incompatible with C++ standards before C++1y
#           multiple return statements in constexpr function is incompatible with C++ standards before C++1y
#           type definition in a constexpr <function|constructor> is incompatible with C++ standards before C++1y
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++1y
#           variable declaration in a constexpr <function|constructor> is incompatible with C++ standards before C++1y
-Wc++0x-extensions
#   -Wc++11-extensions
#         'A' keyword is a C++11 extension
#         'auto' type specifier is a C++11 extension
#         'template' keyword outside of a template
#         'typename' occurs outside of a template
#         alias declarations are a C++11 extension
#         commas at the end of enumerator lists are a C++11 extension
#         default template arguments for a function template are a C++11 extension
#         defaulted function definitions are a C++11 extension
#         deleted function definitions are a C++11 extension
#         enumeration types with a fixed underlying type are a C++11 extension
#         explicit conversion functions are a C++11 extension
#         explicit instantiation of A that occurs after an explicit specialization will be ignored (C++11 extension)
#         extern templates are a C++11 extension
#         first declaration of <class template|class template partial|function template|member function|static data member|member class|member enumeration> specialization of B outside namespace C is a C++11 extension
#         generalized initializer lists are a C++11 extension
#         implicit conversion from array size expression of type A to <integral|enumeration> type C is a C++11 extension
#         in-class initialization of non-static data member is a C++11 extension
#         inline namespaces are a C++11 feature
#         non-class friend type A is a C++11 extension
#         non-type template argument referring to <function|object> B with internal linkage is a C++11 extension
#         range-based for loop is a C++11 extension
#         reference qualifiers on functions are a C++11 extension
#         rvalue references are a C++11 extension
#         scoped enumerations are a C++11 extension
#         static data member A in union is a C++11 extension
#         unelaborated friend declaration is a C++11 extension; specify '<struct|interface|union|class|enum>' to befriend B
#         variadic templates are a C++11 extension
#     -Wc++11-extra-semi
#           extra ';' outside of a function is a C++11 extension
#     -Wc++11-long-long
#           'long long' is a C++11 extension
-Wc++0x-narrowing
#   -Wc++11-narrowing
#         <case value|enumerator value|non-type template argument> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#         constant expression evaluates to A which cannot be narrowed to type B
#         constant expression evaluates to A which cannot be narrowed to type B in C++11
#         non-constant-expression cannot be narrowed from type A to B in initializer list
#         non-constant-expression cannot be narrowed from type A to B in initializer list in C++11
#         type A cannot be narrowed to B in initializer list
#         type A cannot be narrowed to B in initializer list in C++11
-Wc++11-compat-pedantic
#   -Wcxx98-cxx11-compat-pedantic
#         arrays of runtime bound are incompatible with C++ standards before C++1y
#         binary integer literals are incompatible with C++ standards before C++1y
#     -Wcxx98-cxx11-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++1y
#           constexpr function with no return statements is incompatible with C++ standards before C++1y
#           multiple return statements in constexpr function is incompatible with C++ standards before C++1y
#           type definition in a constexpr <function|constructor> is incompatible with C++ standards before C++1y
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++1y
#           variable declaration in a constexpr <function|constructor> is incompatible with C++ standards before C++1y
-Wc++1y-extensions
#     'decltype(auto)' type specifier is a C++1y extension
#     binary integer literals are a C++1y extension
#     multiple return statements in constexpr function is a C++1y extension
#     type definition in a constexpr <function|constructor> is a C++1y extension
#     use of this statement in a constexpr <function|constructor> is a C++1y extension
#     variable declaration in a constexpr <function|constructor> is a C++1y extension
-Wc++98-compat-pedantic
#     #line number greater than 32767 is incompatible with C++98
#     'long long' is incompatible with C++98
#     C++98 requires newline at end of file
#     cast between pointer-to-function and pointer-to-object is incompatible with C++98
#     commas at the end of enumerator lists are incompatible with C++98
#     empty macro arguments are incompatible with C++98
#     explicit instantiation of A that occurs after an explicit specialization is incompatible with C++98
#     extern templates are incompatible with C++98
#     extra ';' outside of a function is incompatible with C++98
#     implicit conversion from array size expression of type A to <integral|enumeration> type C is incompatible with C++98
#     variadic macros are incompatible with C++98
#   -Wc++98-compat
#         '<::' is treated as digraph '<:' (aka '[') followed by ':' in C++98
#         'A' keyword is incompatible with C++98
#         'A' type specifier is incompatible with C++98
#         'alignas' is incompatible with C++98
#         'auto' type specifier is incompatible with C++98
#         'constexpr' specifier is incompatible with C++98
#         'decltype' type specifier is incompatible with C++98
#         'nullptr' is incompatible with C++98
#         <anonymous struct|union> member B with a non-trivial <constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor> is incompatible with C++98
#         <class template|class template partial|function template|member function|static data member|member class|member enumeration> specialization of B outside namespace C is incompatible with C++98
#         alias declarations are incompatible with C++98
#         alignof expressions are incompatible with C++98
#         attributes are incompatible with C++98
#         befriending B without '<struct|interface|union|class|enum>' keyword is incompatible with C++98
#         befriending enumeration type A is incompatible with C++98
#         consecutive right angle brackets are incompatible with C++98 (use '> >')
#         constructor call from initializer list is incompatible with C++98
#         default template arguments for a function template are incompatible with C++98
#         defaulted function definitions are incompatible with C++98
#         delegating constructors are incompatible with C++98
#         deleted function definitions are incompatible with C++98
#         enumeration type in nested name specifier is incompatible with C++98
#         enumeration types with a fixed underlying type are incompatible with C++98
#         explicit conversion functions are incompatible with C++98
#         friend declaration naming a member of the declaring class is incompatible with C++98
#         friend function A would be implicitly redefined in C++98
#         generalized initializer lists are incompatible with C++98
#         goto would jump into protected scope in C++98
#         in-class initialization of non-static data members is incompatible with C++98
#         indirect goto might cross protected scopes in C++98
#         inheriting constructors are incompatible with C++98
#         initialization of initializer_list object is incompatible with C++98
#         inline namespaces are incompatible with C++98
#         lambda expressions are incompatible with C++98
#         literal operators are incompatible with C++98
#         noexcept expressions are incompatible with C++98
#         noexcept specifications are incompatible with C++98
#         non-class friend type A is incompatible with C++98
#         non-type template argument referring to <function|object> B with internal linkage is incompatible with C++98
#         passing object of trivial but non-POD type A through variadic <function|block|method|constructor> is incompatible with C++98
#         range-based for loop is incompatible with C++98
#         raw string literals are incompatible with C++98
#         redundant parentheses surrounding address non-type template argument are incompatible with C++98
#         reference initialized from initializer list is incompatible with C++98
#         reference qualifiers on functions are incompatible with C++98
#         rvalue references are incompatible with C++98
#         scalar initialized from empty initializer list is incompatible with C++98
#         scoped enumerations are incompatible with C++98
#         specifying character 'A' with a universal character name is incompatible with C++98
#         static data member A in union is incompatible with C++98
#         static_assert declarations are incompatible with C++98
#         substitution failure due to access control is incompatible with C++98
#         switch case would be in a protected scope in C++98
#         trailing return types are incompatible with C++98
#         unicode literals are incompatible with C++98
#         universal character name referring to a control character is incompatible with C++98
#         use of 'template' keyword outside of a template is incompatible with C++98
#         use of 'typename' outside of a template is incompatible with C++98
#         use of non-static data member A in an unevaluated context is incompatible with C++98
#         use of null pointer as non-type template argument is incompatible with C++98
#         using this character in an identifier is incompatible with C++98
#         variadic templates are incompatible with C++98
#     -Wc++98-compat-bind-to-temporary-copy
#           <copying variable|copying parameter|returning object|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element> of type C when binding a reference to a temporary would <invoke an inaccessible constructor|find no viable constructor|find ambiguous constructors|invoke a deleted constructor> in C++98
#     -Wc++98-compat-local-type-template-args
#           local type A as template argument is incompatible with C++98
#     -Wc++98-compat-unnamed-type-template-args
#           unnamed type as template argument is incompatible with C++98
#     -Wcxx98-cxx11-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++1y
#           constexpr function with no return statements is incompatible with C++ standards before C++1y
#           multiple return statements in constexpr function is incompatible with C++ standards before C++1y
#           type definition in a constexpr <function|constructor> is incompatible with C++ standards before C++1y
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++1y
#           variable declaration in a constexpr <function|constructor> is incompatible with C++ standards before C++1y
#   -Wcxx98-cxx11-compat-pedantic
#         arrays of runtime bound are incompatible with C++ standards before C++1y
#         binary integer literals are incompatible with C++ standards before C++1y
#     -Wcxx98-cxx11-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++1y
#           constexpr function with no return statements is incompatible with C++ standards before C++1y
#           multiple return statements in constexpr function is incompatible with C++ standards before C++1y
#           type definition in a constexpr <function|constructor> is incompatible with C++ standards before C++1y
#           use of this statement in a constexpr <function|constructor> is incompatible with C++ standards before C++1y
#           variable declaration in a constexpr <function|constructor> is incompatible with C++ standards before C++1y
-Wc11-extensions
#     A is a C11-specific feature
#     _Noreturn functions are a C11-specific feature
#     _Static_assert is a C11-specific feature
#     anonymous structs are a C11 extension
#     anonymous unions are a C11 extension
#     generic selections are a C11-specific feature
-Wc99-compat
#     <using this character in an identifier|starting an identifier with this character> is incompatible with C99
#     unicode literals are incompatible with C99
-Wc99-extensions
#     Flexible array members are a C99-specific feature
#     ISO C99 requires whitespace after the macro name
#     [qualifier in |static ]array size ['[*] ']is a C99 feature
#     commas at the end of enumerator lists are a C99-specific feature
#     compound literals are a C99-specific feature
#     designated initializers are a C99 feature
#     empty macro arguments are a C99 feature
#     hexadecimal floating constants are a C99 feature
#     variable declaration in for loop is a C99-specific feature
-Wcast-align
#     cast from A to B increases required alignment from C to D
-Wcast-qual # DUMMY switch
-Wchar-align # DUMMY switch
-Wcomments
#   -Wcomment
#         '/*' within block comment
#         // comments are not allowed in this language
#         escaped newline between */ characters at block comment end
#         multi-line // comment
-Wcomplex-component-init
#     complex initialization specifying real and imaginary components is an extension
-Wconditional-uninitialized
#     variable A may be uninitialized when <used here|captured by block>
-Wcovered-switch-default
#     default label in switch which covers all enumeration values
-Wctor-dtor-privacy # DUMMY switch
-Wdeclaration-after-statement
#     ISO C90 forbids mixing declarations and code
-Wdeprecated-implementations
#     Implementing deprecated <method|class|category>
-Wdirect-ivar-access
#     instance variable A is being directly accessed
-Wdisabled-macro-expansion
#     disabled expansion of recursive macro
-Wdisabled-optimization # DUMMY switch
-Wdiscard-qual # DUMMY switch
-Wdiv-by-zero # DUMMY switch
-Wdocumentation
#     '<\|@><classdesign|coclass|dependency|helper|helperclass|helps|instancesize|ownership|performance|security|superclass>' command should not be used in a comment attached to a non-container declaration
#     '<\|@><class|interface|protocol|struct|union>' command should not be used in a comment attached to a non-<class|interface|protocol|struct|union> declaration
#     '<\|@><function|functiongroup|method|methodgroup|callback>' command should be used in a comment attached to <a function|an Objective-C method|a pointer to function> declaration
#     '<\|@>B' command does not terminate a verbatim text block
#     '<\|@>B' command used in a comment that is attached to a <function returning void|constructor|destructor|method returning void>
#     '<\|@>B' command used in a comment that is not attached to a function or method declaration
#     '<\|@>param' command used in a comment that is not attached to a function declaration
#     '<\|@>tparam' command used in a comment that is not attached to a template declaration
#     HTML start tag prematurely ended, expected attribute name or '>'
#     duplicated command '<\|@>B'
#     empty paragraph passed to '<\|@>B' command
#     expected quoted string after equals sign
#     not a Doxygen trailing comment
#     parameter 'A' is already documented
#     parameter 'A' not found in the function declaration
#     template parameter 'A' is already documented
#     template parameter 'A' not found in the template declaration
#     unrecognized parameter passing direction, valid directions are '[in]', '[out]' and '[in,out]'
#   -Wdocumentation-deprecated-sync
#         declaration is marked with '\deprecated' command but does not have a deprecation attribute
#   -Wdocumentation-html
#         HTML end tag 'A' is forbidden
#         HTML end tag does not match any start tag
#         HTML start tag 'A' closed by 'B'
-Wdocumentation-pedantic
#     whitespace is not allowed in parameter passing direction
#   -Wdocumentation-unknown-command
#         unknown command tag name
-Wdollar-in-identifier-extension
#     '$' in identifier
-Wduplicate-enum
#     element A has been implicitly assigned B which another element has been assigned
-Wduplicate-method-arg
#     redeclaration of method parameter A
-Wduplicate-method-match
#     multiple declarations of method A found and ignored
-Weffc++ # DUMMY switch
-Wembedded-directive
#     embedding a directive within macro arguments has undefined behavior
-Wempty-translation-unit
#     ISO C requires a translation unit to contain at least one declaration
-Wexit-time-destructors
#     declaration requires an exit-time destructor
-Wexplicit-ownership-type
#     method parameter of type A with no explicit ownership
-Wextended-offsetof
#     using extended field designator is an extension
-Wextra-semi
#     extra ';' <outside of a function|inside a B|inside instance variable list|after member function definition>
#     extra ';' after member function definition
#   -Wc++11-extra-semi
#         extra ';' outside of a function is a C++11 extension
-Wflexible-array-extensions
#     A may not be nested in a struct due to flexible array member
#     A may not be used as an array element due to flexible array member
-Wfloat-equal
#     comparing floating point with == or != is unsafe
-Wformat-non-iso
#     'A' <length modifier|conversion specifier> is not supported by ISO C
#     positional arguments are not supported by ISO C
#     using length modifier 'A' with conversion specifier 'B' is not supported by ISO C
-Wformat=2
#   -Wformat-nonliteral
#         format string is not a string literal
#     -Wformat-security
#           format string is not a string literal (potentially insecure)
#   -Wformat-security
#         format string is not a string literal (potentially insecure)
#   -Wformat-y2k # DUMMY switch
-Wfour-char-constants
#     multi-character character constant
-Wglobal-constructors
#     declaration requires a global constructor
#     declaration requires a global destructor
-Wgnu
#     #line directive with zero argument is a GNU extension
#     A applied to an expression is a GNU extension
#     anonymous structs are a GNU extension
#     binary integer literals are a GNU extension
#     cast to union type is a GNU extension
#     complex integer types are a GNU extension
#     empty <struct|union> is a GNU extension
#     expression is not an <integer|integral> constant expression; folding it to a constant is a GNU extension
#     field A with variable sized type B not at the end of a struct or class is a GNU extension
#     flexible array initialization is a GNU extension
#     flexible array member A in a union is a GNU extension
#     flexible array member A in otherwise empty <struct|interface|union|class|enum> is a GNU extension
#     imaginary constants are a GNU extension
#     in-class initializer for static data member is not a constant expression; folding it to a constant is a GNU extension
#     initialization of an array from a compound literal is a GNU extension
#     must specify at least one argument for '...' parameter of variadic macro
#     redeclaration of already-defined enum A is a GNU extension
#     token pasting of ',' and __VA_ARGS__ is a GNU extension
#     use of GNU ?: expression extension, eliding middle term
#     use of GNU address-of-label extension
#     use of GNU case range extension
#     use of GNU empty initializer extension
#     use of GNU indirect-goto extension
#     use of GNU locally declared label extension
#     use of GNU statement expression extension
#   -Wgnu-designator
#         use of GNU 'missing =' extension in designator
#         use of GNU array range extension
#         use of GNU old-style field designator extension
#   -Wgnu-static-float-init
#         in-class initializer for static data member of type A is a GNU extension
#   -Wvla-extension
#         variable length arrays are a C99 feature
#   -Wzero-length-array
#         zero size arrays are an extension
-Wheader-hygiene
#     using namespace directive in global context in header
-Widiomatic-parentheses
#     using the result of an assignment as a condition without parentheses
-Wimplicit-fallthrough
#     fallthrough annotation does not directly precede switch label
#     fallthrough annotation in unreachable code
#     unannotated fall-through between switch labels
#   -Wimplicit-fallthrough-per-function
#         unannotated fall-through between switch labels in partly-annotated function
-Wimplicit-retain-self
#     block implicitly retains 'self'; explicitly mention 'self' to indicate this is intended behavior
-Wimport # DUMMY switch
-Wimport-preprocessor-directive-pedantic
#     #import is a language extension
-Winit-self # DUMMY switch
-Winline # DUMMY switch
-Winvalid-pch # DUMMY switch
-Wlanguage-extension-token
#     extension used
-Wlocal-type-template-args
#     template argument uses local type A
#   -Wc++98-compat-local-type-template-args
#         local type A as template argument is incompatible with C++98
-Wlong-long
#     'long long' is an extension when C99 mode is not enabled
#   -Wc++11-long-long
#         'long long' is a C++11 extension
-Wloop-analysis
#     variable<s| B|s B and C|s B, C, and D|s B, C, D, and E> used in loop condition not modified in loop body
-Wmethod-signatures
#     conflicting parameter types in implementation of A: B vs C
#     conflicting return type in implementation of A: B vs C
-Wmicrosoft
#     anonymous structs are a Microsoft extension
#     charizing operator #@ is a Microsoft extension
#     enumeration types with a fixed underlying type are a Microsoft extension
#     enumerator value is not representable in the underlying type A
#     exception specification of '...' is a Microsoft extension
#     exception specification of overriding function is more lax than base version
#     explicit constructor calls are a Microsoft extension
#     explicit specialization of A within class scope is a Microsoft extension
#     extra qualification on member A
#     flexible array member A in a union is a Microsoft extension
#     flexible array member A in otherwise empty <struct|interface|union|class|enum> is a Microsoft extension
#     forward references to 'enum' types are a Microsoft extension
#     function definition with pure-specifier is a Microsoft extension
#     goto into protected scope
#     pseudo-destructors on type void are a Microsoft extension
#     types declared in an anonymous <struct|union> are a Microsoft extension
#     use of identifier A found via unqualified lookup into dependent bases of class templates is a Microsoft extension
#     using declaration referring to inaccessible member 'A' (which refers to accessible member 'B') is a Microsoft compatibility extension
-Wmissing-format-attribute # DUMMY switch
-Wmissing-include-dirs # DUMMY switch
-Wmissing-noreturn
#     <function|method> B could be declared with attribute 'noreturn'
#     block could be declared with attribute 'noreturn'
-Wmissing-prototypes
#     no previous prototype for function A
-Wmissing-variable-declarations
#     no previous extern declaration for non-static variable A
-Wnarrowing
#   -Wc++11-narrowing
#         <case value|enumerator value|non-type template argument> <cannot be narrowed from type C to D|evaluates to C, which cannot be narrowed to type D>
#         constant expression evaluates to A which cannot be narrowed to type B
#         constant expression evaluates to A which cannot be narrowed to type B in C++11
#         non-constant-expression cannot be narrowed from type A to B in initializer list
#         non-constant-expression cannot be narrowed from type A to B in initializer list in C++11
#         type A cannot be narrowed to B in initializer list
#         type A cannot be narrowed to B in initializer list in C++11
-Wnested-anon-types
#     anonymous types declared in an anonymous <struct|union> are an extension
-Wnested-externs # DUMMY switch
-Wnewline-eof
#     no newline at end of file
-Wnon-gcc
#   -Wconversion
#         implicit conversion discards imaginary component: A to B
#         implicit conversion loses floating-point precision: A to B
#         implicit conversion loses integer precision: A to B
#         implicit conversion turns floating-point number into integer: A to B
#         implicit conversion turns vector to scalar: A to B
#         non-type template argument value 'A' truncated to 'B' for template parameter of type C
#         non-type template argument with value 'A' converted to 'B' for unsigned template parameter of type C
#     -Wbool-conversion
#           address of function A will always evaluate to 'true'
#           initialization of pointer of type A to null from a constant boolean expression
#     -Wconstant-conversion
#           implicit conversion from C to D changes value from A to B
#       -Wbitfield-constant-conversion
#             implicit truncation from C to bitfield changes value from A to B
#     -Wenum-conversion
#           implicit conversion from enumeration type A to different enumeration type B
#     -Wint-conversion
#           incompatible integer to pointer conversion <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#           incompatible pointer to integer conversion <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>[; dereference with *|; take the address with &|; remove *|; remove &]
#     -Wliteral-conversion
#           implicit conversion from A to B changes value from C to D
#     -Wnon-literal-null-conversion
#           expression which evaluates to zero treated as a null pointer constant of type A
#     -Wnull-conversion
#           implicit conversion of NULL constant to A
#     -Wshorten-64-to-32
#           implicit conversion loses integer precision: A to B
#     -Wsign-conversion
#           implicit conversion changes signedness: A to B
#           operand of ? changes signedness: A to B
#     -Wstring-conversion
#           implicit conversion turns string literal into bool: A to B
#   -Wliteral-range
#         magnitude of floating-point constant too large for type A; maximum is B
#         magnitude of floating-point constant too small for type A; minimum is B
#   -Wsign-compare
#         comparison of integers of different signs: A and B
-Wnon-virtual-dtor
#     A has virtual functions but non-virtual destructor
-Wnonportable-cfstrings # DUMMY switch
-Wobjc-interface-ivars
#     declaration of instance variables in the interface is deprecated
-Wobjc-missing-property-synthesis
#     auto property synthesis is synthesizing property not explicitly synthesized
-Wold-style-cast # DUMMY switch
-Wold-style-definition # DUMMY switch
-Wover-aligned
#     type A requires B bytes of alignment and the default allocator only guarantees C bytes
-Woverflow # DUMMY switch
-Woverlength-strings
#     string literal of length A exceeds maximum length B that <C90|ISO C99|C++> compilers are required to support
-Woverriding-method-mismatch
#     conflicting distributed object modifiers on parameter type in declaration of A
#     conflicting distributed object modifiers on return type in declaration of A
#     conflicting parameter types in declaration of A
#     conflicting parameter types in declaration of A: B vs C
#     conflicting return type in declaration of A
#     conflicting return type in declaration of A: B vs C
#     conflicting variadic declaration of method and its implementation
-Wpacked
#     packed attribute is unnecessary for A
-Wpadded
#     padding <struct|interface|class> B with C <byte|bit>[s] to align F
#     padding <struct|interface|class> B with C <byte|bit>[s] to align anonymous bit-field
#     padding size of A with B <byte|bit>[s] to alignment boundary
-Wpedantic # DUMMY switch
-Wpointer-arith
#     arithmetic on[ a] pointer[s] to void is a GNU extension
#     arithmetic on[ a] pointer[s] to[ the] function type[s] B[ and D] is a GNU extension
#     invalid application of '<sizeof|alignof|vec_step>' to a function type
#     invalid application of '<sizeof|alignof|vec_step>' to a void type
#     subscript of a pointer to void is a GNU extension
-Wpointer-to-int-cast # DUMMY switch
-Wreadonly-setter-attrs
#     property attributes 'A' and 'B' are mutually exclusive
-Wreceiver-forward-class
#     receiver A is a forward class and corresponding @interface may not exist
#     receiver type A for instance message is a forward declaration
-Wreceiver-is-weak
#     weak <receiver|property|implicit property> may be unpredictably set to nil
-Wredundant-decls # DUMMY switch
-Wreserved-user-defined-literal
#     invalid suffix on literal; C++11 requires a space between literal and identifier
#   -Wc++11-compat-reserved-user-defined-literal
#         identifier after literal will be treated as a reserved user-defined literal suffix in C++11
-Wselector
#     unimplemented selector A
-Wshadow
#     declaration shadows a <local variable|variable in C|static data member of C|field of C>
-Wshift-sign-overflow
#     signed shift result (A) sets the sign bit of the shift expression's type (B) and becomes negative
-Wsign-promo # DUMMY switch
-Wsource-uses-openmp
#     unexpected '#pragma omp ...' in program
-Wstack-protector # DUMMY switch
-Wstatic-in-inline
#     static <function|variable> B is used in an inline function with external linkage
-Wstrict-aliasing # DUMMY switch
-Wstrict-aliasing=0 # DUMMY switch
-Wstrict-aliasing=1 # DUMMY switch
-Wstrict-aliasing=2 # DUMMY switch
-Wstrict-overflow # DUMMY switch
-Wstrict-overflow=0 # DUMMY switch
-Wstrict-overflow=1 # DUMMY switch
-Wstrict-overflow=2 # DUMMY switch
-Wstrict-overflow=3 # DUMMY switch
-Wstrict-overflow=4 # DUMMY switch
-Wstrict-overflow=5 # DUMMY switch
-Wstrict-prototypes # DUMMY switch
-Wstrict-selector-match
#     multiple methods named A found
-Wsuper-class-method-mismatch
#     method parameter type does not match super class method parameter type
-Wswitch-default # DUMMY switch
-Wswitch-enum
#     A enumeration values not explicitly handled in switch: B, C, D...
#     enumeration value A not explicitly handled in switch
#     enumeration values A and B not explicitly handled in switch
#     enumeration values A, B, and C not explicitly handled in switch
-Wsynth # DUMMY switch
-Wthread-safety
#   -Wthread-safety-analysis
#         <reading|writing> the value pointed to by 'A' requires locking <'B'|'B' exclusively>
#         <reading|writing> the value pointed to by 'A' requires locking <any mutex|any mutex exclusively>
#         <reading|writing> variable 'A' requires locking <'B'|'B' exclusively>
#         <reading|writing> variable 'A' requires locking <any mutex|any mutex exclusively>
#         calling function 'A' requires <shared|exclusive> lock on 'B'
#         cannot call function 'A' while mutex 'B' is locked
#         cannot resolve lock expression
#         expecting mutex 'A' to be locked at start of each loop
#         expecting mutex 'A' to be locked at the end of function
#         locking 'A' that is already locked
#         mutex 'A' is locked exclusively and shared in the same scope
#         mutex 'A' is not locked on every path through here
#         mutex 'A' is still locked at the end of function
#         unlocking 'A' that was not locked
#   -Wthread-safety-attributes
#         'A' only applies to pointer types; type here is B
#         A attribute can only be applied in a context annotated with 'lockable' attribute
#         A attribute only applies to <fields and global variables|functions and methods|classes and structs>
#         A attribute requires arguments that are class type or point to class type; type here is 'B'
#         A attribute requires arguments whose type is annotated with 'lockable' attribute; type here is 'B'
#         ignoring A attribute because its argument is invalid
#   -Wthread-safety-precise
#         <reading|writing> the value pointed to by 'A' requires locking <'B'|'B' exclusively>
#         <reading|writing> variable 'A' requires locking <'B'|'B' exclusively>
#         calling function 'A' requires <shared|exclusive> lock on 'B'
-Wthread-safety-beta
#     Thread safety beta warning.
-Wtype-limits # DUMMY switch
-Wundeclared-selector
#     undeclared selector A
-Wundef
#     A is not defined, evaluates to 0
-Wundefined-reinterpret-cast
#     dereference of type B that was reinterpret_cast from type A has undefined behavior
#     reinterpret_cast from A to B has undefined behavior
-Wunnamed-type-template-args
#     template argument uses unnamed type
#   -Wc++98-compat-unnamed-type-template-args
#         unnamed type as template argument is incompatible with C++98
-Wunreachable-code
#     will never be executed
-Wunused-exception-parameter
#     unused exception parameter A
-Wunused-macros
#     macro is not used
-Wunused-member-function
#     unused member function A
#   -Wunneeded-member-function
#         member function A is not needed and will not be emitted
-Wused-but-marked-unused
#     A was marked unused but was used
-Wvariadic-macros
#     named variadic macros are a GNU extension
#     variadic macros are a C99 feature
-Wvector-conversions
#   -Wvector-conversion
#         incompatible vector types <assigning to different types|passing to parameter of different type|returning from function with different return type|converting between types|initializing with expression of different type|sending to parameter of different type|casting between types>
-Wvla
#     variable length array used
-Wweak-template-vtables
#     explicit template instantiation A will emit a vtable in every translation unit
-Wweak-vtables
#     A has no out-of-line virtual method definitions; its vtable will be emitted in every translation unit
